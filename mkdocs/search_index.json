{
    "docs": [
        {
            "location": "/", 
            "text": "Intro to Plots in Julia\n\n\nAuthor: Thomas Breloff (@tbreloff)\n\n\nData visualization has a complicated history, with plotting software making trade-offs between features vs simplicity, speed vs beauty, and static vs dynamic.  Some make a visualization and never change it, others must make updates in real-time.\n\n\nPlots is a visualization interface and toolset.  It sits above other visualization \"backends\", connecting commands with implementation.  If one backend does not support your desired features, or make the right trade-offs, just switch to another backend with one command.  No need to change your code.  No need to learn something new.  Plots might be the last plotting package you ever learn.\n\n\nMy goals with the package are:\n\n\n\n\nPowerful\n.  Do more with less.  Complex visualizations become easy.\n\n\nIntuitive\n.  Start generating plots without reading volumes of documentation.  Commands should \"just work\".\n\n\nConcise\n.  Less code means fewer mistakes and more efficient development/analysis.\n\n\nFlexible\n.  Produce your favorite plots from your favorite package, but quicker and simpler.\n\n\nConsistent\n.  Don't commit to one graphics package.  Use the same code and access the strengths of all \nbackends\n.\n\n\nLightweight\n.  Very few dependencies, since backends are loaded and initialized dynamically.\n\n\nSmart\n.  It's not quite AGI, but Plots should figure out what you \nwant\n it to do... not just what you \ntell\n it.\n\n\n\n\nUse the \npreprocessing pipeline\n in Plots to fully describe your visualization before it calls the backend code.  This maintains modularity and allows for efficient separation of front end code, algorithms, and backend graphics.\n\n\nTap into the extensive visualization functionality enabled by the \nPlots ecosystem\n, and easily build your own complex graphics components with \nrecipes\n.\n\n\nPlease add wishlist items, bugs, or any other comments/questions to the \nissues list\n, and \njoin the conversation on gitter\n.\n\n\n\n\nSimple is Beautiful\n\n\nLorenz Attractor\n\n\n# initialize the attractor\n\n\nn\n \n=\n \n1500\n\n\ndt\n \n=\n \n0.02\n\n\n\u03c3\n,\n \n\u03c1\n,\n \n\u03b2\n \n=\n \n10.\n,\n \n28.\n,\n \n8\n/\n3\n\n\nx\n,\n \ny\n,\n \nz\n \n=\n \n1.\n,\n \n1.\n,\n \n1.\n\n\n\n# initialize a 3D plot with 1 empty series\n\n\nplt\n \n=\n \npath3d\n(\n1\n,\n \nxlim\n=\n(\n-\n25\n,\n25\n),\n \nylim\n=\n(\n-\n25\n,\n25\n),\n \nzlim\n=\n(\n0\n,\n50\n),\n\n                \nxlab\n \n=\n \nx\n,\n \nylab\n \n=\n \ny\n,\n \nzlab\n \n=\n \nz\n,\n\n                \ntitle\n \n=\n \nLorenz Attractor\n,\n \nmarker\n \n=\n \n1\n)\n\n\n\n# build an animated gif, saving every 10th frame\n\n\n@\ngif\n \nfor\n \ni\n=\n1\n:\nn\n\n    \ndx\n \n=\n \n\u03c3\n*\n(\ny\n \n-\n \nx\n)\n     \n;\n \nx\n \n+=\n \ndt\n \n*\n \ndx\n\n    \ndy\n \n=\n \nx\n*\n(\n\u03c1\n \n-\n \nz\n)\n \n-\n \ny\n \n;\n \ny\n \n+=\n \ndt\n \n*\n \ndy\n\n    \ndz\n \n=\n \nx\n*\ny\n \n-\n \n\u03b2\n*\nz\n     \n;\n \nz\n \n+=\n \ndt\n \n*\n \ndz\n\n    \npush!\n(\nplt\n,\n \nx\n,\n \ny\n,\n \nz\n)\n\n\nend\n \nevery\n \n10\n\n\n\n\n\n\n\n\nMake some waves\n\n\nusing\n \nPlots\n\n\npyplot\n(\nleg\n=\nfalse\n,\n \nticks\n=\nnothing\n)\n\n\nx\n \n=\n \ny\n \n=\n \nlinspace\n(\n-\n5\n,\n \n5\n,\n \n40\n)\n\n\nzs\n \n=\n \nzeros\n(\n0\n,\n40\n)\n\n\n\n@\ngif\n \nfor\n \ni\n \nin\n \nlinspace\n(\n0\n,\n \n2\n\u03c0\n,\n \n100\n)\n\n    \nf\n(\nx\n,\ny\n)\n \n=\n \nsin\n(\nx\n \n+\n \n10\nsin\n(\ni\n))\n \n+\n \ncos\n(\ny\n)\n\n\n    \n# create a plot with 3 subplots and a custom layout\n\n    \nl\n \n=\n \n@\nlayout\n \n[\na\n{\n0.7\nw\n}\n \nb\n;\n \nc\n{\n0.2\nh\n}]\n\n    \np\n \n=\n \nplot\n(\nx\n,\n \ny\n,\n \nf\n,\n \nst\n \n=\n \n[:\nsurface\n,\n \n:\ncontourf\n],\n \nlayout\n=\nl\n)\n\n\n    \n# add a tracking line\n\n    \nfixed_x\n \n=\n \nzeros\n(\n40\n)\n\n    \nz\n \n=\n \nmap\n(\nf\n,\nfixed_x\n,\ny\n)\n\n    \nplot!\n(\np\n[\n1\n],\n \nfixed_x\n,\n \ny\n,\n \nz\n,\n \nline\n \n=\n \n(:\nblack\n,\n \n5\n,\n \n0.2\n))\n\n    \nvline!\n(\np\n[\n2\n],\n \n[\n0\n],\n \nline\n \n=\n \n(:\nblack\n,\n \n5\n))\n\n\n    \n# add to and show the tracked values over time\n\n    \nzs\n \n=\n \nvcat\n(\nzs\n,\n \nz\n)\n\n    \nplot!\n(\np\n[\n3\n],\n \nzs\n,\n \nalpha\n \n=\n \n0.2\n,\n \npalette\n \n=\n \ncgrad\n(:\nblues\n)\n.\ncolors\n)\n\n\nend\n\n\n\n\n\n\n\n\nIris Dataset\n\n\n# load a dataset\n\n\nusing\n \nRDatasets\n\n\niris\n \n=\n \ndataset\n(\ndatasets\n,\n \niris\n);\n\n\n\n# load the StatPlots recipes (for DataFrames) available via:\n\n\n# Pkg.add(\nStatPlots\n)\n\n\nusing\n \nStatPlots\n\n\n\n# Scatter plot with some custom settings\n\n\nscatter\n(\niris\n,\n \n:\nSepalLength\n,\n \n:\nSepalWidth\n,\n \ngroup\n=\n:\nSpecies\n,\n\n        \ntitle\n \n=\n \nMy awesome plot\n,\n\n        \nxlabel\n \n=\n \nLength\n,\n \nylabel\n \n=\n \nWidth\n,\n\n        \nm\n=\n(\n0.5\n,\n \n[:\n+\n \n:\nh\n \n:\nstar7\n],\n \n12\n),\n\n        \nbg\n=\nRGB\n(\n.\n2\n,\n.\n2\n,\n.\n2\n))\n\n\n\n# save a png\n\n\npng\n(\niris\n)", 
            "title": "Home"
        }, 
        {
            "location": "/#intro-to-plots-in-julia", 
            "text": "Author: Thomas Breloff (@tbreloff)  Data visualization has a complicated history, with plotting software making trade-offs between features vs simplicity, speed vs beauty, and static vs dynamic.  Some make a visualization and never change it, others must make updates in real-time.  Plots is a visualization interface and toolset.  It sits above other visualization \"backends\", connecting commands with implementation.  If one backend does not support your desired features, or make the right trade-offs, just switch to another backend with one command.  No need to change your code.  No need to learn something new.  Plots might be the last plotting package you ever learn.  My goals with the package are:   Powerful .  Do more with less.  Complex visualizations become easy.  Intuitive .  Start generating plots without reading volumes of documentation.  Commands should \"just work\".  Concise .  Less code means fewer mistakes and more efficient development/analysis.  Flexible .  Produce your favorite plots from your favorite package, but quicker and simpler.  Consistent .  Don't commit to one graphics package.  Use the same code and access the strengths of all  backends .  Lightweight .  Very few dependencies, since backends are loaded and initialized dynamically.  Smart .  It's not quite AGI, but Plots should figure out what you  want  it to do... not just what you  tell  it.   Use the  preprocessing pipeline  in Plots to fully describe your visualization before it calls the backend code.  This maintains modularity and allows for efficient separation of front end code, algorithms, and backend graphics.  Tap into the extensive visualization functionality enabled by the  Plots ecosystem , and easily build your own complex graphics components with  recipes .  Please add wishlist items, bugs, or any other comments/questions to the  issues list , and  join the conversation on gitter .", 
            "title": "Intro to Plots in Julia"
        }, 
        {
            "location": "/#simple-is-beautiful", 
            "text": "Lorenz Attractor  # initialize the attractor  n   =   1500  dt   =   0.02  \u03c3 ,   \u03c1 ,   \u03b2   =   10. ,   28. ,   8 / 3  x ,   y ,   z   =   1. ,   1. ,   1.  # initialize a 3D plot with 1 empty series  plt   =   path3d ( 1 ,   xlim = ( - 25 , 25 ),   ylim = ( - 25 , 25 ),   zlim = ( 0 , 50 ), \n                 xlab   =   x ,   ylab   =   y ,   zlab   =   z , \n                 title   =   Lorenz Attractor ,   marker   =   1 )  # build an animated gif, saving every 10th frame  @ gif   for   i = 1 : n \n     dx   =   \u03c3 * ( y   -   x )       ;   x   +=   dt   *   dx \n     dy   =   x * ( \u03c1   -   z )   -   y   ;   y   +=   dt   *   dy \n     dz   =   x * y   -   \u03b2 * z       ;   z   +=   dt   *   dz \n     push! ( plt ,   x ,   y ,   z )  end   every   10    Make some waves  using   Plots  pyplot ( leg = false ,   ticks = nothing )  x   =   y   =   linspace ( - 5 ,   5 ,   40 )  zs   =   zeros ( 0 , 40 )  @ gif   for   i   in   linspace ( 0 ,   2 \u03c0 ,   100 ) \n     f ( x , y )   =   sin ( x   +   10 sin ( i ))   +   cos ( y ) \n\n     # create a plot with 3 subplots and a custom layout \n     l   =   @ layout   [ a { 0.7 w }   b ;   c { 0.2 h }] \n     p   =   plot ( x ,   y ,   f ,   st   =   [: surface ,   : contourf ],   layout = l ) \n\n     # add a tracking line \n     fixed_x   =   zeros ( 40 ) \n     z   =   map ( f , fixed_x , y ) \n     plot! ( p [ 1 ],   fixed_x ,   y ,   z ,   line   =   (: black ,   5 ,   0.2 )) \n     vline! ( p [ 2 ],   [ 0 ],   line   =   (: black ,   5 )) \n\n     # add to and show the tracked values over time \n     zs   =   vcat ( zs ,   z ) \n     plot! ( p [ 3 ],   zs ,   alpha   =   0.2 ,   palette   =   cgrad (: blues ) . colors )  end    Iris Dataset  # load a dataset  using   RDatasets  iris   =   dataset ( datasets ,   iris );  # load the StatPlots recipes (for DataFrames) available via:  # Pkg.add( StatPlots )  using   StatPlots  # Scatter plot with some custom settings  scatter ( iris ,   : SepalLength ,   : SepalWidth ,   group = : Species , \n         title   =   My awesome plot , \n         xlabel   =   Length ,   ylabel   =   Width , \n         m = ( 0.5 ,   [: +   : h   : star7 ],   12 ), \n         bg = RGB ( . 2 , . 2 , . 2 ))  # save a png  png ( iris )", 
            "title": "Simple is Beautiful"
        }, 
        {
            "location": "/install/", 
            "text": "Install\n\n\nFirst, add the package\n\n\nPkg\n.\nadd\n(\nPlots\n)\n\n\n\n# if you want the latest features:\n\n\nPkg\n.\ncheckout\n(\nPlots\n)\n\n\n\n# or for the bleeding edge:\n\n\nPkg\n.\ncheckout\n(\nPlots\n,\n \ndev\n)\n\n\n\n\n\n\nthen get any plotting packages you need (obviously, you should get at least one \nbackend\n).\n\n\nPkg\n.\nadd\n(\nPyPlot\n)\n\n\nPkg\n.\nadd\n(\nGR\n)\n\n\nPkg\n.\nadd\n(\nUnicodePlots\n)\n\n\nPkg\n.\nadd\n(\nPlotlyJS\n)\n\n\n\n\n\n\nFinally, you may wish to add some extensions from the \nPlots ecosystem\n:\n\n\nPkg\n.\nadd\n(\nStatPlots\n)\n\n\nPkg\n.\nadd\n(\nPlotRecipes\n)\n\n\n\n\n\n\n\n\nInitialize\n\n\nusing\n \nPlots\n \n# or StatPlots, or PlotRecipes\n\n\n\n\n\n\nChoose a backend\n, and optionally override default settings at the same time:\n\n\npyplot\n(\nsize\n \n=\n \n(\n300\n,\n300\n),\n \nlegend\n \n=\n \nfalse\n)\n\n\n\n\n\n\n\nTip: Backend methods are lowercase, and match the corresponding backend package name.\n\n\n\n\n\nTip: The underlying plotting backends are not imported and initialized immediately, thus they are\nloaded on demand to reduce dependencies.\n\n\n\n\n\nTip: Plots will pick a default backend for you automatically based on what backends are installed.  You can\noverride this choice by setting an environment variable in your ~/.juliarc.jl file: ENV[\"PLOTS_DEFAULT_BACKEND\"] = \"PlotlyJS\"\n\n\n\n\n\nTip: You can override standard default values in your ~/.juliarc.jl file: PLOTS_DEFAULTS = Dict(:markersize => 10, :legend => false)", 
            "title": "Installation"
        }, 
        {
            "location": "/install/#install", 
            "text": "First, add the package  Pkg . add ( Plots )  # if you want the latest features:  Pkg . checkout ( Plots )  # or for the bleeding edge:  Pkg . checkout ( Plots ,   dev )   then get any plotting packages you need (obviously, you should get at least one  backend ).  Pkg . add ( PyPlot )  Pkg . add ( GR )  Pkg . add ( UnicodePlots )  Pkg . add ( PlotlyJS )   Finally, you may wish to add some extensions from the  Plots ecosystem :  Pkg . add ( StatPlots )  Pkg . add ( PlotRecipes )", 
            "title": "Install"
        }, 
        {
            "location": "/install/#initialize", 
            "text": "using   Plots   # or StatPlots, or PlotRecipes   Choose a backend , and optionally override default settings at the same time:  pyplot ( size   =   ( 300 , 300 ),   legend   =   false )   \nTip: Backend methods are lowercase, and match the corresponding backend package name.  \nTip: The underlying plotting backends are not imported and initialized immediately, thus they are\nloaded on demand to reduce dependencies.  \nTip: Plots will pick a default backend for you automatically based on what backends are installed.  You can\noverride this choice by setting an environment variable in your ~/.juliarc.jl file: ENV[\"PLOTS_DEFAULT_BACKEND\"] = \"PlotlyJS\"  \nTip: You can override standard default values in your ~/.juliarc.jl file: PLOTS_DEFAULTS = Dict(:markersize => 10, :legend => false)", 
            "title": "Initialize"
        }, 
        {
            "location": "/backends/", 
            "text": "Backends\n\n\nBackends are the lifeblood of Plots, and the diversity between features, approaches, and strengths/weaknesses was \none of the primary reasons that I started this package.\n\n\nFor those who haven't had the pleasure of hacking on 15 different plotting APIs:  First, consider yourself lucky.  However,\nyou will probably have a hard time choosing the right backend for your task at hand.  This document is meant to be a guide and \nintroduction to making that choice.\n\n\nFor the impatient\n\n\nMy favorites: GR for speed, Plotly(JS) for interactivity, PyPlot otherwise.\n\n\n\n\n\n\n\n\nIf you require...\n\n\n... then use...\n\n\n\n\n\n\n\n\n\n\nfeatures\n\n\nPyPlot, Plotly(JS), GR\n\n\n\n\n\n\nspeed\n\n\nGR\n\n\n\n\n\n\ninteractivity\n\n\nPlotly(JS)\n\n\n\n\n\n\nbeauty\n\n\nPlotly(JS), PGFPlots\n\n\n\n\n\n\nREPL Plotting\n\n\nUnicodePlots\n\n\n\n\n\n\n3D plots\n\n\nPyPlot, GR, Plotly(JS)\n\n\n\n\n\n\na GUI Window\n\n\nGR, PyPlot, PlotlyJS\n\n\n\n\n\n\na small footprint\n\n\nUnicodePlots, Plotly\n\n\n\n\n\n\n\n\nOf course nothing in life is that simple.  Likely there are subtle tradeoffs between backends, long hidden bugs, and more excitement.  Don't be shy to try out something new!\n\n\n\n\nPyPlot\n\n\nA Julia wrapper around the popular python package PyPlot (Matplotlib).  It uses PyCall.jl to pass data with minimal overhead.\n\n\n\n\nPros:\n\n\n\n\nTons of functionality\n\n\n2D and 3D\n\n\nMature library\n\n\nStandalone or inline\n\n\nWell supported in Plots\n\n\n\n\nCons:\n\n\n\n\nUses python\n\n\nDependencies frequently cause setup issues\n\n\nInconsistent output depending on Matplotlib version\n\n\n\n\nPrimary author: Steven G Johnson (@stevengj)\n\n\nPlotly / PlotlyJS\n\n\nThese are treated as separate backends, though they share much of the code and use the Plotly javascript API.  \nplotly()\n is the only dependency-free plotting option,\nas the required javascript is bundled with Plots.  It can create inline plots in IJulia, or open standalone browser windows when run from the Julia REPL.\n\n\nplotlyjs()\n is the preferred option, and taps into the great functionality of Spencer Lyon's PlotlyJS.jl.  Inline IJulia plots can be updated from any cell... something that\nmakes this backend stand out.  From the Julia REPL, it taps into Blink.jl and Electron to plot within a standalone GUI window... also very cool.\n\n\n\n\nPros:\n\n\n\n\nTons of functionality\n\n\n2D and 3D\n\n\nMature library\n\n\nInteractivity (even when inline)\n\n\nStandalone or inline\n\n\n\n\nCons:\n\n\n\n\nNo custom shapes\n\n\nJSON may limit performance\n\n\n\n\nPrimary PlotlyJS.jl author: Spencer Lyon (@spencerlyon2)\n\n\nGR\n\n\nSuper fast with lots of plot types.  Still actively developed and improving daily.\n\n\n\n\nPros:\n\n\n\n\nSpeed\n\n\n2D and 3D\n\n\nStandalone or inline\n\n\n\n\nCons:\n\n\n\n\nLimited interactivity\n\n\nPlots integration is still a work in progress\n\n\n\n\nPrimary author: Josef Heinen (@jheinen)\n\n\nUnicodePlots\n\n\nSimple and lightweight.  Plot directly in your terminal.  You won't produce anything publication quality, but for a quick look at your data it is awesome.\n\n\n\n\nPros:\n\n\n\n\nMinimal dependencies\n\n\nLightweight\n\n\nFast\n\n\nREPL plotting\n\n\n\n\nCons:\n\n\n\n\nLimited functionality\n\n\n\n\nPrimary author: Christof Stocker (@Evizero)\n\n\nPGFPlots\n\n\nLaTeX plotting, based on PGF/TikZ.\n\n\n\n\nPros:\n\n\n\n\nNice looking plots\n\n\nLots of functionality (though the code is still WIP)\n\n\n\n\nCons:\n\n\n\n\nTricky to install\n\n\nHeavy-weight dependencies\n\n\n\n\nAuthors:\n\n\n\n\nPGFPlots: Christian Feuersanger\n\n\nPGFPlots.jl: Mykel Kochenderfer (@mykelk),  Louis Dressel (@dressel), and others\n\n\nPlots \n--\n PGFPlots link code: Patrick Kofod Mogensen (@pkofod)\n\n\n\n\n\n\nThe future: works in progress\n\n\nGLVisualize\n\n\nA really awesome 2D/3D visualization library written in Julia and OpenGL.  It is feature-packed and fast, and author Simon Danisch has put a ton of energy into its development.  I'm very excited for the day that this is cleanly wrapped.\n\n\n\n\nDeprecated backends\n\n\nGadfly\n\n\nA Julia implementation inspired by the \"Grammar of Graphics\".\n\n\nPros:\n\n\n\n\nClean look\n\n\nLots of features\n\n\nFlexible when combined with Compose.jl (inset plots, etc)\n\n\n\n\nCons:\n\n\n\n\nDo not support 3D\n\n\nSlow time-to-first-plot\n\n\nLots of dependencies\n\n\nNo interactivity\n\n\n\n\nPrimary author: Daniel C Jones\n\n\nImmerse\n\n\nBuilt on top of Gadfly, Immerse adds some interactivity and a standalone GUI window, including zoom/pan and a cool \"point lasso\" tool to save Julia vectors with the selected data points.\n\n\nPros:\n\n\n\n\nSame as Gadfly\n\n\nInteractivity\n\n\nStandalone or inline\n\n\nLasso functionality\n\n\n\n\nCons:\n\n\n\n\nSame as Gadfly\n\n\n\n\nPrimary author: Tim Holy\n\n\nQwt\n\n\nMy package which wraps PyQwt.  Similar to PyPlot, it uses PyCall to convert calls to python.  Though Qwt.jl was the \"first draft\" of Plots, the functionality is superceded by other backends, and it's not worth my time to maintain.\n\n\nPrimary author: Thomas Breloff\n\n\nBokeh\n\n\nUnfinished, but very similar to PlotlyJS... use that instead.\n\n\nWinston\n\n\nFunctionality incomplete... I never finished wrapping it, and I don't think it offers anything beyond other backends.  However, the plots are clean looking and it's relatively fast.", 
            "title": "Backends"
        }, 
        {
            "location": "/backends/#backends", 
            "text": "Backends are the lifeblood of Plots, and the diversity between features, approaches, and strengths/weaknesses was \none of the primary reasons that I started this package.  For those who haven't had the pleasure of hacking on 15 different plotting APIs:  First, consider yourself lucky.  However,\nyou will probably have a hard time choosing the right backend for your task at hand.  This document is meant to be a guide and \nintroduction to making that choice.", 
            "title": "Backends"
        }, 
        {
            "location": "/backends/#for-the-impatient", 
            "text": "My favorites: GR for speed, Plotly(JS) for interactivity, PyPlot otherwise.     If you require...  ... then use...      features  PyPlot, Plotly(JS), GR    speed  GR    interactivity  Plotly(JS)    beauty  Plotly(JS), PGFPlots    REPL Plotting  UnicodePlots    3D plots  PyPlot, GR, Plotly(JS)    a GUI Window  GR, PyPlot, PlotlyJS    a small footprint  UnicodePlots, Plotly     Of course nothing in life is that simple.  Likely there are subtle tradeoffs between backends, long hidden bugs, and more excitement.  Don't be shy to try out something new!", 
            "title": "For the impatient"
        }, 
        {
            "location": "/backends/#pyplot", 
            "text": "A Julia wrapper around the popular python package PyPlot (Matplotlib).  It uses PyCall.jl to pass data with minimal overhead.   Pros:   Tons of functionality  2D and 3D  Mature library  Standalone or inline  Well supported in Plots   Cons:   Uses python  Dependencies frequently cause setup issues  Inconsistent output depending on Matplotlib version   Primary author: Steven G Johnson (@stevengj)", 
            "title": "PyPlot"
        }, 
        {
            "location": "/backends/#plotly-plotlyjs", 
            "text": "These are treated as separate backends, though they share much of the code and use the Plotly javascript API.   plotly()  is the only dependency-free plotting option,\nas the required javascript is bundled with Plots.  It can create inline plots in IJulia, or open standalone browser windows when run from the Julia REPL.  plotlyjs()  is the preferred option, and taps into the great functionality of Spencer Lyon's PlotlyJS.jl.  Inline IJulia plots can be updated from any cell... something that\nmakes this backend stand out.  From the Julia REPL, it taps into Blink.jl and Electron to plot within a standalone GUI window... also very cool.   Pros:   Tons of functionality  2D and 3D  Mature library  Interactivity (even when inline)  Standalone or inline   Cons:   No custom shapes  JSON may limit performance   Primary PlotlyJS.jl author: Spencer Lyon (@spencerlyon2)", 
            "title": "Plotly / PlotlyJS"
        }, 
        {
            "location": "/backends/#gr", 
            "text": "Super fast with lots of plot types.  Still actively developed and improving daily.   Pros:   Speed  2D and 3D  Standalone or inline   Cons:   Limited interactivity  Plots integration is still a work in progress   Primary author: Josef Heinen (@jheinen)", 
            "title": "GR"
        }, 
        {
            "location": "/backends/#unicodeplots", 
            "text": "Simple and lightweight.  Plot directly in your terminal.  You won't produce anything publication quality, but for a quick look at your data it is awesome.   Pros:   Minimal dependencies  Lightweight  Fast  REPL plotting   Cons:   Limited functionality   Primary author: Christof Stocker (@Evizero)", 
            "title": "UnicodePlots"
        }, 
        {
            "location": "/backends/#pgfplots", 
            "text": "LaTeX plotting, based on PGF/TikZ.   Pros:   Nice looking plots  Lots of functionality (though the code is still WIP)   Cons:   Tricky to install  Heavy-weight dependencies   Authors:   PGFPlots: Christian Feuersanger  PGFPlots.jl: Mykel Kochenderfer (@mykelk),  Louis Dressel (@dressel), and others  Plots  --  PGFPlots link code: Patrick Kofod Mogensen (@pkofod)", 
            "title": "PGFPlots"
        }, 
        {
            "location": "/backends/#the-future-works-in-progress", 
            "text": "", 
            "title": "The future: works in progress"
        }, 
        {
            "location": "/backends/#glvisualize", 
            "text": "A really awesome 2D/3D visualization library written in Julia and OpenGL.  It is feature-packed and fast, and author Simon Danisch has put a ton of energy into its development.  I'm very excited for the day that this is cleanly wrapped.", 
            "title": "GLVisualize"
        }, 
        {
            "location": "/backends/#deprecated-backends", 
            "text": "", 
            "title": "Deprecated backends"
        }, 
        {
            "location": "/backends/#gadfly", 
            "text": "A Julia implementation inspired by the \"Grammar of Graphics\".  Pros:   Clean look  Lots of features  Flexible when combined with Compose.jl (inset plots, etc)   Cons:   Do not support 3D  Slow time-to-first-plot  Lots of dependencies  No interactivity   Primary author: Daniel C Jones", 
            "title": "Gadfly"
        }, 
        {
            "location": "/backends/#immerse", 
            "text": "Built on top of Gadfly, Immerse adds some interactivity and a standalone GUI window, including zoom/pan and a cool \"point lasso\" tool to save Julia vectors with the selected data points.  Pros:   Same as Gadfly  Interactivity  Standalone or inline  Lasso functionality   Cons:   Same as Gadfly   Primary author: Tim Holy", 
            "title": "Immerse"
        }, 
        {
            "location": "/backends/#qwt", 
            "text": "My package which wraps PyQwt.  Similar to PyPlot, it uses PyCall to convert calls to python.  Though Qwt.jl was the \"first draft\" of Plots, the functionality is superceded by other backends, and it's not worth my time to maintain.  Primary author: Thomas Breloff", 
            "title": "Qwt"
        }, 
        {
            "location": "/backends/#bokeh", 
            "text": "Unfinished, but very similar to PlotlyJS... use that instead.", 
            "title": "Bokeh"
        }, 
        {
            "location": "/backends/#winston", 
            "text": "Functionality incomplete... I never finished wrapping it, and I don't think it offers anything beyond other backends.  However, the plots are clean looking and it's relatively fast.", 
            "title": "Winston"
        }, 
        {
            "location": "/basics/", 
            "text": "Basic Concepts\n\n\nUse \nplot\n to create a new plot object, and \nplot!\n to add to an existing one:\n\n\nplot\n(\nargs\n...\n;\n \nkw\n...\n)\n                  \n# creates a new Plot, and set it to be the `current`\n\n\nplot!\n(\nargs\n...\n;\n \nkw\n...\n)\n                 \n# modifies Plot `current()`\n\n\nplot!\n(\nplt\n,\n \nargs\n...\n;\n \nkw\n...\n)\n            \n# modifies Plot `plt`\n\n\n\n\n\n\nThe graphic is not shown implicitly, only when \"displayed\".  This will happen automatically when returned to a REPL prompt or to an IJulia cell.  There are \nmany other options\n as well.\n\n\nInput arguments can take \nmany forms\n.  Some valid examples:\n\n\nplot\n()\n                                    \n# empty Plot object\n\n\nplot\n(\n4\n)\n                                   \n# initialize with 4 empty series\n\n\nplot\n(\nrand\n(\n10\n))\n                            \n# 1 series... x = 1:10\n\n\nplot\n(\nrand\n(\n10\n,\n5\n))\n                          \n# 5 series... x = 1:10\n\n\nplot\n(\nrand\n(\n10\n),\n \nrand\n(\n10\n))\n                  \n# 1 series\n\n\nplot\n(\nrand\n(\n10\n,\n5\n),\n \nrand\n(\n10\n))\n                \n# 5 series... y is the same for all\n\n\nplot\n(\nsin\n,\n \nrand\n(\n10\n))\n                       \n# y = sin(x)\n\n\nplot\n(\nrand\n(\n10\n),\n \nsin\n)\n                       \n# same... y = sin(x)\n\n\nplot\n([\nsin\n,\ncos\n],\n \n0\n:\n0.1\n:\n\u03c0\n)\n                  \n# 2 series, sin(x) and cos(x)\n\n\nplot\n([\nsin\n,\ncos\n],\n \n0\n,\n \n\u03c0\n)\n                     \n# sin and cos on the range [0, \u03c0]\n\n\nplot\n(\n1\n:\n10\n,\n \nAny\n[\nrand\n(\n10\n),\n \nsin\n])\n            \n# 2 series: rand(10) and map(sin,x)\n\n\nplot\n(\ndataset\n(\nEcdat\n,\n \nAirline\n),\n \n:\nCost\n)\n  \n# the :Cost column from a DataFrame... must import StatPlots\n\n\n\n\n\n\nKeyword arguments\n allow for customization of the plot, subplots, axes, and series.  They follow consistent rules as much as possible, and you'll avoid common pitfalls if you read this section carefully:\n\n\n\n\nMany arguments have aliases which are \nreplaced during preprocessing\n.  \nc\n is the same as \ncolor\n, \nm\n is the same as \nmarker\n, etc.  You can choose a verbosity that you are comfortable with.\n\n\nThere are some \nspecial arguments\n which magically set many related things at once.\n\n\nIf the argument is a \"matrix-type\", then \neach column will map to a series\n, cycling through columns if there are fewer columns than series.  In this sense, a vector is treated just like an \"nx1 matrix\".\n\n\nMany arguments accept many different types... for example the color (also markercolor, fillcolor, etc) argument will accept strings or symbols with a color name, or any Colors.Colorant, or a ColorScheme, or a symbol representing a ColorGradient, or an AbstractVector of colors/symbols/etc...\n\n\n\n\n\n\nUseful Tips\n\n\n\nTip: A common error is to pass a Vector when you intend for each item to apply to only one series.  Instead of an n-length Vector, pass a 1xn Matrix.\n\n\n\n\n\n  \nTip: You can update certain plot settings after plot creation:\n\n  \n\n    plot!(title = \"New Title\", xlabel = \"New xlabel\", ylabel = \"New ylabel\")\n    plot!(xlims = (0, 5.5), ylims = (-2.2, 6), xticks = 0:0.5:10, yticks = [0,1,5,10])\n\n    # or using magic:\n    plot!(xaxis = (\"mylabel\", :log10, :flip))\n    xaxis!(\"mylabel\", :log10, :flip)\n  \n\n\n\n\n\n\nTip: With \nsupported backends\n, you can pass a Plots.Shape object for the marker/markershape arguments.  Shape takes a vector of 2-tuples in the constructor, defining the points of the polygon's shape in a unit-scaled coordinate space.  To make a square, for example, you could do: Shape([(1,1),(1,-1),(-1,-1),(-1,1)])\n\n\n\n\n\nTip: You can see the default value for a given argument with default(arg::Symbol), and set the default value with default(arg::Symbol, value) or default(; kw...).  For example set the\ndefault window size and whether we should show a legend with default(size=(600,400), leg=false).\n\n\n\n\n\nTip: Call `gui()` to display the plot in a window.  Interactivity depends on backend.  Plotting at the REPL (without semicolon) implicitly calls `gui()`.\n\n\n\n\n\nTip: See the \nexamples\n for plotting ideas and features.", 
            "title": "Basics"
        }, 
        {
            "location": "/basics/#basic-concepts", 
            "text": "Use  plot  to create a new plot object, and  plot!  to add to an existing one:  plot ( args ... ;   kw ... )                    # creates a new Plot, and set it to be the `current`  plot! ( args ... ;   kw ... )                   # modifies Plot `current()`  plot! ( plt ,   args ... ;   kw ... )              # modifies Plot `plt`   The graphic is not shown implicitly, only when \"displayed\".  This will happen automatically when returned to a REPL prompt or to an IJulia cell.  There are  many other options  as well.  Input arguments can take  many forms .  Some valid examples:  plot ()                                      # empty Plot object  plot ( 4 )                                     # initialize with 4 empty series  plot ( rand ( 10 ))                              # 1 series... x = 1:10  plot ( rand ( 10 , 5 ))                            # 5 series... x = 1:10  plot ( rand ( 10 ),   rand ( 10 ))                    # 1 series  plot ( rand ( 10 , 5 ),   rand ( 10 ))                  # 5 series... y is the same for all  plot ( sin ,   rand ( 10 ))                         # y = sin(x)  plot ( rand ( 10 ),   sin )                         # same... y = sin(x)  plot ([ sin , cos ],   0 : 0.1 : \u03c0 )                    # 2 series, sin(x) and cos(x)  plot ([ sin , cos ],   0 ,   \u03c0 )                       # sin and cos on the range [0, \u03c0]  plot ( 1 : 10 ,   Any [ rand ( 10 ),   sin ])              # 2 series: rand(10) and map(sin,x)  plot ( dataset ( Ecdat ,   Airline ),   : Cost )    # the :Cost column from a DataFrame... must import StatPlots   Keyword arguments  allow for customization of the plot, subplots, axes, and series.  They follow consistent rules as much as possible, and you'll avoid common pitfalls if you read this section carefully:   Many arguments have aliases which are  replaced during preprocessing .   c  is the same as  color ,  m  is the same as  marker , etc.  You can choose a verbosity that you are comfortable with.  There are some  special arguments  which magically set many related things at once.  If the argument is a \"matrix-type\", then  each column will map to a series , cycling through columns if there are fewer columns than series.  In this sense, a vector is treated just like an \"nx1 matrix\".  Many arguments accept many different types... for example the color (also markercolor, fillcolor, etc) argument will accept strings or symbols with a color name, or any Colors.Colorant, or a ColorScheme, or a symbol representing a ColorGradient, or an AbstractVector of colors/symbols/etc...", 
            "title": "Basic Concepts"
        }, 
        {
            "location": "/basics/#useful-tips", 
            "text": "Tip: A common error is to pass a Vector when you intend for each item to apply to only one series.  Instead of an n-length Vector, pass a 1xn Matrix.  \n   Tip: You can update certain plot settings after plot creation: \n   \n    plot!(title = \"New Title\", xlabel = \"New xlabel\", ylabel = \"New ylabel\")\n    plot!(xlims = (0, 5.5), ylims = (-2.2, 6), xticks = 0:0.5:10, yticks = [0,1,5,10])\n\n    # or using magic:\n    plot!(xaxis = (\"mylabel\", :log10, :flip))\n    xaxis!(\"mylabel\", :log10, :flip)\n     \nTip: With  supported backends , you can pass a Plots.Shape object for the marker/markershape arguments.  Shape takes a vector of 2-tuples in the constructor, defining the points of the polygon's shape in a unit-scaled coordinate space.  To make a square, for example, you could do: Shape([(1,1),(1,-1),(-1,-1),(-1,1)])  \nTip: You can see the default value for a given argument with default(arg::Symbol), and set the default value with default(arg::Symbol, value) or default(; kw...).  For example set the\ndefault window size and whether we should show a legend with default(size=(600,400), leg=false).  \nTip: Call `gui()` to display the plot in a window.  Interactivity depends on backend.  Plotting at the REPL (without semicolon) implicitly calls `gui()`.  \nTip: See the  examples  for plotting ideas and features.", 
            "title": "Useful Tips"
        }, 
        {
            "location": "/input_data/", 
            "text": "Input Data\n\n\nPart of the power of Plots lies is in the many combinations of allowed input data.\nYou shouldn't spend your time transforming and massaging your data into a specific format.\nLet Plots do that for you.\n\n\nThere are a few rules to remember, and you'll be a power user in no time.\n\n\nInputs are arguments, not keywords\n\n\nWhile \nplot(x = 1:10, y = rand(10))\n will work as expected, it is not the preferred method.  In fact,\nthis method will simply call \nplot(1:10, rand(10))\n.  Instead,\nuse \nplot(rand(10))\n.  In this case, a single input will be mapped to the \n:y\n keyword, and a missing\nvalue for \n:x\n will impute a unit range \n1:10\n.\n\n\nThe reason lies in the flexibility of Julia's multiple dispatch, where every combination of input types\ncan have unique behavior, when desired.\n\n\nColumns are series\n\n\nIn most cases, passing a (n x m) matrix of values (numbers, etc) will create \nm\n series, each with \nn\n data points.  This follows a consistent rule... vectors apply to a series, matrices apply to many series.  This rule carries into keyword arguments.  \nplot(rand(10,4), color = [:red, :blue])\n will create 4 series, each assigned the color vector [:red,:blue].  However, \nplot(rand(10,4), color = [:red :blue])\n will create 4 series, with series 1 and 3 taking the color \n:red\n and series 2 and 4 taking the color \n:blue\n.  The difference is that in the first example, it is a length-2 column vector, and in the second example it is a (1 x 2) row vector (a Matrix).\n\n\nDataFrames support\n\n\nIf you have DataFrames installed, some convenience functionality is turned on.  (Those coming from R will appreciate it.)  The first argument should be the \nDataFrame\n, and subsequent \nSymbol\n arguments will be mapped to the corresponding column in that \nDataFrame\n.  Example:\n\n\nusing\n \nDataFrames\n,\n \nPlots\n;\n \ngadfly\n()\n\n\nusing\n \nRDatasets\n;\n \niris\n \n=\n \ndataset\n(\ndatasets\n,\n \niris\n)\n\n\n\nscatter\n(\niris\n,\n \n:\nSepalLength\n,\n \n:\nSepalWidth\n,\n \ngroup\n=\n:\nSpecies\n,\n\n        \ntitle\n \n=\n \nMy awesome plot\n,\n \nxlabel\n \n=\n \nLength\n,\n \nylabel\n \n=\n \nWidth\n,\n\n        \nm\n=\n(\n0.5\n,\n \n[:\n+\n \n:\nh\n \n:\nstar7\n],\n \n12\n),\n \nbg\n=\nRGB\n(\n.\n2\n,\n.\n2\n,\n.\n2\n))\n\n\n\n\n\n\n\n\nFunctions\n\n\nFunctions can typically be used in place of input data, and they will be mapped as needed. 2D and 3D parametric plots can also be created, and ranges can be given as vectors or min/max.  For example, here are alternative methods to create the same plot:\n\n\nusing\n \nPlots\n\n\ntmin\n \n=\n \n0\n\n\ntmax\n \n=\n \n4\n\u03c0\n\n\ntvec\n \n=\n \nlinspace\n(\ntmin\n,\n \ntmax\n,\n \n100\n)\n\n\n\nplot\n(\nsin\n(\ntvec\n),\n \ncos\n(\ntvec\n))\n\n\nplot\n(\nsin\n,\n \ncos\n,\n \ntvec\n)\n\n\nplot\n(\nsin\n,\n \ncos\n,\n \ntmin\n,\n \ntmax\n)\n\n\n\n\n\n\nVectors of functions are allowed as well (one series per function).\n\n\nShapes\n\n\nCheck out \nthis tutorial\n to save Gotham:", 
            "title": "Input Data"
        }, 
        {
            "location": "/input_data/#input-data", 
            "text": "Part of the power of Plots lies is in the many combinations of allowed input data.\nYou shouldn't spend your time transforming and massaging your data into a specific format.\nLet Plots do that for you.  There are a few rules to remember, and you'll be a power user in no time.", 
            "title": "Input Data"
        }, 
        {
            "location": "/input_data/#inputs-are-arguments-not-keywords", 
            "text": "While  plot(x = 1:10, y = rand(10))  will work as expected, it is not the preferred method.  In fact,\nthis method will simply call  plot(1:10, rand(10)) .  Instead,\nuse  plot(rand(10)) .  In this case, a single input will be mapped to the  :y  keyword, and a missing\nvalue for  :x  will impute a unit range  1:10 .  The reason lies in the flexibility of Julia's multiple dispatch, where every combination of input types\ncan have unique behavior, when desired.", 
            "title": "Inputs are arguments, not keywords"
        }, 
        {
            "location": "/input_data/#columns-are-series", 
            "text": "In most cases, passing a (n x m) matrix of values (numbers, etc) will create  m  series, each with  n  data points.  This follows a consistent rule... vectors apply to a series, matrices apply to many series.  This rule carries into keyword arguments.   plot(rand(10,4), color = [:red, :blue])  will create 4 series, each assigned the color vector [:red,:blue].  However,  plot(rand(10,4), color = [:red :blue])  will create 4 series, with series 1 and 3 taking the color  :red  and series 2 and 4 taking the color  :blue .  The difference is that in the first example, it is a length-2 column vector, and in the second example it is a (1 x 2) row vector (a Matrix).", 
            "title": "Columns are series"
        }, 
        {
            "location": "/input_data/#dataframes-support", 
            "text": "If you have DataFrames installed, some convenience functionality is turned on.  (Those coming from R will appreciate it.)  The first argument should be the  DataFrame , and subsequent  Symbol  arguments will be mapped to the corresponding column in that  DataFrame .  Example:  using   DataFrames ,   Plots ;   gadfly ()  using   RDatasets ;   iris   =   dataset ( datasets ,   iris )  scatter ( iris ,   : SepalLength ,   : SepalWidth ,   group = : Species , \n         title   =   My awesome plot ,   xlabel   =   Length ,   ylabel   =   Width , \n         m = ( 0.5 ,   [: +   : h   : star7 ],   12 ),   bg = RGB ( . 2 , . 2 , . 2 ))", 
            "title": "DataFrames support"
        }, 
        {
            "location": "/input_data/#functions", 
            "text": "Functions can typically be used in place of input data, and they will be mapped as needed. 2D and 3D parametric plots can also be created, and ranges can be given as vectors or min/max.  For example, here are alternative methods to create the same plot:  using   Plots  tmin   =   0  tmax   =   4 \u03c0  tvec   =   linspace ( tmin ,   tmax ,   100 )  plot ( sin ( tvec ),   cos ( tvec ))  plot ( sin ,   cos ,   tvec )  plot ( sin ,   cos ,   tmin ,   tmax )   Vectors of functions are allowed as well (one series per function).", 
            "title": "Functions"
        }, 
        {
            "location": "/input_data/#shapes", 
            "text": "Check out  this tutorial  to save Gotham:", 
            "title": "Shapes"
        }, 
        {
            "location": "/attributes/", 
            "text": "<!--\nfunction autoResize(id){\n    var newheight;\n    var newwidth;\n\n    if(document.getElementById){\n        newheight = document.getElementById(id).contentWindow.document .body.scrollHeight;\n        newwidth = document.getElementById(id).contentWindow.document .body.scrollWidth;\n    }\n\n    document.getElementById(id).height = (newheight) + \"px\";\n    document.getElementById(id).width = (newwidth) + \"px\";\n}\n//-->\n\n\n\n\n\n\nAttributes\n\n\nIn Plots, input data is passed positionally (for example, the \ny\n in \nplot(y)\n), and attributes are passed as keywords (for example, \nplot(y, color = :blue)\n).\n\n\n\n\nAliases\n\n\nKeywords can take a range of values through the \nalias mechanic\n.  For example, \nplot(y, color = :blue)\n is really interpreted as \nplot(y, seriescolor = :blue)\n.  Each attribute has a number of aliases (see the charts below), which are available to avoid the pain of constantly looking up plotting API documentation because you forgot the argument name.  \nc\n, \ncolor\n, and \nseriescolor\n all mean the same thing, and in fact those are eventually converted into the more precise attributes \nlinecolor\n, \nmarkercolor\n, \nmarkerstrokecolor\n, and \nfillcolor\n (which you can then override if desired).\n\n\n\nTip: Use aliases for one-off analysis and visualization, but use the true keyword name for long-lived library code to avoid confusion.\n\n\n\n\n\nTip: As of this writing, aliases do not work inside recipes!!\n\n\n\n\n\n\nMagic Arguments\n\n\nSome arguments encompass smart shorthands for setting many related arguments at the same time.  Plots uses type checking and multiple dispatch to smartly \"figure out\" which values apply to which argument.  Pass in a tuple of values.  Single values will be first wrapped in a tuple before processing.\n\n\naxis (and xaxis/yaxis/zaxis)\n\n\nPassing a tuple of settings to the \nxaxis\n argument will allow the quick definition\nof \nxlabel\n, \nxlim\n, \nxticks\n, \nxscale\n, \nxflip\n, and \nxtickfont\n.  The following are equivalent:\n\n\nplot\n(\ny\n,\n \nxaxis\n \n=\n \n(\nmy label\n,\n \n(\n0\n,\n10\n),\n \n0\n:\n0.5\n:\n10\n,\n \n:\nlog\n,\n \n:\nflip\n,\n \nfont\n(\n20\n,\n \nCourier\n)))\n\n\n\nplot\n(\ny\n,\n \nxlabel\n \n=\n \nmy label\n,\n\n        \nxlims\n \n=\n \n(\n0\n,\n10\n),\n\n        \nxticks\n \n=\n \n0\n:\n0.5\n:\n10\n,\n\n        \nxscale\n \n=\n \n:\nlog\n,\n\n        \nxflip\n \n=\n \ntrue\n,\n\n        \nxtickfont\n \n=\n \nfont\n(\n20\n,\n \nCourier\n))\n\n\n\n\n\n\nNote that \nyaxis\n and \nzaxis\n work similarly, and \naxis\n will apply to all.\n\n\nline\n\n\nSet attributes corresponding to a series line.  Aliases: \nl\n.  The following are equivalent:\n\n\nplot\n(\ny\n,\n \nline\n \n=\n \n(:\nsteppre\n,\n \n:\ndot\n,\n \n:\narrow\n,\n \n0.5\n,\n \n4\n,\n \n:\nred\n))\n\n\n\nplot\n(\ny\n,\n \nseriestype\n \n=\n \n:\nsteppre\n,\n\n        \nlinestyle\n \n=\n \n:\ndot\n,\n\n        \narrow\n \n=\n \n:\narrow\n,\n\n        \nlinealpha\n \n=\n \n0.5\n,\n\n        \nlinewidth\n \n=\n \n4\n,\n\n        \nlinecolor\n \n=\n \n:\nred\n)\n\n\n\n\n\n\nfill\n\n\nSet attributes corresponding to a series fill area.  Aliases: \nf\n, \narea\n.  The following are equivalent:\n\n\nplot\n(\ny\n,\n \nfill\n \n=\n \n(\n0\n,\n \n0.5\n,\n \n:\nred\n))\n\n\n\nplot\n(\ny\n,\n \nfillrange\n \n=\n \n0\n,\n\n        \nfillalpha\n \n=\n \n0.5\n,\n\n        \nfillcolor\n \n=\n \n:\nred\n)\n\n\n\n\n\n\nmarker\n\n\nSet attributes corresponding to a series marker.  Aliases: \nm\n, \nmark\n.  The following are equivalent:\n\n\nscatter\n(\ny\n,\n \nmarker\n \n=\n \n(:\nhexagon\n,\n \n20\n,\n \n0.6\n,\n \n:\ngreen\n,\n \nStroke\n(\n3\n,\n \n0.2\n,\n \n:\nblack\n,\n \n:\ndot\n)))\n\n\n\nscatter\n(\ny\n,\n \nmarkershape\n \n=\n \n:\nhexagon\n,\n\n           \nmarkersize\n \n=\n \n20\n,\n\n           \nmarkeralpha\n \n=\n \n0.6\n,\n\n           \nmarkercolor\n \n=\n \n:\ngreen\n,\n\n           \nmarkerstrokewidth\n \n=\n \n3\n,\n\n           \nmarkerstrokealpha\n \n=\n \n0.2\n,\n\n           \nmarkerstrokecolor\n \n=\n \n:\nblack\n,\n\n           \nmarkerstrokestyle\n \n=\n \n:\ndot\n)\n\n\n\n\n\n\n\n\nSeries\n\n\nThese attributes apply to individual series (lines, scatters, heatmaps, etc)\n\n\nYou need a Frames Capable browser to view this content.\n\n\n\n\n\nPlot\n\n\nThese attributes apply to the full Plot.  (A Plot contains a tree-like layout of Subplots)\n\n\nYou need a Frames Capable browser to view this content.\n\n\n\n\n\nSubplot\n\n\nThese attributes apply to settings for individual Subplots.\n\n\nYou need a Frames Capable browser to view this content.\n\n\n\n\n\nAxis\n\n\nThese attributes apply to an individual Axis in a Subplot (for example the \nsubplot[:xaxis]\n)\n\n\nYou need a Frames Capable browser to view this content.", 
            "title": "Attributes"
        }, 
        {
            "location": "/attributes/#attributes", 
            "text": "In Plots, input data is passed positionally (for example, the  y  in  plot(y) ), and attributes are passed as keywords (for example,  plot(y, color = :blue) ).", 
            "title": "Attributes"
        }, 
        {
            "location": "/attributes/#aliases", 
            "text": "Keywords can take a range of values through the  alias mechanic .  For example,  plot(y, color = :blue)  is really interpreted as  plot(y, seriescolor = :blue) .  Each attribute has a number of aliases (see the charts below), which are available to avoid the pain of constantly looking up plotting API documentation because you forgot the argument name.   c ,  color , and  seriescolor  all mean the same thing, and in fact those are eventually converted into the more precise attributes  linecolor ,  markercolor ,  markerstrokecolor , and  fillcolor  (which you can then override if desired).  \nTip: Use aliases for one-off analysis and visualization, but use the true keyword name for long-lived library code to avoid confusion.  \nTip: As of this writing, aliases do not work inside recipes!!", 
            "title": "Aliases"
        }, 
        {
            "location": "/attributes/#magic-arguments", 
            "text": "Some arguments encompass smart shorthands for setting many related arguments at the same time.  Plots uses type checking and multiple dispatch to smartly \"figure out\" which values apply to which argument.  Pass in a tuple of values.  Single values will be first wrapped in a tuple before processing.", 
            "title": "Magic Arguments"
        }, 
        {
            "location": "/attributes/#axis-and-xaxisyaxiszaxis", 
            "text": "Passing a tuple of settings to the  xaxis  argument will allow the quick definition\nof  xlabel ,  xlim ,  xticks ,  xscale ,  xflip , and  xtickfont .  The following are equivalent:  plot ( y ,   xaxis   =   ( my label ,   ( 0 , 10 ),   0 : 0.5 : 10 ,   : log ,   : flip ,   font ( 20 ,   Courier )))  plot ( y ,   xlabel   =   my label , \n         xlims   =   ( 0 , 10 ), \n         xticks   =   0 : 0.5 : 10 , \n         xscale   =   : log , \n         xflip   =   true , \n         xtickfont   =   font ( 20 ,   Courier ))   Note that  yaxis  and  zaxis  work similarly, and  axis  will apply to all.", 
            "title": "axis (and xaxis/yaxis/zaxis)"
        }, 
        {
            "location": "/attributes/#line", 
            "text": "Set attributes corresponding to a series line.  Aliases:  l .  The following are equivalent:  plot ( y ,   line   =   (: steppre ,   : dot ,   : arrow ,   0.5 ,   4 ,   : red ))  plot ( y ,   seriestype   =   : steppre , \n         linestyle   =   : dot , \n         arrow   =   : arrow , \n         linealpha   =   0.5 , \n         linewidth   =   4 , \n         linecolor   =   : red )", 
            "title": "line"
        }, 
        {
            "location": "/attributes/#fill", 
            "text": "Set attributes corresponding to a series fill area.  Aliases:  f ,  area .  The following are equivalent:  plot ( y ,   fill   =   ( 0 ,   0.5 ,   : red ))  plot ( y ,   fillrange   =   0 , \n         fillalpha   =   0.5 , \n         fillcolor   =   : red )", 
            "title": "fill"
        }, 
        {
            "location": "/attributes/#marker", 
            "text": "Set attributes corresponding to a series marker.  Aliases:  m ,  mark .  The following are equivalent:  scatter ( y ,   marker   =   (: hexagon ,   20 ,   0.6 ,   : green ,   Stroke ( 3 ,   0.2 ,   : black ,   : dot )))  scatter ( y ,   markershape   =   : hexagon , \n            markersize   =   20 , \n            markeralpha   =   0.6 , \n            markercolor   =   : green , \n            markerstrokewidth   =   3 , \n            markerstrokealpha   =   0.2 , \n            markerstrokecolor   =   : black , \n            markerstrokestyle   =   : dot )", 
            "title": "marker"
        }, 
        {
            "location": "/attributes/#series", 
            "text": "These attributes apply to individual series (lines, scatters, heatmaps, etc)  You need a Frames Capable browser to view this content.", 
            "title": "Series"
        }, 
        {
            "location": "/attributes/#plot", 
            "text": "These attributes apply to the full Plot.  (A Plot contains a tree-like layout of Subplots)  You need a Frames Capable browser to view this content.", 
            "title": "Plot"
        }, 
        {
            "location": "/attributes/#subplot", 
            "text": "These attributes apply to settings for individual Subplots.  You need a Frames Capable browser to view this content.", 
            "title": "Subplot"
        }, 
        {
            "location": "/attributes/#axis", 
            "text": "These attributes apply to an individual Axis in a Subplot (for example the  subplot[:xaxis] )  You need a Frames Capable browser to view this content.", 
            "title": "Axis"
        }, 
        {
            "location": "/colors/", 
            "text": "Colors\n\n\nThere are many color attributes, for lines, fills, markers, backgrounds, and foregrounds.  Many colors follow a hierarchy... \nlinecolor\n gets its value from \nseriescolor\n, for example, unless you override the value.  This allows for you to simply set precisely what you want, without lots of boilerplate.\n\n\nColor attributes will except many different types:\n\n\n\n\nSymbol\ns or \nString\ns will be passed to \nColors.parse(Colorant, c)\n, so \n:red\n is equivalent to \ncolorant\"red\"\n\n\nfalse\n or \nnothing\n will be converted to an invisible \nRGBA(0,0,0,0)\n\n\nAny \nColors.Colorant\n, with or without alpha/opacity\n\n\nAny \nPlots.ColorScheme\n, which includes \nColorVector\n, \nColorGradient\n, etc\n\n\n\n\nIn addition, there is an extensive facility for selecting and generating color maps/gradients.\n\n\n\n\nA valid Symbol: \n:inferno\n (the default), \n:heat\n, \n:blues\n, etc\n\n\nA list of colors (or anything that can be converted to a color)\n\n\nA pre-built \nColorGradient\n, which can be constructed with the \ncgrad\n helper function.  See \nthis short tutorial\n for example usage.\n\n\n\n\n\n\nSeries Colors\n\n\nFor series, there are a few attributes to know:\n\n\n\n\nseriescolor\n: Not used directly, but defines the base color for the series\n\n\nlinecolor\n: Color of paths\n\n\nfillcolor\n: Color of area fill\n\n\nmarkercolor\n: Color of the interior of markers and shapes\n\n\nmarkerstrokecolor\n: Color of the border/stroke of markers and shapes\n\n\n\n\nseriescolor\n defaults to \n:auto\n, and gets assigned a color from the \ncolor_palette\n based on its index in the subplot.  By default, the other colors \n:match\n.  (See the table below)\n\n\n\n\n\n\n\n\nThis color...\n\n\nmatches this color...\n\n\n\n\n\n\n\n\n\n\nlinecolor\n\n\nseriescolor\n\n\n\n\n\n\nfillcolor\n\n\nseriescolor\n\n\n\n\n\n\nmarkercolor\n\n\nseriescolor\n\n\n\n\n\n\nmarkerstrokecolor\n\n\nforeground_color_subplot\n\n\n\n\n\n\n\n\nNote: each of these attributes have a corresponding alpha override: \nseriesalpha\n, \nlinealpha\n, \nfillalpha\n, \nmarkeralpha\n, and \nmarkerstrokealpha\n.  They are optional, and you can still give alpha information as part of an \nColors.RGBA\n.\n\n\nNote: in some contexts, and when the user hasn't set a value, the \nlinecolor\n or \nmarkerstrokecolor\n may be overridden.\n\n\n\n\nForeground/Background\n\n\nForeground and background colors work similarly:\n\n\n\n\n\n\n\n\nThis color...\n\n\nmatches this color...\n\n\n\n\n\n\n\n\n\n\nbackground_color_outside\n\n\nbackground_color\n\n\n\n\n\n\nbackground_color_subplot\n\n\nbackground_color\n\n\n\n\n\n\nbackground_color_legend\n\n\nbackground_color_subplot\n\n\n\n\n\n\nbackground_color_inside\n\n\nbackground_color_subplot\n\n\n\n\n\n\nforeground_color_subplot\n\n\nforeground_color\n\n\n\n\n\n\nforeground_color_legend\n\n\nforeground_color_subplot\n\n\n\n\n\n\nforeground_color_grid\n\n\nforeground_color_subplot\n\n\n\n\n\n\nforeground_color_title\n\n\nforeground_color_subplot\n\n\n\n\n\n\nforeground_color_axis\n\n\nforeground_color_subplot\n\n\n\n\n\n\nforeground_color_border\n\n\nforeground_color_subplot\n\n\n\n\n\n\nforeground_color_guide\n\n\nforeground_color_subplot\n\n\n\n\n\n\nforeground_color_text\n\n\nforeground_color_subplot\n\n\n\n\n\n\n\n\n\n\nMisc\n\n\n\n\nline_z\n and \nmarker_z\n parameters will map data values into a ColorGradient value\n\n\ncolor_pallete\n determines the colors assigned when \nseriescolor == :auto\n:\n\n\nIf passed a vector of colors, it will force cycling of those colors\n\n\nIf passed a gradient, it will infinitely draw unique colors from that gradient, attempting to spread them out", 
            "title": "Colors"
        }, 
        {
            "location": "/colors/#colors", 
            "text": "There are many color attributes, for lines, fills, markers, backgrounds, and foregrounds.  Many colors follow a hierarchy...  linecolor  gets its value from  seriescolor , for example, unless you override the value.  This allows for you to simply set precisely what you want, without lots of boilerplate.  Color attributes will except many different types:   Symbol s or  String s will be passed to  Colors.parse(Colorant, c) , so  :red  is equivalent to  colorant\"red\"  false  or  nothing  will be converted to an invisible  RGBA(0,0,0,0)  Any  Colors.Colorant , with or without alpha/opacity  Any  Plots.ColorScheme , which includes  ColorVector ,  ColorGradient , etc   In addition, there is an extensive facility for selecting and generating color maps/gradients.   A valid Symbol:  :inferno  (the default),  :heat ,  :blues , etc  A list of colors (or anything that can be converted to a color)  A pre-built  ColorGradient , which can be constructed with the  cgrad  helper function.  See  this short tutorial  for example usage.", 
            "title": "Colors"
        }, 
        {
            "location": "/colors/#series-colors", 
            "text": "For series, there are a few attributes to know:   seriescolor : Not used directly, but defines the base color for the series  linecolor : Color of paths  fillcolor : Color of area fill  markercolor : Color of the interior of markers and shapes  markerstrokecolor : Color of the border/stroke of markers and shapes   seriescolor  defaults to  :auto , and gets assigned a color from the  color_palette  based on its index in the subplot.  By default, the other colors  :match .  (See the table below)     This color...  matches this color...      linecolor  seriescolor    fillcolor  seriescolor    markercolor  seriescolor    markerstrokecolor  foreground_color_subplot     Note: each of these attributes have a corresponding alpha override:  seriesalpha ,  linealpha ,  fillalpha ,  markeralpha , and  markerstrokealpha .  They are optional, and you can still give alpha information as part of an  Colors.RGBA .  Note: in some contexts, and when the user hasn't set a value, the  linecolor  or  markerstrokecolor  may be overridden.", 
            "title": "Series Colors"
        }, 
        {
            "location": "/colors/#foregroundbackground", 
            "text": "Foreground and background colors work similarly:     This color...  matches this color...      background_color_outside  background_color    background_color_subplot  background_color    background_color_legend  background_color_subplot    background_color_inside  background_color_subplot    foreground_color_subplot  foreground_color    foreground_color_legend  foreground_color_subplot    foreground_color_grid  foreground_color_subplot    foreground_color_title  foreground_color_subplot    foreground_color_axis  foreground_color_subplot    foreground_color_border  foreground_color_subplot    foreground_color_guide  foreground_color_subplot    foreground_color_text  foreground_color_subplot", 
            "title": "Foreground/Background"
        }, 
        {
            "location": "/colors/#misc", 
            "text": "line_z  and  marker_z  parameters will map data values into a ColorGradient value  color_pallete  determines the colors assigned when  seriescolor == :auto :  If passed a vector of colors, it will force cycling of those colors  If passed a gradient, it will infinitely draw unique colors from that gradient, attempting to spread them out", 
            "title": "Misc"
        }, 
        {
            "location": "/output/", 
            "text": "Output\n\n\nIn IJulia or the REPL, \na Plot is only displayed when returned\n (a semicolon will suppress the return), or if explicitly displayed with \ndisplay()\n, \ngui()\n, or by adding \nshow = true\n to your plot command.\n\n\n\nTip: You can have MATLAB-like interactive behavior by setting the default value: default(show = true)\n\n\n\n\nGUI\n\n\ngui()\n displays the most recent plot, or \ndisplay(plt)\n works.  Returning the plot from the REPL is like calling \ngui()\n.\n\n\nsavefig\n\n\nSave the most recent plot, choosing file type automatically by the extension.\n\n\nsavefig(filename)\n\n\n\n\n\nThere are also shorthands \npng(fn)\n, etc.  You don't need the file extension for those.\n\n\n\n\nGR\n\n\nFor the GR backend there are some additional optional settings:  (Thanks @jheinen!)\n\n\nThe GKS_WSTYPE environment variable can be used to set the output device. The default workstation type is automatically selected depending on the platform:\n -  211 = X11 (Un*x)\n -  400 = Quartz (macOS only)\n -  42 = GDI (Windows only)\n\n\nAdd this to your \n~/.juliarc.jl\n file to switch the default output device:\n\n\nENV\n[\nGKS_WSTYPE\n]\n \n=\n \nx11\n\n\n\n\n\n\nChoose from:\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nx11\n\n\nX11 (Un*x + macOS)\n\n\n\n\n\n\nquartz\n\n\nQuartz (macOS only)\n\n\n\n\n\n\nwin\n\n\nGDI (Windows only)\n\n\n\n\n\n\nps, eps\n\n\nPostScript\n\n\n\n\n\n\npdf\n\n\nPortable Document Format\n\n\n\n\n\n\nbmp\n\n\nWindows Bitmap (BMP)\n\n\n\n\n\n\npgf\n\n\nPGF / TikZ\n\n\n\n\n\n\nmov\n\n\nMPEG-4 video\n\n\n\n\n\n\njpeg, jpg\n\n\nJPEG image file\n\n\n\n\n\n\npng\n\n\nPortable Network Graphics file (PNG)\n\n\n\n\n\n\ntiff, tif\n\n\nTagged Image File Format (TIFF)\n\n\n\n\n\n\nfig\n\n\nXfig vector graphics file\n\n\n\n\n\n\nsvg\n\n\nScalable Vector Graphics\n\n\n\n\n\n\nwmf\n\n\nWindows Metafile", 
            "title": "Output"
        }, 
        {
            "location": "/output/#output", 
            "text": "In IJulia or the REPL,  a Plot is only displayed when returned  (a semicolon will suppress the return), or if explicitly displayed with  display() ,  gui() , or by adding  show = true  to your plot command.  \nTip: You can have MATLAB-like interactive behavior by setting the default value: default(show = true)", 
            "title": "Output"
        }, 
        {
            "location": "/output/#gui", 
            "text": "gui()  displays the most recent plot, or  display(plt)  works.  Returning the plot from the REPL is like calling  gui() .", 
            "title": "GUI"
        }, 
        {
            "location": "/output/#savefig", 
            "text": "Save the most recent plot, choosing file type automatically by the extension.  savefig(filename)  There are also shorthands  png(fn) , etc.  You don't need the file extension for those.", 
            "title": "savefig"
        }, 
        {
            "location": "/output/#gr", 
            "text": "For the GR backend there are some additional optional settings:  (Thanks @jheinen!)  The GKS_WSTYPE environment variable can be used to set the output device. The default workstation type is automatically selected depending on the platform:\n -  211 = X11 (Un*x)\n -  400 = Quartz (macOS only)\n -  42 = GDI (Windows only)  Add this to your  ~/.juliarc.jl  file to switch the default output device:  ENV [ GKS_WSTYPE ]   =   x11   Choose from:     Type  Description      x11  X11 (Un*x + macOS)    quartz  Quartz (macOS only)    win  GDI (Windows only)    ps, eps  PostScript    pdf  Portable Document Format    bmp  Windows Bitmap (BMP)    pgf  PGF / TikZ    mov  MPEG-4 video    jpeg, jpg  JPEG image file    png  Portable Network Graphics file (PNG)    tiff, tif  Tagged Image File Format (TIFF)    fig  Xfig vector graphics file    svg  Scalable Vector Graphics    wmf  Windows Metafile", 
            "title": "GR"
        }, 
        {
            "location": "/animations/", 
            "text": "Animations\n\n\nAnimations are created in 3 steps:\n\n\n\n\nInitialize an \nAnimation\n object.\n\n\nSave each frame of the animation with \nframe(anim)\n.\n\n\nConvert the frames to an animated gif with \ngif(anim, filename, fps=15)\n\n\n\n\n\nTip: the convenience macros `@gif` and `@animate` simplify this code immensely.  See the \nhome page\n for examples of the short version, or\nthe \npyplot example\n for the long version.\n\n\n\n\n\n\nConvenience macros\n\n\nThere are two macros for varying levels of convenience in creating animations: \n@animate\n and \n@gif\n.  The main difference is that \n@animate\n will return an \nAnimation\n object for later processing, and \n@gif\n will create an animated gif file (and display it when returned to an IJulia cell).\n\n\nUse \n@gif\n for simple, one-off animations that you want to view immediately.  Use \n@animate\n for anything more complex.  Constructing \nAnimation\n objects can be done when you need full control of the life-cycle of the animation (usually unnecessary though).\n\n\nExamples:\n\n\nanim\n \n=\n \n@\nanimate\n \nfor\n \ni\n=\n1\n:\n100\n\n    \nplot\n(\n...\n)\n\n\nend\n\n\ngif\n(\nanim\n,\n \n/tmp/anim_fps15.gif\n,\n \nfps\n \n=\n \n15\n)\n\n\ngif\n(\nanim\n,\n \n/tmp/anim_fps30.gif\n,\n \nfps\n \n=\n \n30\n)\n\n\n\n\n\n\nThe \nevery\n flag will only save a frame \"every N iterations\":\n\n\n@\ngif\n \nfor\n \ni\n=\n1\n:\n100\n\n    \nplot\n(\n...\n)\n\n\nend\n \nevery\n \n10\n\n\n\n\n\n\nThe \nwhen\n flag will only save a frame \"when the expression is true\"\n\n\n@\ngif\n \nfor\n \ni\n=\n1\n:\n100\n\n    \nplot\n(\n...\n)\n\n\nend\n \nwhen\n \ni\n \n \n50\n \n \nmod1\n(\ni\n,\n \n10\n)\n \n==\n \n5", 
            "title": "Animations"
        }, 
        {
            "location": "/animations/#animations", 
            "text": "Animations are created in 3 steps:   Initialize an  Animation  object.  Save each frame of the animation with  frame(anim) .  Convert the frames to an animated gif with  gif(anim, filename, fps=15)   \nTip: the convenience macros `@gif` and `@animate` simplify this code immensely.  See the  home page  for examples of the short version, or\nthe  pyplot example  for the long version.", 
            "title": "Animations"
        }, 
        {
            "location": "/animations/#convenience-macros", 
            "text": "There are two macros for varying levels of convenience in creating animations:  @animate  and  @gif .  The main difference is that  @animate  will return an  Animation  object for later processing, and  @gif  will create an animated gif file (and display it when returned to an IJulia cell).  Use  @gif  for simple, one-off animations that you want to view immediately.  Use  @animate  for anything more complex.  Constructing  Animation  objects can be done when you need full control of the life-cycle of the animation (usually unnecessary though).  Examples:  anim   =   @ animate   for   i = 1 : 100 \n     plot ( ... )  end  gif ( anim ,   /tmp/anim_fps15.gif ,   fps   =   15 )  gif ( anim ,   /tmp/anim_fps30.gif ,   fps   =   30 )   The  every  flag will only save a frame \"every N iterations\":  @ gif   for   i = 1 : 100 \n     plot ( ... )  end   every   10   The  when  flag will only save a frame \"when the expression is true\"  @ gif   for   i = 1 : 100 \n     plot ( ... )  end   when   i     50     mod1 ( i ,   10 )   ==   5", 
            "title": "Convenience macros"
        }, 
        {
            "location": "/pipeline/", 
            "text": "Processing Pipeline\n\n\nPlotting commands will send inputs through a series of preprocessing steps, in order to convert, simplify, and generalize. The idea is that end-users need incredible flexibility in what (and how) they are able to make calls.  They may want total control over plot attributes, or none at all.  There may be 8 attributes that are constant, but one that varies by data series.  We need to be able to easily layer complex plots on top of each other, and easily define what they should look like.  Input data might come in any form.\n\n\nI'll go through the steps that occur after a call to \nplot()\n or \nplot!()\n, and hint at the power and flexibility that arises.\n\n\nAn example command\n\n\nSuppose we have data:\n\n\nn\n \n=\n \n100\n\n\nx\n,\n \ny\n \n=\n \nlinspace\n(\n0\n,\n1\n,\nn\n),\n \nrandn\n(\nn\n,\n \n3\n)\n\n\n\n\n\n\nand we'd like to visualize \nx\n against each column of \ny\n.  Here's a sample command in Plots:\n\n\nusing\n \nPlots\n;\n \npyplot\n()\n\n\nplot\n(\nx\n,\n \ny\n,\n \nline\n \n=\n \n(\n0.5\n,\n \n[\n4\n \n1\n \n0\n],\n \n[:\npath\n \n:\nscatter\n \n:\ndensity\n]),\n\n    \nmarker\n=\n(\n10\n,\n \n0.5\n,\n \n[:\nnone\n \n:\n+\n \n:\nnone\n]),\n \nfill\n=\n0.5\n,\n\n    \norientation\n \n=\n \n:\nh\n,\n \ntitle\n \n=\n \nMy title\n)\n\n\n\n\n\n\n\n\nIn this example, we have an input matrix, and we'd like to plot three series on top of each other, one for each column of data.\nWe create a row vector (1x3 matrix) of symbols to assign different visualization types for each series, set the orientation of the histogram, and set\nalpha values.\n\n\nFor comparison's sake, this is somewhat similar to the following calls in PyPlot:\n\n\nimport\n \nPyPlot\n\n\nfig\n \n=\n \nPyPlot\n.\ngcf\n()\n\n\nfig\n[:\nset_size_inches\n](\n4\n,\n3\n,\nforward\n=\ntrue\n)\n\n\nfig\n[:\nset_dpi\n](\n100\n)\n\n\nPyPlot\n.\nclf\n()\n\n\n\nPyPlot\n.\nplot\n(\nx\n,\n \ny\n[:,\n1\n],\n \nalpha\n \n=\n \n0.5\n,\n \nsteelblue\n,\n \nlinewidth\n \n=\n \n4\n)\n\n\nPyPlot\n.\nscatter\n(\nx\n,\n \ny\n[:,\n2\n],\n \nalpha\n \n=\n \n0.5\n,\n \nmarker\n \n=\n \n+\n,\n \ns\n \n=\n \n100\n,\n \nc\n=\norangered\n)\n\n\nPyPlot\n.\nplt\n[:\nhist\n](\ny\n[:,\n3\n],\n \norientation\n \n=\n \nhorizontal\n,\n \nalpha\n \n=\n \n0.5\n,\n\n                          \nnormed\n \n=\n \ntrue\n,\n \nbins\n=\n30\n,\n \ncolor\n=\ngreen\n,\n\n                          \nlinewidth\n \n=\n \n0\n)\n\n\n\nax\n \n=\n \nPyPlot\n.\ngca\n()\n\n\nax\n[:\nxaxis\n][:\ngrid\n](\ntrue\n)\n\n\nax\n[:\nyaxis\n][:\ngrid\n](\ntrue\n)\n\n\nPyPlot\n.\ntitle\n(\nMy title\n)\n\n\nPyPlot\n.\nlegend\n([\ny1\n,\ny2\n])\n\n\nPyPlot\n.\nshow\n()\n\n\n\n\n\n\n\n\nStep 1: Preprocess Attributes\n\n\nSee \nreplacing aliases\n and \nmagic arguments\n for details.\n\n\nAfterwards, there are some arguments which are simplified and compressed, such as converting the boolean setting \ncolorbar = false\n to the internal description \ncolorbar = :none\n as to allow complex behavior without complex interface, replacing \nnothing\n with the invisible \nRGBA(0,0,0,0)\n, and similar.\n\n\n\n\nStep 2: Process input data: User Recipes, Grouping, and more\n\n\nPlots will rarely ask you to pre-process your own inputs.  You have a Julia array? Great.  DataFrame? No problem.  Surface function? You got it.\n\n\nDuring this step, Plots will translate your input data (within the context of the plot type and other inputs) into a list of sliced and/or expanded representations,\nwhere each item represents the data for one plot series.  Under the hood, it makes heavy use of \nmultiple dispatch\n and \nrecipes\n.\n\n\nInputs are recursively processed until a matching recipe is found.  This means you can make modular and hierarchical recipes which are processed just like anything built into Plots.\n\n\ntype\n MyVecWrapper\n\n  \nv\n::\nVector\n{\nFloat64\n}\n\n\nend\n\n\nmv\n \n=\n \nMyVecWrapper\n(\nrand\n(\n100\n))\n\n\n\n@\nrecipe\n \nfunction\n f\n(\nmv\n::\nMyVecWrapper\n)\n\n    \nmarkershape\n \n--\n \n:\ncircle\n\n    \nmarkersize\n  \n--\n \n30\n\n    \nmv\n.\nv\n\n\nend\n\n\n\nplot\n(\n\n    \nplot\n(\nmv\n.\nv\n),\n\n    \nplot\n(\nmv\n)\n\n\n)\n\n\n\n\n\n\n\n\nNote that if dispatch does not find a recipe for the full combination of inputs, it will then try to apply \ntype recipes\n to each individual argument.\n\n\nThis hook gave us a nice way to swap out the input data and add custom visualization attributes for a user type.  Things like error bars, regression lines, ribbons, and group filtering are also handled during this recursive pass.\n\n\nGroups: When you'd like to split a data series into multiple plot series, you can use the \ngroup\n keyword.  Attributes can be applied to the resulting series as if your data had been already separated into distinct input data.  The \ngroup\n variable determines how to split the data and also assigns the legend label.\n\n\nIn this example, we split the data points into 3 groups randomly, and give them different marker shapes (\n[:s :o :x]\n are aliases for \n:star5\n, \n:octagon\n, and \n:xcross\n). The other attibutes (\n:markersize\n and \n:markeralpha\n) are shared.\n\n\nscatter\n(\nrand\n(\n100\n),\n \ngroup\n \n=\n \nrand\n(\n1\n:\n3\n,\n \n100\n),\n \nmarker\n \n=\n \n(\n10\n,\n0.3\n,[:\ns\n \n:\no\n \n:\nx\n]))\n\n\n\n\n\n\n\n\n\n\nStep 3:  Initialize and update Plot and Subplots\n\n\nAttributes which apply to Plot, Subplot, or Axis objects are pulled out and processed.  Backend methods for initializing the figure/window are triggered, and the \nlayout\n is built.\n\n\n\n\nStep 4: Series Recipes\n\n\nThis part is somewhat magical.  Following the first three steps, we have a list of keyword dictionaries (type \nKW\n) which contain both data and attributes.  Now we will recursively apply \nseries recipes\n, first checking to see if a backend supports a series type natively, and if not, applying a series recipe and re-processing.\n\n\nThe result is that one can create generic recipes (converting a histogram to a bar plot, for example), which will reduce the series to the highest-level type(s) that a backend supports.  Since recipes are so simple to create, we can do complex visualizations in backends which support very little natively.\n\n\n\n\nStep 5: Preparing for output\n\n\nMuch of the heavy processing is offloaded until it's needed.  Plots will try to avoid expensive graphical updates until you actually choose to \ndisplay\n the plot.  Just before display, we will compute the layout specifics and bounding boxes of the subplots and other plot components, then trigger the callback to the backend code to draw/update the plot.\n\n\n\n\nStep 6: Display it\n\n\nOpen/refresh a GUI window, write to a file, or display inline in IJulia.  Remember that, in IJulia or the REPL, \na Plot is only displayed when returned\n (a semicolon will suppress the return), or if explicitly displayed with \ndisplay()\n, \ngui()\n, or by adding \nshow = true\n to your plot command.\n\n\n\nTip: You can have MATLAB-like interactive behavior by setting the default value: default(show = true)", 
            "title": "Internals"
        }, 
        {
            "location": "/pipeline/#processing-pipeline", 
            "text": "Plotting commands will send inputs through a series of preprocessing steps, in order to convert, simplify, and generalize. The idea is that end-users need incredible flexibility in what (and how) they are able to make calls.  They may want total control over plot attributes, or none at all.  There may be 8 attributes that are constant, but one that varies by data series.  We need to be able to easily layer complex plots on top of each other, and easily define what they should look like.  Input data might come in any form.  I'll go through the steps that occur after a call to  plot()  or  plot!() , and hint at the power and flexibility that arises.", 
            "title": "Processing Pipeline"
        }, 
        {
            "location": "/pipeline/#an-example-command", 
            "text": "Suppose we have data:  n   =   100  x ,   y   =   linspace ( 0 , 1 , n ),   randn ( n ,   3 )   and we'd like to visualize  x  against each column of  y .  Here's a sample command in Plots:  using   Plots ;   pyplot ()  plot ( x ,   y ,   line   =   ( 0.5 ,   [ 4   1   0 ],   [: path   : scatter   : density ]), \n     marker = ( 10 ,   0.5 ,   [: none   : +   : none ]),   fill = 0.5 , \n     orientation   =   : h ,   title   =   My title )    In this example, we have an input matrix, and we'd like to plot three series on top of each other, one for each column of data.\nWe create a row vector (1x3 matrix) of symbols to assign different visualization types for each series, set the orientation of the histogram, and set\nalpha values.  For comparison's sake, this is somewhat similar to the following calls in PyPlot:  import   PyPlot  fig   =   PyPlot . gcf ()  fig [: set_size_inches ]( 4 , 3 , forward = true )  fig [: set_dpi ]( 100 )  PyPlot . clf ()  PyPlot . plot ( x ,   y [:, 1 ],   alpha   =   0.5 ,   steelblue ,   linewidth   =   4 )  PyPlot . scatter ( x ,   y [:, 2 ],   alpha   =   0.5 ,   marker   =   + ,   s   =   100 ,   c = orangered )  PyPlot . plt [: hist ]( y [:, 3 ],   orientation   =   horizontal ,   alpha   =   0.5 , \n                           normed   =   true ,   bins = 30 ,   color = green , \n                           linewidth   =   0 )  ax   =   PyPlot . gca ()  ax [: xaxis ][: grid ]( true )  ax [: yaxis ][: grid ]( true )  PyPlot . title ( My title )  PyPlot . legend ([ y1 , y2 ])  PyPlot . show ()", 
            "title": "An example command"
        }, 
        {
            "location": "/pipeline/#step-1-preprocess-attributes", 
            "text": "See  replacing aliases  and  magic arguments  for details.  Afterwards, there are some arguments which are simplified and compressed, such as converting the boolean setting  colorbar = false  to the internal description  colorbar = :none  as to allow complex behavior without complex interface, replacing  nothing  with the invisible  RGBA(0,0,0,0) , and similar.", 
            "title": "Step 1: Preprocess Attributes"
        }, 
        {
            "location": "/pipeline/#step-2-process-input-data-user-recipes-grouping-and-more", 
            "text": "Plots will rarely ask you to pre-process your own inputs.  You have a Julia array? Great.  DataFrame? No problem.  Surface function? You got it.  During this step, Plots will translate your input data (within the context of the plot type and other inputs) into a list of sliced and/or expanded representations,\nwhere each item represents the data for one plot series.  Under the hood, it makes heavy use of  multiple dispatch  and  recipes .  Inputs are recursively processed until a matching recipe is found.  This means you can make modular and hierarchical recipes which are processed just like anything built into Plots.  type  MyVecWrapper \n   v :: Vector { Float64 }  end  mv   =   MyVecWrapper ( rand ( 100 ))  @ recipe   function  f ( mv :: MyVecWrapper ) \n     markershape   --   : circle \n     markersize    --   30 \n     mv . v  end  plot ( \n     plot ( mv . v ), \n     plot ( mv )  )    Note that if dispatch does not find a recipe for the full combination of inputs, it will then try to apply  type recipes  to each individual argument.  This hook gave us a nice way to swap out the input data and add custom visualization attributes for a user type.  Things like error bars, regression lines, ribbons, and group filtering are also handled during this recursive pass.  Groups: When you'd like to split a data series into multiple plot series, you can use the  group  keyword.  Attributes can be applied to the resulting series as if your data had been already separated into distinct input data.  The  group  variable determines how to split the data and also assigns the legend label.  In this example, we split the data points into 3 groups randomly, and give them different marker shapes ( [:s :o :x]  are aliases for  :star5 ,  :octagon , and  :xcross ). The other attibutes ( :markersize  and  :markeralpha ) are shared.  scatter ( rand ( 100 ),   group   =   rand ( 1 : 3 ,   100 ),   marker   =   ( 10 , 0.3 ,[: s   : o   : x ]))", 
            "title": "Step 2: Process input data: User Recipes, Grouping, and more"
        }, 
        {
            "location": "/pipeline/#step-3-initialize-and-update-plot-and-subplots", 
            "text": "Attributes which apply to Plot, Subplot, or Axis objects are pulled out and processed.  Backend methods for initializing the figure/window are triggered, and the  layout  is built.", 
            "title": "Step 3:  Initialize and update Plot and Subplots"
        }, 
        {
            "location": "/pipeline/#step-4-series-recipes", 
            "text": "This part is somewhat magical.  Following the first three steps, we have a list of keyword dictionaries (type  KW ) which contain both data and attributes.  Now we will recursively apply  series recipes , first checking to see if a backend supports a series type natively, and if not, applying a series recipe and re-processing.  The result is that one can create generic recipes (converting a histogram to a bar plot, for example), which will reduce the series to the highest-level type(s) that a backend supports.  Since recipes are so simple to create, we can do complex visualizations in backends which support very little natively.", 
            "title": "Step 4: Series Recipes"
        }, 
        {
            "location": "/pipeline/#step-5-preparing-for-output", 
            "text": "Much of the heavy processing is offloaded until it's needed.  Plots will try to avoid expensive graphical updates until you actually choose to  display  the plot.  Just before display, we will compute the layout specifics and bounding boxes of the subplots and other plot components, then trigger the callback to the backend code to draw/update the plot.", 
            "title": "Step 5: Preparing for output"
        }, 
        {
            "location": "/pipeline/#step-6-display-it", 
            "text": "Open/refresh a GUI window, write to a file, or display inline in IJulia.  Remember that, in IJulia or the REPL,  a Plot is only displayed when returned  (a semicolon will suppress the return), or if explicitly displayed with  display() ,  gui() , or by adding  show = true  to your plot command.  \nTip: You can have MATLAB-like interactive behavior by setting the default value: default(show = true)", 
            "title": "Step 6: Display it"
        }, 
        {
            "location": "/layouts/", 
            "text": "Layouts\n\n\nAs of v0.7.0, Plots has taken control of subplot positioning, allowing complex, nested grids of subplots and components.  Care has been taken to keep the framework flexible and generic, so that backends need only support the ability to precisely define the absolute position of a subplot, and they get the full power of nesting, plot area alignment, and more.  Just set the \nlayout\n keyword in a call to \nplot(...)\n\n\nIt's helpful at this point to review terminology:\n\n\n\n\nPlot\n: The whole figure/window\n\n\nSubplot\n: One subplot, containing a title, axes, colorbar, legend, and plot area.\n\n\nAxis\n: One axis of a subplot, containing axis guide (label), tick labels, and tick marks.\n\n\nPlot Area\n: The part of a subplot where the data is shown... contains the series, grid lines, etc.\n\n\nSeries\n: One distinct visualization of data. (For example: a line or a set of markers)\n\n\n\n\n\n\nSimple Layouts\n\n\nPass an integer to \nlayout\n to allow it to automatically compute a grid size for that many subplots:\n\n\n# create a 2x2 grid, and map each of the 4 series to one of the subplots\n\n\nplot\n(\nrand\n(\n100\n,\n4\n),\n \nlayout\n \n=\n \n4\n)\n\n\n\n\n\n\n\n\nPass a tuple to \nlayout\n to create a grid of that size:\n\n\n# create a 4x1 grid, and map each of the 4 series to one of the subplots\n\n\nplot\n(\nrand\n(\n100\n,\n4\n),\n \nlayout\n \n=\n \n(\n4\n,\n1\n))\n\n\n\n\n\n\n\n\nMore complex grid layouts can be created with the \ngrid(...)\n constructor:\n\n\nplot\n(\nrand\n(\n100\n,\n4\n),\n \nlayout\n \n=\n \ngrid\n(\n4\n,\n1\n,\nheights\n=\n[\n0.1\n,\n0.4\n,\n0.4\n,\n0.1\n]))\n\n\n\n\n\n\n\n\n\n\nAdvanced Layouts\n\n\nThe \n@layout\n macro is the easiest way to define complex layouts, using Julia's \nmultidimensional Array construction\n as the basis for a custom layout syntax.  Precise sizing can be acheived with curly brackets, otherwise the free space is equally split between the \nplot areas\n of subplots.\n\n\nl\n \n=\n \n@\nlayout\n \n[\n  \na\n{\n0.3\nw\n}\n \n[\ngrid\n(\n3\n,\n3\n)\n\n                         \nb\n{\n0.2\nh\n}\n \n]]\n\n\nplot\n(\n\n    \nrand\n(\n10\n,\n11\n),\n\n    \nlayout\n \n=\n \nl\n,\n \nlegend\n \n=\n \nfalse\n,\n \nseriestype\n \n=\n \n[:\nbar\n \n:\nscatter\n \n:\npath\n],\n\n    \ntitle\n \n=\n \n[\n(\n$i\n)\n \nfor\n \ni\n=\n1\n:\n11\n]\n,\n \ntitleloc\n \n=\n \n:\nright\n,\n \ntitlefont\n \n=\n \nfont\n(\n8\n)\n\n\n)\n\n\n\n\n\n\n\n\n\n\nCreate inset (floating) subplots using the \ninset_subplots\n attribute. \ninset_subplots\n takes a list of (parent_layout, BoundingBox) tuples, where the bounding box is relative to the parent.\n\n\nUse \npx\n/\nmm\n/\ninch\n for absolute coords, \nw\n/\nh\n for percentage relative to the parent. Origin is top-left. \nh_anchor\n/\nv_anchor\n define what the \nx\n/\ny\n inputs of the bounding box refer to.\n\n\nusing\n \nPlots\n\n\nplot\n(\nheatmap\n(\nrandn\n(\n10\n,\n20\n)),\n \nboxplot\n(\nrand\n(\n1\n:\n4\n,\n1000\n),\nrandn\n(\n1000\n)),\n \nleg\n=\nfalse\n)\n\n\nhistogram!\n(\nrandn\n(\n1000\n),\n \ninset_subplots\n \n=\n \n[(\n1\n,\n \nbbox\n(\n0.05\nw\n,\n0.95\nh\n,\n0.5\nw\n,\n0.5\nh\n,\n \nv_anchor\n=\n:\nbottom\n))],\n \nsubplot\n=\n3\n,\n \nticks\n=\nnothing\n)\n\n\nsticks!\n(\nrandn\n(\n100\n),\n \ninset_subplots\n=\n[\nbbox\n(\n0.35\nw\n,\n0.5\nh\n,\n200\npx\n,\n200\npx\n,\nh_anchor\n=\n:\ncenter\n,\nv_anchor\n=\n:\ncenter\n)],\n \nsubplot\n=\n4\n)", 
            "title": "Layouts"
        }, 
        {
            "location": "/layouts/#layouts", 
            "text": "As of v0.7.0, Plots has taken control of subplot positioning, allowing complex, nested grids of subplots and components.  Care has been taken to keep the framework flexible and generic, so that backends need only support the ability to precisely define the absolute position of a subplot, and they get the full power of nesting, plot area alignment, and more.  Just set the  layout  keyword in a call to  plot(...)  It's helpful at this point to review terminology:   Plot : The whole figure/window  Subplot : One subplot, containing a title, axes, colorbar, legend, and plot area.  Axis : One axis of a subplot, containing axis guide (label), tick labels, and tick marks.  Plot Area : The part of a subplot where the data is shown... contains the series, grid lines, etc.  Series : One distinct visualization of data. (For example: a line or a set of markers)", 
            "title": "Layouts"
        }, 
        {
            "location": "/layouts/#simple-layouts", 
            "text": "Pass an integer to  layout  to allow it to automatically compute a grid size for that many subplots:  # create a 2x2 grid, and map each of the 4 series to one of the subplots  plot ( rand ( 100 , 4 ),   layout   =   4 )    Pass a tuple to  layout  to create a grid of that size:  # create a 4x1 grid, and map each of the 4 series to one of the subplots  plot ( rand ( 100 , 4 ),   layout   =   ( 4 , 1 ))    More complex grid layouts can be created with the  grid(...)  constructor:  plot ( rand ( 100 , 4 ),   layout   =   grid ( 4 , 1 , heights = [ 0.1 , 0.4 , 0.4 , 0.1 ]))", 
            "title": "Simple Layouts"
        }, 
        {
            "location": "/layouts/#advanced-layouts", 
            "text": "The  @layout  macro is the easiest way to define complex layouts, using Julia's  multidimensional Array construction  as the basis for a custom layout syntax.  Precise sizing can be acheived with curly brackets, otherwise the free space is equally split between the  plot areas  of subplots.  l   =   @ layout   [    a { 0.3 w }   [ grid ( 3 , 3 ) \n                          b { 0.2 h }   ]]  plot ( \n     rand ( 10 , 11 ), \n     layout   =   l ,   legend   =   false ,   seriestype   =   [: bar   : scatter   : path ], \n     title   =   [ ( $i )   for   i = 1 : 11 ] ,   titleloc   =   : right ,   titlefont   =   font ( 8 )  )     Create inset (floating) subplots using the  inset_subplots  attribute.  inset_subplots  takes a list of (parent_layout, BoundingBox) tuples, where the bounding box is relative to the parent.  Use  px / mm / inch  for absolute coords,  w / h  for percentage relative to the parent. Origin is top-left.  h_anchor / v_anchor  define what the  x / y  inputs of the bounding box refer to.  using   Plots  plot ( heatmap ( randn ( 10 , 20 )),   boxplot ( rand ( 1 : 4 , 1000 ), randn ( 1000 )),   leg = false )  histogram! ( randn ( 1000 ),   inset_subplots   =   [( 1 ,   bbox ( 0.05 w , 0.95 h , 0.5 w , 0.5 h ,   v_anchor = : bottom ))],   subplot = 3 ,   ticks = nothing )  sticks! ( randn ( 100 ),   inset_subplots = [ bbox ( 0.35 w , 0.5 h , 200 px , 200 px , h_anchor = : center , v_anchor = : center )],   subplot = 4 )", 
            "title": "Advanced Layouts"
        }, 
        {
            "location": "/recipes/", 
            "text": "Advanced Recipes\n\n\nLike other tools in Plots, recipes are relatively simple, but extremely powerful.  A recipe is created by invoking the \n@recipe\n macro, which is defined in the lightweight package \nRecipesBase\n.  There are many examples of recipes both within Plots and in many external packages, including \nPlotRecipes\n.\n\n\nThere are four main types of recipes in Plots (listed in the order they are processed):\n\n\n\n\nUser Recipes\n\n\nType Recipes\n\n\nPlot Recipes\n\n\nSeries Recipes\n\n\n\n\nThe recipe type is determined completely by the dispatch signature.\n  Each recipe type is called from a different part of the \nplotting pipeline\n, so you will choose a type of recipe to match how much processing you want completed before your recipe is applied.\n\n\nThese are the dispatch signatures for each type (note that most of these can accept positional or keyword args, denoted by \n...\n):\n\n\n\n\nUser Recipes: \n@recipe function f(custom_arg_1::T, custom_arg_2::S, ...; ...) end\n\n\nProcess a unique set of types early in the pipeline.  Good for user-defined types or special combinations of Base types.\n\n\nThe \n@userplot\n macro is a nice convenience which both defines a new type (to ensure correct dispatch) and exports shorthands.\n\n\nSee \ngraphplot\n for an example.\n\n\n\n\n\n\nType Recipes: \n@recipe function f{T\n:MyType}(::Type{T}, val::T) end\n\n\nFor user-defined types which wrap or have a one-to-one mapping to something supported by Plots, simply define a conversion method.\n\n\nNote: this is effectively saying \"when you see type T, replace it with ...\"\n\n\nSee \nSymPy\n for an example.\n\n\n\n\n\n\nPlot Recipes: \n@recipe function f(::Type{Val{:myplotrecipename}}, plt::Plot; ...) end\n\n\nThese are called after input data has been processed, but \nbefore the plot is created\n.\n\n\nBuild layouts, add subplots, and other plot-wide attributes\n\n\nSee \nmarginalhist\n for an example.\n\n\n\n\n\n\nSeries Recipes: \n@recipe function f(::Type{Val{:myseriesrecipename}}, x, y, z; ...) end\n\n\nThese are the last calls to happen.  Each backend will support a short list of series types (\npath\n, \nshape\n, \nhistogram\n, etc).  If a series type is natively supported, processing is passed (delegated) to the backend.  If a series type is \nnot\n natively supported by the backend, we attempt to call a \"series recipe\".\n\n\nNote: If there's no series recipe defined, and the backend doesn't support it, you'll see an error like: \nERROR: The backend must not support the series type Val{:hi}, and there isn't a series recipe defined.\n\n\nNote: You must have the \nx, y, z\n included in the signature, or it won't be processed as a series type!!\n\n\n\n\n\n\n\n\nRecipe Syntax/Rules\n\n\nLets decompose what's happening inside the recipe macro, starting with a simple recipe:\n\n\ntype\n MyType\n \nend\n\n\n\n@\nrecipe\n \nfunction\n f\n(::\nMyType\n,\n \nn\n::\nInteger\n \n=\n \n10\n;\n \nadd_marker\n \n=\n \nfalse\n)\n\n    \nlinecolor\n   \n--\n \n:\nblue\n\n    \nseriestype\n  \n:\n=\n  \n:\npath\n\n    \nmarkershape\n \n--\n \n(\nadd_marker\n \n?\n \n:\ncircle\n \n:\n \n:\nnone\n)\n\n    \ndelete!\n(\nd\n,\n \n:\nadd_marker\n)\n\n    \nrand\n(\nn\n)\n\n\nend\n\n\n\n\n\n\nWe create a new type \nMyType\n, which is empty, and used purely for dispatch.  Our goal here is to create a random path of \nn\n points.\n\n\nThere are a few important things to know, after which recipes boil down to updating an attribute dictionary and returning input data:\n\n\n\n\nA recipe signature \nf(args...; kw...)\n is converted into a definition of \napply_recipe(d::KW, args...)\n where:\n\n\nd\n is an attribute dictionary of type \ntypealias KW Dict{Symbol,Any}\n\n\nYour \nargs\n must be distinct enough that dispatch will call your definition (and without masking an existing definition).  Using a custom data type will ensure proper dispatch.\n\n\nThe function \nf\n is unused/meaningless... call it whatever you want.\n\n\n\n\n\n\nThe special operator \n--\n turns \nlinecolor --\n :blue\n into \nget!(d, :linecolor, :blue)\n, setting the attribute only when it doesn't already exist.  (Tip: Wrap the right hand side in parentheses for complex expressions.)\n\n\nThe special operator \n:=\n turns \nseriestype := :path\n into \nd[:seriestype] = :path\n, forcing that attribute value.  (Tip: Wrap the right hand side in parentheses for complex expressions.)\n\n\nThe return value of the recipe is the \nargs\n of a \nRecipeData\n object, which also has a reference to the attribute dictionary.\n\n\nA recipe returns a Vector{RecipeData}.  We'll see how to add to this list later with the \n@series\n macro.\n\n\n\n\nBreaking down the example:\n\n\nIn the example above, we use \nMyType\n for dispatch, with optional positional argument \nn::Integer\n:\n\n\n@\nrecipe\n \nfunction\n f\n(::\nMyType\n,\n \nn\n::\nInteger\n \n=\n \n10\n;\n \nadd_marker\n \n=\n \nfalse\n)\n\n\n\n\n\n\nWith a call to \nplot(MyType())\n or similar, this recipe will be invoked.  If \nlinecolor\n has not been set, it is set to \n:blue\n:\n\n\n    \nlinecolor\n   \n--\n \n:\nblue\n\n\n\n\n\n\nThe \nseriestype\n is forced to be \n:path\n:\n\n\n    \nseriestype\n  \n:\n=\n  \n:\npath\n\n\n\n\n\n\nThe \nmarkershape\n is a little more complex; it checks the \nadd_marker\n custom keyword, but only if \nmarkershape\n was not already set.  (Note: the \nadd_marker\n key is redundant, as the user can just set the marker shape directly... I use it only for demonstration):\n\n\n    \nmarkershape\n \n--\n \n(\nadd_marker\n \n?\n \n:\ncircle\n \n:\n \n:\nnone\n)\n\n\n\n\n\n\nthen return the data to be plotted:\n\n\n    \nrand\n(\nn\n)\n\n\nend\n\n\n\n\n\n\nSome example usages of our (mostly useless) recipe:\n\n\nmt\n \n=\n \nMyType\n()\n\n\nplot\n(\n\n    \nplot\n(\nmt\n),\n\n    \nplot\n(\nmt\n,\n \n100\n,\n \nlinecolor\n \n=\n \n:\nred\n),\n\n    \nplot\n(\nmt\n,\n \nmarker\n \n=\n \n(:\nstar\n,\n20\n),\n \nadd_marker\n \n=\n \nfalse\n),\n\n    \nplot\n(\nmt\n,\n \nadd_marker\n \n=\n \ntrue\n)\n\n\n)\n\n\n\n\n\n\n\n\n\n\nUser Recipes\n\n\nThe example above is an example of a \"user recipe\", in which you define the full signature for dispatch.  User recipes (like others) can be stacked and modular.  The following is valid:\n\n\n@\nrecipe\n \nf\n(\nmt\n::\nMyType\n,\n \nn\n::\nInteger\n \n=\n \n10\n)\n \n=\n \n(\nmt\n,\n \nrand\n(\nn\n))\n\n\n@\nrecipe\n \nf\n(\nmt\n::\nMyType\n,\n \nv\n::\nAbstractVector\n)\n \n=\n \nhist\n(\nv\n)\n\n\n\n\n\n\nHere a call to \nplot(MyType())\n will apply these recipes in order; first mapping \nmt\n to \n(mt, rand(10))\n and then subsequently mapping to \nhist(rand(10))\n.\n\n\n\n\nType Recipes\n\n\nFor some custom data types, they are essentially light wrappers around built-in containers.  For example you may have a type:\n\n\ntype\n MyWrapper\n\n    \nv\n::\nVector\n\n\nend\n\n\n\n\n\n\nIn this case, you'd like your \nMyWrapper\n objects to be treated just like Vectors, but do not wish to subtype AbstractArray.  No worries!  Just define a type recipe to do the conversion:\n\n\n@\nrecipe\n \nf\n(::\nType\n{\nMyWrapper\n},\n \nmw\n::\nMyWrapper\n)\n \n=\n \nmw\n.\nv\n\n\n\n\n\n\nThis signature is called on each input when dispatch did not find a suitable recipe for the full \nargs...\n.  So \nplot(rand(10), MyWrapper(rand(10)))\n will \"just work\".\n\n\n\n\nSeries Recipes\n\n\nThis is where the magic happens.  You can create your own custom visualizations for arbitrary data.  Quickly define violin plots, error bars, and even standard types like histograms and step plots.  A histogram is a bar plot:\n\n\n@\nrecipe\n \nfunction\n f\n(::\nType\n{\nVal\n{:\nhistogram\n}},\n \nx\n,\n \ny\n,\n \nz\n)\n\n    \nedges\n,\n \ncounts\n \n=\n \nmy_hist\n(\ny\n,\n \nd\n[:\nbins\n],\n\n                               \nnormed\n \n=\n \nd\n[:\nnormalize\n],\n\n                               \nweights\n \n=\n \nd\n[:\nweights\n])\n\n    \nx\n \n:\n=\n \nedges\n\n    \ny\n \n:\n=\n \ncounts\n\n    \nseriestype\n \n:\n=\n \n:\nbar\n\n    \n()\n\n\nend\n\n\n\n\n\n\nwhile a 2D histogram is really a heatmap:\n\n\n@\nrecipe\n \nfunction\n f\n(::\nType\n{\nVal\n{:\nhistogram2d\n}},\n \nx\n,\n \ny\n,\n \nz\n)\n\n    \nxedges\n,\n \nyedges\n,\n \ncounts\n \n=\n \nmy_hist_2d\n(\nx\n,\n \ny\n,\n \nd\n[:\nbins\n],\n\n                                              \nnormed\n \n=\n \nd\n[:\nnormalize\n],\n\n                                              \nweights\n \n=\n \nd\n[:\nweights\n])\n\n    \nx\n \n:\n=\n \ncenters\n(\nxedges\n)\n\n    \ny\n \n:\n=\n \ncenters\n(\nyedges\n)\n\n    \nz\n \n:\n=\n \nSurface\n(\ncounts\n)\n\n    \nseriestype\n \n:\n=\n \n:\nheatmap\n\n    \n()\n\n\nend\n\n\n\n\n\n\nThe argument \ny\n is always populated, the argument \nx\n is populated with a call like \nplot(x,y, seriestype =: histogram2d)\n and correspondingly for \nz\n, \nplot(x,y,z, seriestype =: histogram2d)\n\n\nSee below where I go through a series recipe for creating boxplots.  Many of these \"standard\" recipes are defined in Plots, though they can be defined anywhere \nwithout requiring the package to be dependent on Plots\n.\n\n\n\n\nCase studies\n\n\nMarginal Histograms\n\n\nIn this case study, I'll explain how I built the \nmarginalhist\n recipe for \nPlotRecipes\n.  This is a nice example because, although easy to understand, it utilizes some great Plots features.\n\n\nMarginal histograms are a visualization comparing two variables.  The main plot is a 2D histogram, where each rectangle is a (possibly normalized and weighted) count of data points in that bucket.  Above the main plot is a smaller histogram of the first variable, and to the right of the main plot is a histogram of the second variable.  The full recipe:\n\n\n@\nuserplot\n \nMarginalHist\n\n\n\n@\nrecipe\n \nfunction\n f\n(\nh\n::\nMarginalHist\n)\n\n    \nif\n \nlength\n(\nh\n.\nargs\n)\n \n!=\n \n2\n \n||\n \n!\n(\ntypeof\n(\nh\n.\nargs\n[\n1\n])\n \n:\n \nAbstractVector\n)\n \n||\n \n!\n(\ntypeof\n(\nh\n.\nargs\n[\n2\n])\n \n:\n \nAbstractVector\n)\n\n        \nerror\n(\nMarginal Histograms should be given two vectors.  Got: \n$(typeof(h.args))\n)\n\n    \nend\n\n    \nx\n,\n \ny\n \n=\n \nh\n.\nargs\n\n\n    \n# set up the subplots\n\n    \nlegend\n \n:\n=\n \nfalse\n\n    \nlink\n \n:\n=\n \n:\nboth\n\n    \nticks\n \n:\n=\n \n[\nnothing\n \n:\nauto\n \nnothing\n]\n\n    \ngrid\n \n:\n=\n \nfalse\n\n    \nforeground_color_subplot\n \n:\n=\n \n[\nRGBA\n(\n0\n,\n0\n,\n0\n,\n0\n)\n \n:\nmatch\n \nRGBA\n(\n0\n,\n0\n,\n0\n,\n0\n)]\n\n    \nlayout\n \n:\n=\n \n@\nlayout\n \n[\ntophist\n           \n_\n\n                       \nhist2d\n{\n0.9\nw\n,\n0.9\nh\n}\n \nrighthist\n]\n\n\n    \n# main histogram2d\n\n    \n@\nseries\n \nbegin\n\n        \nseriestype\n \n:\n=\n \n:\nhistogram2d\n\n        \nsubplot\n \n:\n=\n \n2\n\n        \nx\n,\n \ny\n\n    \nend\n\n\n    \n# these are common to both marginal histograms\n\n    \nfillcolor\n \n:\n=\n \n:\nblack\n\n    \nfillalpha\n \n:\n=\n \n0.3\n\n    \nlinealpha\n \n:\n=\n \n0.3\n\n    \nseriestype\n \n:\n=\n \n:\nhistogram\n\n\n    \n# upper histogram\n\n    \n@\nseries\n \nbegin\n\n        \nsubplot\n \n:\n=\n \n1\n\n        \nx\n\n    \nend\n\n\n    \n# right histogram\n\n    \n@\nseries\n \nbegin\n\n        \norientation\n \n:\n=\n \n:\nh\n\n        \nsubplot\n \n:\n=\n \n3\n\n        \ny\n\n    \nend\n\n\nend\n\n\n\n\n\n\nUsage:\n\n\nusing\n \nDistributions\n,\n \nPlotRecipes\n\n\npyplot\n()\n\n\nn\n \n=\n \n1000\n\n\nx\n \n=\n \nrand\n(\nGamma\n(\n2\n),\n \nn\n)\n\n\ny\n \n=\n \n-\n0.5\nx\n \n+\n \nrandn\n(\nn\n)\n\n\nmarginalhist\n(\nx\n,\n \ny\n,\n \nfc\n=\n:\nplasma\n,\n \nbins\n=\n40\n)\n\n\n\n\n\n\n\n\n\n\nNow I'll go through each section in detail:\n\n\nThe \n@userplot\n macro is a nice convenience for creating a new wrapper for input arguments that can be distinct during dispatch.  It also creates lowercase convenience methods (\nmarginalhist\n and \nmarginalhist!\n) and exports them.\n\n\n@\nuserplot\n \nMarginalHist\n\n\n\n\n\n\nthus create a type \nMarginalHist\n for dispatch. An object of type \nMarginalHist\n has the field \nargs\n which is the tuple of arguments the plot function is invoked with, which can be either \nmarginalhist(x,y,...)\n or \nplot(x,y, seriestype = :marginalhist)\n. The first syntax is a shorthand created by the \n@userplot\n macro.\n\n\nWe dispatch only on the generated type, as the real inputs are wrapped inside it:\n\n\n@\nrecipe\n \nfunction\n f\n(\nh\n::\nMarginalHist\n)\n\n\n\n\n\n\nSome error checking.  Note that we're extracting the real inputs (like in a call to \nmarginalhist(randn(100), randn(100))\n) into \nx\n and \ny\n:\n\n\n    \nif\n \nlength\n(\nh\n.\nargs\n)\n \n!=\n \n2\n \n||\n \n!\n(\ntypeof\n(\nh\n.\nargs\n[\n1\n])\n \n:\n \nAbstractVector\n)\n \n||\n \n!\n(\ntypeof\n(\nh\n.\nargs\n[\n2\n])\n \n:\n \nAbstractVector\n)\n\n        \nerror\n(\nMarginal Histograms should be given two vectors.  Got: \n$(typeof(h.args))\n)\n\n    \nend\n\n    \nx\n,\n \ny\n \n=\n \nh\n.\nargs\n\n\n\n\n\n\nNext we build the subplot layout and define some attributes.  A few things to note:\n\n\n- The layout creates three subplots (`_` is left blank)\n- Attributes are mapped to each subplot when passed in as a matrix (row-vector)\n- The attribute `link := :both` means that the y-axes of each row (and x-axes of\n    each column) will share data extrema.  Other values include `:x`, `:y`,\n    `:all`, and `:none`.\n\n\n\n\n\n    \n# set up the subplots\n\n    \nlegend\n \n:\n=\n \nfalse\n\n    \nlink\n \n:\n=\n \n:\nboth\n\n    \nticks\n \n:\n=\n \n[\nnothing\n \n:\nauto\n \nnothing\n]\n\n    \ngrid\n \n:\n=\n \nfalse\n\n    \nforeground_color_subplot\n \n:\n=\n \n[\nRGBA\n(\n0\n,\n0\n,\n0\n,\n0\n)\n \n:\nmatch\n \nRGBA\n(\n0\n,\n0\n,\n0\n,\n0\n)]\n\n    \nlayout\n \n:\n=\n \n@\nlayout\n \n[\ntophist\n           \n_\n\n                       \nhist2d\n{\n0.9\nw\n,\n0.9\nh\n}\n \nrighthist\n]\n\n\n\n\n\n\nDefine the series of the main plot.  The \n@series\n macro makes a local copy of the attribute dictionary \nd\n using a \"let block\".  The copied dictionary and the returned args are added to the \nVector{RecipeData}\n which is returned from the recipe.  This block is similar to calling \nhistogram2d!(x, y; subplot = 2, d...)\n (but you wouldn't actually want to do that).\n\n\nNote: this \n@series\n block gets a \"snapshot\" of the attributes, so it contains anything that was set before this block, but nothing from after it.  \n@series\n blocks can be standalone, as these are, or they can be in a loop.\n\n\n    \n# main histogram2d\n\n    \n@\nseries\n \nbegin\n\n        \nseriestype\n \n:\n=\n \n:\nhistogram2d\n\n        \nsubplot\n \n:\n=\n \n2\n\n        \nx\n,\n \ny\n\n    \nend\n\n\n\n\n\n\nNext we move on to the marginal plots.  We first set attributes which are shared by both:\n\n\n    \n# these are common to both marginal histograms\n\n    \nfillcolor\n \n:\n=\n \n:\nblack\n\n    \nfillalpha\n \n:\n=\n \n0.3\n\n    \nlinealpha\n \n:\n=\n \n0.3\n\n    \nseriestype\n \n:\n=\n \n:\nhistogram\n\n\n\n\n\n\nNow we create two more series, one for each histogram.\n\n\n    \n# upper histogram\n\n    \n@\nseries\n \nbegin\n\n        \nsubplot\n \n:\n=\n \n1\n\n        \nx\n\n    \nend\n\n\n    \n# right histogram\n\n    \n@\nseries\n \nbegin\n\n        \norientation\n \n:\n=\n \n:\nh\n\n        \nsubplot\n \n:\n=\n \n3\n\n        \ny\n\n    \nend\n\n\nend\n\n\n\n\n\n\nIt's important to note: normally we would return arguments from a recipe, and those arguments would be added to a \nRecipeData\n object and pushed onto our \nVector{RecipeData}\n.  However, when creating series using the \n@series\n macro, you have the option of returning \nnothing\n, which will bypass that last step.\n\n\n\n\nSeries Recipe - Notched Box Plots\n\n\nTODO\n\n\n\n\nDocumenting plot functions\n\n\nA documentation string added above the recipe definition will have no effect, just like the function name is meaningless. Since everything in Julia can be associated with a doc-string, the documentation can be added to the name of the plot function like this\n\n\n\n\nMy docstring\n\n\n\n\nmy_plotfunc\n\n\n\n\n\n\nThis can be put anywhere in the code and will appear on the call \n?my_plotfunc\n.\n\n\n\n\nTroubleshooting\n\n\nIt can sometimes be helpful when debugging recipes to see the order of dispatch inside the \napply_recipe\n calls.  Turn on debugging info with:\n\n\nRecipesBase\n.\ndebug\n()\n\n\n\n\n\n\nYou can also pass a \nBool\n to the \ndebug\n method to turn it on/off.\n\n\nHere are some common errors, and what to look out for:\n\n\nconvertToAnyVector\n\n\nERROR\n:\n \nIn\n \nconvertToAnyVector\n,\n \ncould\n \nnot\n \nhandle\n \nthe\n \nargument\n \ntypes\n:\n \nsome\n \ntype\n\n    \n[\ninlined\n \ncode\n]\n \nfrom\n \n~/\n.\njulia\n/\nv0\n.4\n/\nPlots\n/\nsrc\n/\nseries_new\n.\njl\n:\n87\n\n    \nin\n \napply_recipe\n \nat\n \n~/\n.\njulia\n/\nv0\n.4\n/\nRecipesBase\n/\nsrc\n/\nRecipesBase\n.\njl\n:\n237\n\n    \nin\n \n_plot\n!\n \nat\n \n~/\n.\njulia\n/\nv0\n.4\n/\nPlots\n/\nsrc\n/\nplot\n.\njl\n:\n312\n\n    \nin\n \nplot\n \nat\n \n~/\n.\njulia\n/\nv0\n.4\n/\nPlots\n/\nsrc\n/\nplot\n.\njl\n:\n52\n\n\n\n\n\n\nThis error occurs when dispatch cannot recursively map input data to\n\n\nThis error occurs whenever there is an error thrown from within the recipe code. The type \nsome type\n is the type the failing recipe is called with. This can give some hint as to where the error occured. Remember, there may be a large series of call to different recipes for a complicated plot, and \nsome type\n is the type the innermost failing recipe was called with.\n\n\nMethodError: \nstart\n has no method matching start(::Void)\n\n\nERROR\n:\n \nMethodError\n:\n \n`\nstart\n`\n \nhas\n \nno\n \nmethod\n \nmatching\n \nstart\n(::\nVoid\n)\n\n    \nin\n \ncollect\n \nat\n \n./\narray\n.\njl\n:\n260\n\n    \nin\n \ncollect\n \nat\n \n./\narray\n.\njl\n:\n272\n\n    \nin\n \nplotly_series\n \nat\n \n~/.\njulia\n/v0.4/Plots/src/backends/\nplotly\n.\njl\n:\n345\n\n    \nin\n \n_series_added\n \nat\n \n~/.\njulia\n/v0.4/Plots/src/backends/\nplotlyjs\n.\njl\n:\n36\n\n    \nin\n \n_apply_series_recipe\n \nat\n \n~/.\njulia\n/v0.4/Plots/src/\nplot\n.\njl\n:\n224\n\n    \nin\n \n_plot\n!\n \nat\n \n~/.\njulia\n/v0.4/Plots/src/\nplot\n.\njl\n:\n537\n\n\n\n\n\n\nThis error is commonly encountered when a series type expects data for \nx\n, \ny\n, or \nz\n, but instead was passed \nnothing\n (which is of type \nVoid\n).  Check that you have a \nz\n value defined for 3D plots, and likewise that you have valid values for \nx\n and \ny\n.  This could also apply to attributes like \nfillrange\n, \nmarker_z\n, or \nline_z\n if they are expected to have non-void values.", 
            "title": "Recipes"
        }, 
        {
            "location": "/recipes/#advanced-recipes", 
            "text": "Like other tools in Plots, recipes are relatively simple, but extremely powerful.  A recipe is created by invoking the  @recipe  macro, which is defined in the lightweight package  RecipesBase .  There are many examples of recipes both within Plots and in many external packages, including  PlotRecipes .  There are four main types of recipes in Plots (listed in the order they are processed):   User Recipes  Type Recipes  Plot Recipes  Series Recipes   The recipe type is determined completely by the dispatch signature.   Each recipe type is called from a different part of the  plotting pipeline , so you will choose a type of recipe to match how much processing you want completed before your recipe is applied.  These are the dispatch signatures for each type (note that most of these can accept positional or keyword args, denoted by  ... ):   User Recipes:  @recipe function f(custom_arg_1::T, custom_arg_2::S, ...; ...) end  Process a unique set of types early in the pipeline.  Good for user-defined types or special combinations of Base types.  The  @userplot  macro is a nice convenience which both defines a new type (to ensure correct dispatch) and exports shorthands.  See  graphplot  for an example.    Type Recipes:  @recipe function f{T :MyType}(::Type{T}, val::T) end  For user-defined types which wrap or have a one-to-one mapping to something supported by Plots, simply define a conversion method.  Note: this is effectively saying \"when you see type T, replace it with ...\"  See  SymPy  for an example.    Plot Recipes:  @recipe function f(::Type{Val{:myplotrecipename}}, plt::Plot; ...) end  These are called after input data has been processed, but  before the plot is created .  Build layouts, add subplots, and other plot-wide attributes  See  marginalhist  for an example.    Series Recipes:  @recipe function f(::Type{Val{:myseriesrecipename}}, x, y, z; ...) end  These are the last calls to happen.  Each backend will support a short list of series types ( path ,  shape ,  histogram , etc).  If a series type is natively supported, processing is passed (delegated) to the backend.  If a series type is  not  natively supported by the backend, we attempt to call a \"series recipe\".  Note: If there's no series recipe defined, and the backend doesn't support it, you'll see an error like:  ERROR: The backend must not support the series type Val{:hi}, and there isn't a series recipe defined.  Note: You must have the  x, y, z  included in the signature, or it won't be processed as a series type!!", 
            "title": "Advanced Recipes"
        }, 
        {
            "location": "/recipes/#recipe-syntaxrules", 
            "text": "Lets decompose what's happening inside the recipe macro, starting with a simple recipe:  type  MyType   end  @ recipe   function  f (:: MyType ,   n :: Integer   =   10 ;   add_marker   =   false ) \n     linecolor     --   : blue \n     seriestype    : =    : path \n     markershape   --   ( add_marker   ?   : circle   :   : none ) \n     delete! ( d ,   : add_marker ) \n     rand ( n )  end   We create a new type  MyType , which is empty, and used purely for dispatch.  Our goal here is to create a random path of  n  points.  There are a few important things to know, after which recipes boil down to updating an attribute dictionary and returning input data:   A recipe signature  f(args...; kw...)  is converted into a definition of  apply_recipe(d::KW, args...)  where:  d  is an attribute dictionary of type  typealias KW Dict{Symbol,Any}  Your  args  must be distinct enough that dispatch will call your definition (and without masking an existing definition).  Using a custom data type will ensure proper dispatch.  The function  f  is unused/meaningless... call it whatever you want.    The special operator  --  turns  linecolor --  :blue  into  get!(d, :linecolor, :blue) , setting the attribute only when it doesn't already exist.  (Tip: Wrap the right hand side in parentheses for complex expressions.)  The special operator  :=  turns  seriestype := :path  into  d[:seriestype] = :path , forcing that attribute value.  (Tip: Wrap the right hand side in parentheses for complex expressions.)  The return value of the recipe is the  args  of a  RecipeData  object, which also has a reference to the attribute dictionary.  A recipe returns a Vector{RecipeData}.  We'll see how to add to this list later with the  @series  macro.   Breaking down the example:  In the example above, we use  MyType  for dispatch, with optional positional argument  n::Integer :  @ recipe   function  f (:: MyType ,   n :: Integer   =   10 ;   add_marker   =   false )   With a call to  plot(MyType())  or similar, this recipe will be invoked.  If  linecolor  has not been set, it is set to  :blue :       linecolor     --   : blue   The  seriestype  is forced to be  :path :       seriestype    : =    : path   The  markershape  is a little more complex; it checks the  add_marker  custom keyword, but only if  markershape  was not already set.  (Note: the  add_marker  key is redundant, as the user can just set the marker shape directly... I use it only for demonstration):       markershape   --   ( add_marker   ?   : circle   :   : none )   then return the data to be plotted:       rand ( n )  end   Some example usages of our (mostly useless) recipe:  mt   =   MyType ()  plot ( \n     plot ( mt ), \n     plot ( mt ,   100 ,   linecolor   =   : red ), \n     plot ( mt ,   marker   =   (: star , 20 ),   add_marker   =   false ), \n     plot ( mt ,   add_marker   =   true )  )", 
            "title": "Recipe Syntax/Rules"
        }, 
        {
            "location": "/recipes/#user-recipes", 
            "text": "The example above is an example of a \"user recipe\", in which you define the full signature for dispatch.  User recipes (like others) can be stacked and modular.  The following is valid:  @ recipe   f ( mt :: MyType ,   n :: Integer   =   10 )   =   ( mt ,   rand ( n ))  @ recipe   f ( mt :: MyType ,   v :: AbstractVector )   =   hist ( v )   Here a call to  plot(MyType())  will apply these recipes in order; first mapping  mt  to  (mt, rand(10))  and then subsequently mapping to  hist(rand(10)) .", 
            "title": "User Recipes"
        }, 
        {
            "location": "/recipes/#type-recipes", 
            "text": "For some custom data types, they are essentially light wrappers around built-in containers.  For example you may have a type:  type  MyWrapper \n     v :: Vector  end   In this case, you'd like your  MyWrapper  objects to be treated just like Vectors, but do not wish to subtype AbstractArray.  No worries!  Just define a type recipe to do the conversion:  @ recipe   f (:: Type { MyWrapper },   mw :: MyWrapper )   =   mw . v   This signature is called on each input when dispatch did not find a suitable recipe for the full  args... .  So  plot(rand(10), MyWrapper(rand(10)))  will \"just work\".", 
            "title": "Type Recipes"
        }, 
        {
            "location": "/recipes/#series-recipes", 
            "text": "This is where the magic happens.  You can create your own custom visualizations for arbitrary data.  Quickly define violin plots, error bars, and even standard types like histograms and step plots.  A histogram is a bar plot:  @ recipe   function  f (:: Type { Val {: histogram }},   x ,   y ,   z ) \n     edges ,   counts   =   my_hist ( y ,   d [: bins ], \n                                normed   =   d [: normalize ], \n                                weights   =   d [: weights ]) \n     x   : =   edges \n     y   : =   counts \n     seriestype   : =   : bar \n     ()  end   while a 2D histogram is really a heatmap:  @ recipe   function  f (:: Type { Val {: histogram2d }},   x ,   y ,   z ) \n     xedges ,   yedges ,   counts   =   my_hist_2d ( x ,   y ,   d [: bins ], \n                                               normed   =   d [: normalize ], \n                                               weights   =   d [: weights ]) \n     x   : =   centers ( xedges ) \n     y   : =   centers ( yedges ) \n     z   : =   Surface ( counts ) \n     seriestype   : =   : heatmap \n     ()  end   The argument  y  is always populated, the argument  x  is populated with a call like  plot(x,y, seriestype =: histogram2d)  and correspondingly for  z ,  plot(x,y,z, seriestype =: histogram2d)  See below where I go through a series recipe for creating boxplots.  Many of these \"standard\" recipes are defined in Plots, though they can be defined anywhere  without requiring the package to be dependent on Plots .", 
            "title": "Series Recipes"
        }, 
        {
            "location": "/recipes/#case-studies", 
            "text": "", 
            "title": "Case studies"
        }, 
        {
            "location": "/recipes/#marginal-histograms", 
            "text": "In this case study, I'll explain how I built the  marginalhist  recipe for  PlotRecipes .  This is a nice example because, although easy to understand, it utilizes some great Plots features.  Marginal histograms are a visualization comparing two variables.  The main plot is a 2D histogram, where each rectangle is a (possibly normalized and weighted) count of data points in that bucket.  Above the main plot is a smaller histogram of the first variable, and to the right of the main plot is a histogram of the second variable.  The full recipe:  @ userplot   MarginalHist  @ recipe   function  f ( h :: MarginalHist ) \n     if   length ( h . args )   !=   2   ||   ! ( typeof ( h . args [ 1 ])   :   AbstractVector )   ||   ! ( typeof ( h . args [ 2 ])   :   AbstractVector ) \n         error ( Marginal Histograms should be given two vectors.  Got:  $(typeof(h.args)) ) \n     end \n     x ,   y   =   h . args \n\n     # set up the subplots \n     legend   : =   false \n     link   : =   : both \n     ticks   : =   [ nothing   : auto   nothing ] \n     grid   : =   false \n     foreground_color_subplot   : =   [ RGBA ( 0 , 0 , 0 , 0 )   : match   RGBA ( 0 , 0 , 0 , 0 )] \n     layout   : =   @ layout   [ tophist             _ \n                        hist2d { 0.9 w , 0.9 h }   righthist ] \n\n     # main histogram2d \n     @ series   begin \n         seriestype   : =   : histogram2d \n         subplot   : =   2 \n         x ,   y \n     end \n\n     # these are common to both marginal histograms \n     fillcolor   : =   : black \n     fillalpha   : =   0.3 \n     linealpha   : =   0.3 \n     seriestype   : =   : histogram \n\n     # upper histogram \n     @ series   begin \n         subplot   : =   1 \n         x \n     end \n\n     # right histogram \n     @ series   begin \n         orientation   : =   : h \n         subplot   : =   3 \n         y \n     end  end   Usage:  using   Distributions ,   PlotRecipes  pyplot ()  n   =   1000  x   =   rand ( Gamma ( 2 ),   n )  y   =   - 0.5 x   +   randn ( n )  marginalhist ( x ,   y ,   fc = : plasma ,   bins = 40 )     Now I'll go through each section in detail:  The  @userplot  macro is a nice convenience for creating a new wrapper for input arguments that can be distinct during dispatch.  It also creates lowercase convenience methods ( marginalhist  and  marginalhist! ) and exports them.  @ userplot   MarginalHist   thus create a type  MarginalHist  for dispatch. An object of type  MarginalHist  has the field  args  which is the tuple of arguments the plot function is invoked with, which can be either  marginalhist(x,y,...)  or  plot(x,y, seriestype = :marginalhist) . The first syntax is a shorthand created by the  @userplot  macro.  We dispatch only on the generated type, as the real inputs are wrapped inside it:  @ recipe   function  f ( h :: MarginalHist )   Some error checking.  Note that we're extracting the real inputs (like in a call to  marginalhist(randn(100), randn(100)) ) into  x  and  y :       if   length ( h . args )   !=   2   ||   ! ( typeof ( h . args [ 1 ])   :   AbstractVector )   ||   ! ( typeof ( h . args [ 2 ])   :   AbstractVector ) \n         error ( Marginal Histograms should be given two vectors.  Got:  $(typeof(h.args)) ) \n     end \n     x ,   y   =   h . args   Next we build the subplot layout and define some attributes.  A few things to note:  - The layout creates three subplots (`_` is left blank)\n- Attributes are mapped to each subplot when passed in as a matrix (row-vector)\n- The attribute `link := :both` means that the y-axes of each row (and x-axes of\n    each column) will share data extrema.  Other values include `:x`, `:y`,\n    `:all`, and `:none`.       # set up the subplots \n     legend   : =   false \n     link   : =   : both \n     ticks   : =   [ nothing   : auto   nothing ] \n     grid   : =   false \n     foreground_color_subplot   : =   [ RGBA ( 0 , 0 , 0 , 0 )   : match   RGBA ( 0 , 0 , 0 , 0 )] \n     layout   : =   @ layout   [ tophist             _ \n                        hist2d { 0.9 w , 0.9 h }   righthist ]   Define the series of the main plot.  The  @series  macro makes a local copy of the attribute dictionary  d  using a \"let block\".  The copied dictionary and the returned args are added to the  Vector{RecipeData}  which is returned from the recipe.  This block is similar to calling  histogram2d!(x, y; subplot = 2, d...)  (but you wouldn't actually want to do that).  Note: this  @series  block gets a \"snapshot\" of the attributes, so it contains anything that was set before this block, but nothing from after it.   @series  blocks can be standalone, as these are, or they can be in a loop.       # main histogram2d \n     @ series   begin \n         seriestype   : =   : histogram2d \n         subplot   : =   2 \n         x ,   y \n     end   Next we move on to the marginal plots.  We first set attributes which are shared by both:       # these are common to both marginal histograms \n     fillcolor   : =   : black \n     fillalpha   : =   0.3 \n     linealpha   : =   0.3 \n     seriestype   : =   : histogram   Now we create two more series, one for each histogram.       # upper histogram \n     @ series   begin \n         subplot   : =   1 \n         x \n     end \n\n     # right histogram \n     @ series   begin \n         orientation   : =   : h \n         subplot   : =   3 \n         y \n     end  end   It's important to note: normally we would return arguments from a recipe, and those arguments would be added to a  RecipeData  object and pushed onto our  Vector{RecipeData} .  However, when creating series using the  @series  macro, you have the option of returning  nothing , which will bypass that last step.", 
            "title": "Marginal Histograms"
        }, 
        {
            "location": "/recipes/#series-recipe-notched-box-plots", 
            "text": "TODO", 
            "title": "Series Recipe - Notched Box Plots"
        }, 
        {
            "location": "/recipes/#documenting-plot-functions", 
            "text": "A documentation string added above the recipe definition will have no effect, just like the function name is meaningless. Since everything in Julia can be associated with a doc-string, the documentation can be added to the name of the plot function like this   My docstring   my_plotfunc   This can be put anywhere in the code and will appear on the call  ?my_plotfunc .", 
            "title": "Documenting plot functions"
        }, 
        {
            "location": "/recipes/#troubleshooting", 
            "text": "It can sometimes be helpful when debugging recipes to see the order of dispatch inside the  apply_recipe  calls.  Turn on debugging info with:  RecipesBase . debug ()   You can also pass a  Bool  to the  debug  method to turn it on/off.  Here are some common errors, and what to look out for:", 
            "title": "Troubleshooting"
        }, 
        {
            "location": "/recipes/#converttoanyvector", 
            "text": "ERROR :   In   convertToAnyVector ,   could   not   handle   the   argument   types :   some   type \n     [ inlined   code ]   from   ~/ . julia / v0 .4 / Plots / src / series_new . jl : 87 \n     in   apply_recipe   at   ~/ . julia / v0 .4 / RecipesBase / src / RecipesBase . jl : 237 \n     in   _plot !   at   ~/ . julia / v0 .4 / Plots / src / plot . jl : 312 \n     in   plot   at   ~/ . julia / v0 .4 / Plots / src / plot . jl : 52   This error occurs when dispatch cannot recursively map input data to  This error occurs whenever there is an error thrown from within the recipe code. The type  some type  is the type the failing recipe is called with. This can give some hint as to where the error occured. Remember, there may be a large series of call to different recipes for a complicated plot, and  some type  is the type the innermost failing recipe was called with.", 
            "title": "convertToAnyVector"
        }, 
        {
            "location": "/recipes/#methoderror-start-has-no-method-matching-startvoid", 
            "text": "ERROR :   MethodError :   ` start `   has   no   method   matching   start (:: Void ) \n     in   collect   at   ./ array . jl : 260 \n     in   collect   at   ./ array . jl : 272 \n     in   plotly_series   at   ~/. julia /v0.4/Plots/src/backends/ plotly . jl : 345 \n     in   _series_added   at   ~/. julia /v0.4/Plots/src/backends/ plotlyjs . jl : 36 \n     in   _apply_series_recipe   at   ~/. julia /v0.4/Plots/src/ plot . jl : 224 \n     in   _plot !   at   ~/. julia /v0.4/Plots/src/ plot . jl : 537   This error is commonly encountered when a series type expects data for  x ,  y , or  z , but instead was passed  nothing  (which is of type  Void ).  Check that you have a  z  value defined for 3D plots, and likewise that you have valid values for  x  and  y .  This could also apply to attributes like  fillrange ,  marker_z , or  line_z  if they are expected to have non-void values.", 
            "title": "MethodError: start has no method matching start(::Void)"
        }, 
        {
            "location": "/ecosystem/", 
            "text": "Plots is great on its own, but the real power comes from the ecosystem surrounding it.  The design of Plots (and more specifically \nRecipesBase\n) is to bind together disparate functionality into a cohesive and consistent user experience.  Some packages may choose to implement recipes to visualize their custom types.  Others may extend the functionality of Plots for Base types.  On this page I'll attempt to collect and display some of the many things you can do using the ecosystem which has developed around the Plots core.\n\n\n\n\nJuliaPlots\n\n\nThe \nJuliaPlots\n organization builds and maintains much of the most commonly used functionality external to core Plots, as well as RecipesBase, PlotUtils, the documentation, and more.\n\n\nStatPlots\n\n\nMuch of this functionality once existed in core Plots, but has been moved out to facilitate a clean separation between those features that are truly \"core\" and those which are specific to certain types of workflows and disciplines.  \n\n\n\n\nTypes:\n\n\nDataFrames\n\n\nDistributions\n\n\n\n\n\n\nRecipes:\n\n\nhistogram/histogram2d\n\n\nboxplot\n\n\nviolin\n\n\nmarginalhist\n\n\ncorrplot/cornerplot\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPlotRecipes\n\n\nA catch-all for functionality and recipes which don't have a home elsewhere.  Graphs (networks of nodes and edges), maps/shapes, finance, and more.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCommunity packages\n\n\nDifferentialEquations\n\n\nDifferentialEquations.jl is a package for solving numerically solving differential equations in Julia by Chris Rackauckas. The purpose of this package is to supply efficient Julia implementations of solvers for various differential equations. Equations within the realm of this package include ordinary differential equations (ODEs), stochastic ordinary differential equations (SODEs or SDEs), stochastic partial differential equations (SPDEs), partial differential equations (with both finite difference and finite element methods), differential algebraic equations, and differential delay equations. It includes well-optimized implementations classic algorithms and ones from recent research, including algorithms optimized for high-precision and HPC applications.\n\n\nAll of the solvers return solution objects which are set up with plot recipes to give informative default plots.\n\n\n\n\nTODO:\n\n\nMLPlots\n\n\nValueHistories\n\n\nLosses\n\n\nIterativeSolvers\n\n\nSymPy\n\n\nImplicitEquations\n\n\nOnlineStats\n\n\nAverageShiftedHistograms\n\n\nPhyloTrees\n\n\nRobotlib\n\n\nEEG\n\n\nControlSystems\n\n\nApproxFun\n\n\nJWAS", 
            "title": "Ecosystem"
        }, 
        {
            "location": "/ecosystem/#juliaplots", 
            "text": "The  JuliaPlots  organization builds and maintains much of the most commonly used functionality external to core Plots, as well as RecipesBase, PlotUtils, the documentation, and more.", 
            "title": "JuliaPlots"
        }, 
        {
            "location": "/ecosystem/#statplots", 
            "text": "Much of this functionality once existed in core Plots, but has been moved out to facilitate a clean separation between those features that are truly \"core\" and those which are specific to certain types of workflows and disciplines.     Types:  DataFrames  Distributions    Recipes:  histogram/histogram2d  boxplot  violin  marginalhist  corrplot/cornerplot", 
            "title": "StatPlots"
        }, 
        {
            "location": "/ecosystem/#plotrecipes", 
            "text": "A catch-all for functionality and recipes which don't have a home elsewhere.  Graphs (networks of nodes and edges), maps/shapes, finance, and more.", 
            "title": "PlotRecipes"
        }, 
        {
            "location": "/ecosystem/#community-packages", 
            "text": "", 
            "title": "Community packages"
        }, 
        {
            "location": "/ecosystem/#differentialequations", 
            "text": "DifferentialEquations.jl is a package for solving numerically solving differential equations in Julia by Chris Rackauckas. The purpose of this package is to supply efficient Julia implementations of solvers for various differential equations. Equations within the realm of this package include ordinary differential equations (ODEs), stochastic ordinary differential equations (SODEs or SDEs), stochastic partial differential equations (SPDEs), partial differential equations (with both finite difference and finite element methods), differential algebraic equations, and differential delay equations. It includes well-optimized implementations classic algorithms and ones from recent research, including algorithms optimized for high-precision and HPC applications.  All of the solvers return solution objects which are set up with plot recipes to give informative default plots.   TODO:", 
            "title": "DifferentialEquations"
        }, 
        {
            "location": "/ecosystem/#mlplots", 
            "text": "", 
            "title": "MLPlots"
        }, 
        {
            "location": "/ecosystem/#valuehistories", 
            "text": "", 
            "title": "ValueHistories"
        }, 
        {
            "location": "/ecosystem/#losses", 
            "text": "", 
            "title": "Losses"
        }, 
        {
            "location": "/ecosystem/#iterativesolvers", 
            "text": "", 
            "title": "IterativeSolvers"
        }, 
        {
            "location": "/ecosystem/#sympy", 
            "text": "", 
            "title": "SymPy"
        }, 
        {
            "location": "/ecosystem/#implicitequations", 
            "text": "", 
            "title": "ImplicitEquations"
        }, 
        {
            "location": "/ecosystem/#onlinestats", 
            "text": "", 
            "title": "OnlineStats"
        }, 
        {
            "location": "/ecosystem/#averageshiftedhistograms", 
            "text": "", 
            "title": "AverageShiftedHistograms"
        }, 
        {
            "location": "/ecosystem/#phylotrees", 
            "text": "", 
            "title": "PhyloTrees"
        }, 
        {
            "location": "/ecosystem/#robotlib", 
            "text": "", 
            "title": "Robotlib"
        }, 
        {
            "location": "/ecosystem/#eeg", 
            "text": "", 
            "title": "EEG"
        }, 
        {
            "location": "/ecosystem/#controlsystems", 
            "text": "", 
            "title": "ControlSystems"
        }, 
        {
            "location": "/ecosystem/#approxfun", 
            "text": "", 
            "title": "ApproxFun"
        }, 
        {
            "location": "/ecosystem/#jwas", 
            "text": "", 
            "title": "JWAS"
        }, 
        {
            "location": "/plots_v0.7/", 
            "text": "Plots - New and improved\n\n\nJust as Gregor Clegane went from \npowerful man\n to \nunstoppable monster\n, Plots is making a transition to a more modular, more powerful, and more customizable visualization platform.\n\n\nThere are two major shifts (recipes and layouts) and countless other smaller changes.  Internally, things look very different, but I've made serious effort to keep things backward-compatible, when appropriate.\n\n\n\n\nRecipes\n\n\nSee \nthe full recipes tutorial\n for a detailed explanation.\n\n\nSparked by a brief comment by @Evizero (Christof Stocker) during a discussion on a Plots issue, the importance of recipes for the future of plotting in Julia became immediately apparent.  I went to work right away to build \nRecipesBase\n, a super lightweight but powerful package which allows users to create intricate plotting logic external to Plots.  The \n@recipe\n macro in RecipesBase will add a method definition for \nRecipesBase.apply_recipe\n.  Plots adds to and calls this same function, and so your package and Plots can communicate without ever knowing about the other.  Magic!\n\n\nVisualizing custom user types has always been a confusing problem.  Should a package developer add a dependency on a plotting package (forcing the significant baggage that comes with that dependency)? Should they attempt conditional dependencies?  Should they submit a PR to graphics packages to define their custom visualizations?  It seems that every option had many cons for each pro, and the decision was tough.  With recipes, these issues go away.  One tiny package (RecipesBase) gives simple hooks into the visualization pipeline, allowing users and package developers to focus solely on the specifics of their visualization.  Pick the shapes/lines/colors that will represent your data well, decide on custom defaults, and convert the inputs (if you need to).  Everything else is handled by Plots.\n\n\nVisualizing User Types\n\n\nExamples are always best.  Lets explore the implementation of \ncreating visualization recipes for Distributions\n.\n\n\nCustom treatment of input combinations\n\n\nWant to do something special whenever the first input is a time series?  Maybe you want to preprocess your data depending on keyword flags?  This is all possible by making recipes with unique dispatch signatures.  You can offload and use the pre and post processing of Plots, and just add the bits that are specific to you.\n\n\nType Recipes: Easy drop-in replacement of data types\n\n\nMany times a data type is a simple wrapper of a Function or Array.  For example:\n\n\ntype\n MyVec\n\n    \nv\n::\nVector\n{\nInt\n}\n\n\nend\n\n\n\n\n\n\nIf \nMyVec\n was a subtype of AbstractVector, there would not be anything to do... it should \"just work\".  However this isn't always desireable, and it would be nice if you could call \nplot(10:20, myvec)\n without having to personally define every possible combination of inputs.  It this case, you'll want to use a special type of recipe signature:\n\n\n@\nrecipe\n \nf\n(::\nType\n{\nMyVec\n},\n \nmyvec\n::\nMyVec\n)\n \n=\n \nmyvec\n.\nv\n\n\n\n\n\n\nAfterwards, all plot commands which work for vectors will also work for your datatype.\n\n\nSeries Recipes\n\n\nLets quickly discuss a mainstay of data visualization: the histogram.  Hadley Wickham has explored the nature of histograms as part of his \nLayered Grammar of Graphics\n.  In it, he discusses how a histogram is really nothing more than a bar graph which has its data pre-binned.  This is true, and it can be taken further.  A bar-graph is really an extension of a step-graph, in which zeros are interwoven among the x-values.  A step-graph is really nothing more than a path (line) which can travel only horizontally or vertically.  Of course, a similar decomposition could be had by treating the bars as filled polygons.\n\n\nThe point to be had is that a graphics package need only be able to draw lines and polygons, and they can support drawing a histogram.  The path from data to histogram is normally very complicated, but we can avoid the complexity and define a recipe to convert it to its subcomponents.  In a few lines of readable code, we can implement a key statistical visualization.  See the \ntutorial on series recipes\n for a better understanding of how you might use them.\n\n\n\n\nLayouts\n\n\nSee the \ntutorial on layouts\n.\n\n\n\n\nEverything else\n\n\nSee the \nNEWS\n.", 
            "title": "Plots v0.7"
        }, 
        {
            "location": "/plots_v0.7/#plots-new-and-improved", 
            "text": "Just as Gregor Clegane went from  powerful man  to  unstoppable monster , Plots is making a transition to a more modular, more powerful, and more customizable visualization platform.  There are two major shifts (recipes and layouts) and countless other smaller changes.  Internally, things look very different, but I've made serious effort to keep things backward-compatible, when appropriate.", 
            "title": "Plots - New and improved"
        }, 
        {
            "location": "/plots_v0.7/#recipes", 
            "text": "See  the full recipes tutorial  for a detailed explanation.  Sparked by a brief comment by @Evizero (Christof Stocker) during a discussion on a Plots issue, the importance of recipes for the future of plotting in Julia became immediately apparent.  I went to work right away to build  RecipesBase , a super lightweight but powerful package which allows users to create intricate plotting logic external to Plots.  The  @recipe  macro in RecipesBase will add a method definition for  RecipesBase.apply_recipe .  Plots adds to and calls this same function, and so your package and Plots can communicate without ever knowing about the other.  Magic!  Visualizing custom user types has always been a confusing problem.  Should a package developer add a dependency on a plotting package (forcing the significant baggage that comes with that dependency)? Should they attempt conditional dependencies?  Should they submit a PR to graphics packages to define their custom visualizations?  It seems that every option had many cons for each pro, and the decision was tough.  With recipes, these issues go away.  One tiny package (RecipesBase) gives simple hooks into the visualization pipeline, allowing users and package developers to focus solely on the specifics of their visualization.  Pick the shapes/lines/colors that will represent your data well, decide on custom defaults, and convert the inputs (if you need to).  Everything else is handled by Plots.", 
            "title": "Recipes"
        }, 
        {
            "location": "/plots_v0.7/#visualizing-user-types", 
            "text": "Examples are always best.  Lets explore the implementation of  creating visualization recipes for Distributions .", 
            "title": "Visualizing User Types"
        }, 
        {
            "location": "/plots_v0.7/#custom-treatment-of-input-combinations", 
            "text": "Want to do something special whenever the first input is a time series?  Maybe you want to preprocess your data depending on keyword flags?  This is all possible by making recipes with unique dispatch signatures.  You can offload and use the pre and post processing of Plots, and just add the bits that are specific to you.", 
            "title": "Custom treatment of input combinations"
        }, 
        {
            "location": "/plots_v0.7/#type-recipes-easy-drop-in-replacement-of-data-types", 
            "text": "Many times a data type is a simple wrapper of a Function or Array.  For example:  type  MyVec \n     v :: Vector { Int }  end   If  MyVec  was a subtype of AbstractVector, there would not be anything to do... it should \"just work\".  However this isn't always desireable, and it would be nice if you could call  plot(10:20, myvec)  without having to personally define every possible combination of inputs.  It this case, you'll want to use a special type of recipe signature:  @ recipe   f (:: Type { MyVec },   myvec :: MyVec )   =   myvec . v   Afterwards, all plot commands which work for vectors will also work for your datatype.", 
            "title": "Type Recipes: Easy drop-in replacement of data types"
        }, 
        {
            "location": "/plots_v0.7/#series-recipes", 
            "text": "Lets quickly discuss a mainstay of data visualization: the histogram.  Hadley Wickham has explored the nature of histograms as part of his  Layered Grammar of Graphics .  In it, he discusses how a histogram is really nothing more than a bar graph which has its data pre-binned.  This is true, and it can be taken further.  A bar-graph is really an extension of a step-graph, in which zeros are interwoven among the x-values.  A step-graph is really nothing more than a path (line) which can travel only horizontally or vertically.  Of course, a similar decomposition could be had by treating the bars as filled polygons.  The point to be had is that a graphics package need only be able to draw lines and polygons, and they can support drawing a histogram.  The path from data to histogram is normally very complicated, but we can avoid the complexity and define a recipe to convert it to its subcomponents.  In a few lines of readable code, we can implement a key statistical visualization.  See the  tutorial on series recipes  for a better understanding of how you might use them.", 
            "title": "Series Recipes"
        }, 
        {
            "location": "/plots_v0.7/#layouts", 
            "text": "See the  tutorial on layouts .", 
            "title": "Layouts"
        }, 
        {
            "location": "/plots_v0.7/#everything-else", 
            "text": "See the  NEWS .", 
            "title": "Everything else"
        }, 
        {
            "location": "/supported/", 
            "text": "Series Types\n\n\nKey:\n\n\n\n\nOrange\n: the series type is natively supported by the backend.\n\n\nBlue\n: the series type is supported through series recipes.\n\n\n\n\n\n\nKeyword Arguments\n\n\n\n\nMarkers\n\n\n\n\nLine styles\n\n\n\n\nScales", 
            "title": "Supported Attributes"
        }, 
        {
            "location": "/supported/#series-types", 
            "text": "Key:   Orange : the series type is natively supported by the backend.  Blue : the series type is supported through series recipes.", 
            "title": "Series Types"
        }, 
        {
            "location": "/supported/#keyword-arguments", 
            "text": "", 
            "title": "Keyword Arguments"
        }, 
        {
            "location": "/supported/#markers", 
            "text": "", 
            "title": "Markers"
        }, 
        {
            "location": "/supported/#line-styles", 
            "text": "", 
            "title": "Line styles"
        }, 
        {
            "location": "/supported/#scales", 
            "text": "", 
            "title": "Scales"
        }, 
        {
            "location": "/examples/pyplot/", 
            "text": "Initialize\n\n\nusing\n \nPlots\n\n\npyplot\n()\n\n\n\n\n\n\nLines\n\n\nA simple line plot of the columns.\n\n\nplot\n(\nPlots\n.\nfakedata\n(\n50\n,\n5\n),\nw\n=\n3\n)\n\n\n\n\n\n\n\n\nFunctions, adding data, and animations\n\n\nPlot multiple functions.  You can also put the function first, or use the form \nplot(f, xmin, xmax)\n where f is a Function or AbstractVector{Function}.\n\n\nGet series data: \nx, y = plt[i]\n.  Set series data: \nplt[i] = (x,y)\n. Add to the series with \npush!\n/\nappend!\n.\n\n\nEasily build animations.  (\nconvert\n or \nffmpeg\n must be available to generate the animation.)  Use command \ngif(anim, filename, fps=15)\n to save the animation.\n\n\np\n \n=\n \nplot\n([\nsin\n,\ncos\n],\nzeros\n(\n0\n),\nleg\n=\nfalse\n)\n\n\nanim\n \n=\n \nAnimation\n()\n\n\nfor\n \nx\n \n=\n \nlinspace\n(\n0\n,\n10\n\u03c0\n,\n100\n)\n\n    \npush!\n(\np\n,\nx\n,\nFloat64\n[\nsin\n(\nx\n),\ncos\n(\nx\n)])\n\n    \nframe\n(\nanim\n)\n\n\nend\n\n\n\n\n\n\n\n\nParametric plots\n\n\nPlot function pair (x(u), y(u)).\n\n\nplot\n(\nsin\n,(\nx\n-\nbegin\n \n            \nsin\n(\n2\nx\n)\n\n        \nend\n),\n0\n,\n2\n\u03c0\n,\nline\n=\n4\n,\nleg\n=\nfalse\n,\nfill\n=\n(\n0\n,:\norange\n))\n\n\n\n\n\n\n\n\nColors\n\n\nAccess predefined palettes (or build your own with the \ncolorscheme\n method).  Line/marker colors are auto-generated from the plot's palette, unless overridden.  Set the \nz\n argument to turn on series gradients.\n\n\ny\n \n=\n \nrand\n(\n100\n)\n\n\nplot\n(\n0\n:\n10\n:\n100\n,\nrand\n(\n11\n,\n4\n),\nlab\n=\nlines\n,\nw\n=\n3\n,\npalette\n=\n:\ngrays\n,\nfill\n=\n(\n0\n,:\nauto\n),\n\u03b1\n=\n0.6\n)\n\n\nscatter!\n(\ny\n,\nzcolor\n=\nabs\n(\ny\n \n-\n \n0.5\n),\nm\n=\n(:\nheat\n,\n0.8\n,\nstroke\n(\n1\n,:\ngreen\n)),\nms\n=\n10\n \n*\n \nabs\n(\ny\n \n-\n \n0.5\n)\n \n+\n \n4\n,\nlab\n=\ngrad\n)\n\n\n\n\n\n\n\n\nGlobal\n\n\nChange the guides/background/limits/ticks.  Convenience args \nxaxis\n and \nyaxis\n allow you to pass a tuple or value which will be mapped to the relevant args automatically.  The \nxaxis\n below will be replaced with \nxlabel\n and \nxlims\n args automatically during the preprocessing step. You can also use shorthand functions: \ntitle!\n, \nxaxis!\n, \nyaxis!\n, \nxlabel!\n, \nylabel!\n, \nxlims!\n, \nylims!\n, \nxticks!\n, \nyticks!\n\n\ny\n \n=\n \nrand\n(\n20\n,\n3\n)\n\n\nplot\n(\ny\n,\nxaxis\n=\n(\nXLABEL\n,(\n-\n5\n,\n30\n),\n0\n:\n2\n:\n20\n,:\nflip\n),\nbackground_color\n=\nRGB\n(\n0.2\n,\n0.2\n,\n0.2\n),\nleg\n=\nfalse\n)\n\n\nhline!\n(\nmean\n(\ny\n,\n1\n)\n \n+\n \nrand\n(\n1\n,\n3\n),\nline\n=\n(\n4\n,:\ndash\n,\n0.6\n,[:\nlightgreen\n \n:\ngreen\n \n:\ndarkgreen\n]))\n\n\nvline!\n([\n5\n,\n10\n])\n\n\ntitle!\n(\nTITLE\n)\n\n\nyaxis!\n(\nYLABEL\n,:\nlog10\n)\n\n\n\n\n\n\n\n\nImages\n\n\nPlot an image.  y-axis is set to flipped\n\n\nimport\n \nImages\n\n\nimg\n \n=\n \nImages\n.\nload\n(\nPkg\n.\ndir\n(\nPlotReferenceImages\n,\nPlots\n,\npyplot\n,\n0.7.0\n,\nref1.png\n))\n\n\nplot\n(\nimg\n)\n\n\n\n\n\n\n\n\nArguments\n\n\nPlot multiple series with different numbers of points.  Mix arguments that apply to all series (marker/markersize) with arguments unique to each series (colors).  Special arguments \nline\n, \nmarker\n, and \nfill\n will automatically figure out what arguments to set (for example, we are setting the \nlinestyle\n, \nlinewidth\n, and \ncolor\n arguments with \nline\n.)  Note that we pass a matrix of colors, and this applies the colors to each series.\n\n\nys\n \n=\n \nVector\n[\nrand\n(\n10\n),\nrand\n(\n20\n)]\n\n\nplot\n(\nys\n,\ncolor\n=\n[:\nblack\n \n:\norange\n],\nline\n=\n(:\ndot\n,\n4\n),\nmarker\n=\n([:\nhex\n \n:\nd\n],\n12\n,\n0.8\n,\nstroke\n(\n3\n,:\ngray\n)))\n\n\n\n\n\n\n\n\nBuild plot in pieces\n\n\nStart with a base plot...\n\n\nplot\n(\nrand\n(\n100\n)\n \n/\n \n3\n,\nreg\n=\ntrue\n,\nfill\n=\n(\n0\n,:\ngreen\n))\n\n\n\n\n\n\n\n\n\n\nand add to it later.\n\n\nscatter!\n(\nrand\n(\n100\n),\nmarkersize\n=\n6\n,\nc\n=\n:\norange\n)\n\n\n\n\n\n\n\n\nHistogram2D\n\n\nhistogram2d\n(\nrandn\n(\n10000\n),\nrandn\n(\n10000\n),\nnbins\n=\n20\n)\n\n\n\n\n\n\n\n\nLine types\n\n\nlinetypes\n \n=\n \n[:\npath\n \n:\nsteppre\n \n:\nsteppost\n \n:\nsticks\n \n:\nscatter\n]\n\n\nn\n \n=\n \nlength\n(\nlinetypes\n)\n\n\nx\n \n=\n \nVector\n[\nsort\n(\nrand\n(\n20\n))\n \nfor\n \ni\n \n=\n \n1\n:\nn\n]\n\n\ny\n \n=\n \nrand\n(\n20\n,\nn\n)\n\n\nplot\n(\nx\n,\ny\n,\nline\n=\n(\nlinetypes\n,\n3\n),\nlab\n=\nmap\n(\nstring\n,\nlinetypes\n),\nms\n=\n15\n)\n\n\n\n\n\n\n\n\nLine styles\n\n\nstyles\n \n=\n \nsetdiff\n(\nsupported_styles\n(),[:\nauto\n])\n\n\nplot\n(\ncumsum\n(\nrandn\n(\n20\n,\nlength\n(\nstyles\n)),\n1\n),\nstyle\n=\n:\nauto\n,\nlabel\n=\nmap\n(\nstring\n,\nstyles\n),\nw\n=\n5\n)\n\n\n\n\n\n\n\n\nMarker types\n\n\nmarkers\n \n=\n \nsetdiff\n(\nsupported_markers\n(),[:\nnone\n,:\nauto\n,\nShape\n])\n\n\nn\n \n=\n \nlength\n(\nmarkers\n)\n\n\nx\n \n=\n \n(\nlinspace\n(\n0\n,\n10\n,\nn\n \n+\n \n2\n))[\n2\n:\nend\n \n-\n \n1\n]\n\n\ny\n \n=\n \nrepmat\n(\nreverse\n(\nx\n)\n,\nn\n,\n1\n)\n\n\nscatter\n(\nx\n,\ny\n,\nm\n=\n(\n8\n,:\nauto\n),\nlab\n=\nmap\n(\nstring\n,\nmarkers\n),\nbg\n=\n:\nlinen\n,\nxlim\n=\n(\n0\n,\n10\n),\nylim\n=\n(\n0\n,\n10\n))\n\n\n\n\n\n\n\n\nBar\n\n\nx is the midpoint of the bar. (todo: allow passing of edges instead of midpoints)\n\n\nbar\n(\nrandn\n(\n99\n))\n\n\n\n\n\n\n\n\nHistogram\n\n\nhistogram\n(\nrandn\n(\n1000\n),\nnbins\n=\n20\n)\n\n\n\n\n\n\n\n\nSubplots\n\n\nUse the \nlayout\n keyword, and optionally the convenient \n@layout\n macro to generate arbitrarily complex subplot layouts.\n\n\nl\n \n=\n \n@\nlayout\n([\na\n{\n0.1\nh\n},\nb\n \n[\nc\n,\nd\n \ne\n]])\n\n\nplot\n(\nrandn\n(\n100\n,\n5\n),\nlayout\n=\nl\n,\nt\n=\n[:\nline\n \n:\nhistogram\n \n:\nscatter\n \n:\nsteppre\n \n:\nbar\n],\nleg\n=\nfalse\n,\nticks\n=\nnothing\n,\nborder\n=\nfalse\n)\n\n\n\n\n\n\n\n\nAdding to subplots\n\n\nNote here the automatic grid layout, as well as the order in which new series are added to the plots.\n\n\nplot\n(\nPlots\n.\nfakedata\n(\n100\n,\n10\n),\nlayout\n=\n4\n,\npalette\n=\n[:\ngrays\n \n:\nblues\n \n:\nheat\n \n:\nlightrainbow\n],\nbg_inside\n=\n[:\norange\n \n:\npink\n \n:\ndarkblue\n \n:\nblack\n])\n\n\n\n\n\n\n\n\n\n\nsrand\n(\n111\n)\n\n\nplot!\n(\nPlots\n.\nfakedata\n(\n100\n,\n10\n))\n\n\n\n\n\n\n\n\nOpen/High/Low/Close\n\n\nCreate an OHLC chart.  Pass in a list of (open,high,low,close) tuples as your \ny\n argument.  This uses recipes to first convert the tuples to OHLC objects, and subsequently create a :path series with the appropriate line segments.\n\n\nn\n \n=\n \n20\n\n\nhgt\n \n=\n \nrand\n(\nn\n)\n \n+\n \n1\n\n\nbot\n \n=\n \nrandn\n(\nn\n)\n\n\nopenpct\n \n=\n \nrand\n(\nn\n)\n\n\nclosepct\n \n=\n \nrand\n(\nn\n)\n\n\ny\n \n=\n \nOHLC\n[(\nopenpct\n[\ni\n]\n \n*\n \nhgt\n[\ni\n]\n \n+\n \nbot\n[\ni\n],\nbot\n[\ni\n]\n \n+\n \nhgt\n[\ni\n],\nbot\n[\ni\n],\nclosepct\n[\ni\n]\n \n*\n \nhgt\n[\ni\n]\n \n+\n \nbot\n[\ni\n])\n \nfor\n \ni\n \n=\n \n1\n:\nn\n]\n\n\nohlc\n(\ny\n)\n\n\n\n\n\n\n\n\nAnnotations\n\n\nThe \nannotations\n keyword is used for text annotations in data-coordinates.  Pass in a tuple (x,y,text) or a vector of annotations.  \nannotate!(ann)\n is shorthand for \nplot!(; annotation=ann)\n.  Series annotations are used for annotating individual data points.  They require only the annotation... x/y values are computed.  A \nPlotText\n object can be build with the method \ntext(string, attr...)\n, which wraps font and color attributes.\n\n\ny\n \n=\n \nrand\n(\n10\n)\n\n\nplot\n(\ny\n,\nannotations\n=\n(\n3\n,\ny\n[\n3\n],\ntext\n(\nthis is #3\n,:\nleft\n)),\nleg\n=\nfalse\n)\n\n\nannotate!\n([(\n5\n,\ny\n[\n5\n],\ntext\n(\nthis is #5\n,\n16\n,:\nred\n,:\ncenter\n)),(\n10\n,\ny\n[\n10\n],\ntext\n(\nthis is #10\n,:\nright\n,\n20\n,\ncourier\n))])\n\n\nscatter!\n(\nlinspace\n(\n2\n,\n8\n,\n6\n),\nrand\n(\n6\n),\nmarker\n=\n(\n50\n,\n0.2\n,:\norange\n),\nseries_annotations\n=\n[\nseries\n,\nannotations\n,\nmap\n,\nto\n,\nseries\n,\ntext\n(\ndata\n,:\ngreen\n)])\n\n\n\n\n\n\n\n\nCustom Markers\n\n\nA \nPlots.Shape\n is a light wrapper around vertices of a polygon.  For supported backends, pass arbitrary polygons as the marker shapes.  Note: The center is (0,0) and the size is expected to be rougly the area of the unit circle.\n\n\nverts\n \n=\n \n[(\n-\n1.0\n,\n1.0\n),(\n-\n1.28\n,\n0.6\n),(\n-\n0.2\n,\n-\n1.4\n),(\n0.2\n,\n-\n1.4\n),(\n1.28\n,\n0.6\n),(\n1.0\n,\n1.0\n),(\n-\n1.0\n,\n1.0\n),(\n-\n0.2\n,\n-\n0.6\n),(\n0.0\n,\n-\n0.2\n),(\n-\n0.4\n,\n0.6\n),(\n1.28\n,\n0.6\n),(\n0.2\n,\n-\n1.4\n),(\n-\n0.2\n,\n-\n1.4\n),(\n0.6\n,\n0.2\n),(\n-\n0.2\n,\n0.2\n),(\n0.0\n,\n-\n0.2\n),(\n0.2\n,\n0.2\n),(\n-\n0.2\n,\n-\n0.6\n)]\n\n\nx\n \n=\n \n0.1\n:\n0.2\n:\n0.9\n\n\ny\n \n=\n \n0.7\n \n*\n \nrand\n(\n5\n)\n \n+\n \n0.15\n\n\nplot\n(\nx\n,\ny\n,\nline\n=\n(\n3\n,:\ndash\n,:\nlightblue\n),\nmarker\n=\n(\nShape\n(\nverts\n),\n30\n,\nRGBA\n(\n0\n,\n0\n,\n0\n,\n0.2\n)),\nbg\n=\n:\npink\n,\nfg\n=\n:\ndarkblue\n,\nxlim\n=\n(\n0\n,\n1\n),\nylim\n=\n(\n0\n,\n1\n),\nleg\n=\nfalse\n)\n\n\n\n\n\n\n\n\nContours\n\n\nAny value for fill works here.  We first build a filled contour from a function, then an unfilled contour from a matrix.\n\n\nx\n \n=\n \n1\n:\n0.5\n:\n20\n\n\ny\n \n=\n \n1\n:\n0.5\n:\n10\n\n\nf\n(\nx\n,\ny\n)\n \n=\n \nbegin\n \n        \n(\n3\nx\n \n+\n \ny\n \n^\n \n2\n)\n \n*\n \nabs\n(\nsin\n(\nx\n)\n \n+\n \ncos\n(\ny\n))\n\n    \nend\n\n\nX\n \n=\n \nrepmat\n(\nx\n,\nlength\n(\ny\n),\n1\n)\n\n\nY\n \n=\n \nrepmat\n(\ny\n,\n1\n,\nlength\n(\nx\n))\n\n\nZ\n \n=\n \nmap\n(\nf\n,\nX\n,\nY\n)\n\n\np1\n \n=\n \ncontour\n(\nx\n,\ny\n,\nf\n,\nfill\n=\ntrue\n)\n\n\np2\n \n=\n \ncontour\n(\nx\n,\ny\n,\nZ\n)\n\n\nplot\n(\np1\n,\np2\n)\n\n\n\n\n\n\n\n\nPie\n\n\nx\n \n=\n \n[\nNerds\n,\nHackers\n,\nScientists\n]\n\n\ny\n \n=\n \n[\n0.4\n,\n0.35\n,\n0.25\n]\n\n\npie\n(\nx\n,\ny\n,\ntitle\n=\nThe Julia Community\n,\nl\n=\n0.5\n)\n\n\n\n\n\n\n\n\n3D\n\n\nn\n \n=\n \n100\n\n\nts\n \n=\n \nlinspace\n(\n0\n,\n8\n\u03c0\n,\nn\n)\n\n\nx\n \n=\n \nts\n \n.*\n \nmap\n(\ncos\n,\nts\n)\n\n\ny\n \n=\n \n(\n0.1\nts\n)\n \n.*\n \nmap\n(\nsin\n,\nts\n)\n\n\nz\n \n=\n \n1\n:\nn\n\n\nplot\n(\nx\n,\ny\n,\nz\n,\nzcolor\n=\nreverse\n(\nz\n),\nm\n=\n(\n10\n,\n0.8\n,:\nblues\n,\nstroke\n(\n0\n)),\nleg\n=\nfalse\n,\ncbar\n=\ntrue\n,\nw\n=\n5\n)\n\n\nplot!\n(\nzeros\n(\nn\n),\nzeros\n(\nn\n),\n1\n:\nn\n,\nw\n=\n10\n)\n\n\n\n\n\n\n\n\nDataFrames\n\n\nPlot using DataFrame column symbols.\n\n\nimport\n \nRDatasets\n\n\niris\n \n=\n \nRDatasets\n.\ndataset\n(\ndatasets\n,\niris\n)\n\n\nscatter\n(\niris\n,:\nSepalLength\n,:\nSepalWidth\n,\ngroup\n=\n:\nSpecies\n,\ntitle\n=\nMy awesome plot\n,\nxlabel\n=\nLength\n,\nylabel\n=\nWidth\n,\nmarker\n=\n(\n0.5\n,[:\n+\n \n:\nh\n \n:\nstar7\n],\n12\n),\nbg\n=\nRGB\n(\n0.2\n,\n0.2\n,\n0.2\n))\n\n\n\n\n\n\n\n\nGroups and Subplots\n\n\ngroup\n \n=\n \nrand\n(\nmap\n((\ni\n-\nbegin\n \n                    \ngroup \n$(i)\n\n                \nend\n),\n1\n:\n4\n),\n100\n)\n\n\nplot\n(\nrand\n(\n100\n),\nlayout\n=\n@\nlayout\n([\na\n \nb\n;\nc\n]),\ngroup\n=\ngroup\n,\nn\n=\n3\n,\nlinetype\n=\n[:\nbar\n \n:\nscatter\n \n:\nsteppre\n])\n\n\n\n\n\n\n\n\nPolar Plots\n\n\n\u0398\n \n=\n \nlinspace\n(\n0\n,\n1.5\n\u03c0\n,\n100\n)\n\n\nr\n \n=\n \nabs\n(\n0.1\n \n*\n \nrandn\n(\n100\n)\n \n+\n \nsin\n(\n3\n\u0398\n))\n\n\nplot\n(\n\u0398\n,\nr\n,\nproj\n=\n:\npolar\n,\nm\n=\n2\n)\n\n\n\n\n\n\n\n\nHeatmap, categorical axes, and aspect_ratio\n\n\nxs\n \n=\n \n[\nstring\n(\nx\n,\ni\n)\n \nfor\n \ni\n \n=\n \n1\n:\n10\n]\n\n\nys\n \n=\n \n[\nstring\n(\ny\n,\ni\n)\n \nfor\n \ni\n \n=\n \n1\n:\n4\n]\n\n\nz\n \n=\n \nfloat\n((\n1\n:\n4\n)\n \n*\n \n1\n:\n10\n)\n\n\nheatmap\n(\nxs\n,\nys\n,\nz\n,\naspect_ratio\n=\n1\n)\n\n\n\n\n\n\n\n\nLayouts, margins, label rotation, title location\n\n\nplot\n(\nrand\n(\n100\n,\n6\n),\nlayout\n=\n@\nlayout\n([\na\n \nb\n;\nc\n]),\ntitle\n=\n[\nA\n \nB\n \nC\n],\ntitle_location\n=\n:\nleft\n,\nleft_margin\n=\n[\n20\nmm\n \n0\nmm\n],\nbottom_margin\n=\n50\npx\n,\nxrotation\n=\n60\n)\n\n\n\n\n\n\n\n\nBoxplot and Violin series recipes\n\n\nimport\n \nRDatasets\n\n\nsingers\n \n=\n \nRDatasets\n.\ndataset\n(\nlattice\n,\nsinger\n)\n\n\nviolin\n(\nsingers\n,:\nVoicePart\n,:\nHeight\n,\nmarker\n=\n(\n0.2\n,:\nblue\n,\nstroke\n(\n0\n)))\n\n\nboxplot!\n(\nsingers\n,:\nVoicePart\n,:\nHeight\n,\nmarker\n=\n(\n0.3\n,:\norange\n,\nstroke\n(\n2\n)))\n\n\n\n\n\n\n\n\n\n\nSupported arguments: \nannotations\n, \narrow\n, \naspect_ratio\n, \nbackground_color\n, \nbackground_color_inside\n, \nbackground_color_legend\n, \nbackground_color_outside\n, \nbar_edges\n, \nbar_width\n, \nbins\n, \nclims\n, \ncolor_palette\n, \ncolorbar\n, \ncontours\n, \nfillalpha\n, \nfillcolor\n, \nfillrange\n, \nforeground_color\n, \nforeground_color_axis\n, \nforeground_color_border\n, \nforeground_color_grid\n, \nforeground_color_legend\n, \nforeground_color_text\n, \ngrid\n, \ngroup\n, \nguidefont\n, \nlabel\n, \nlayout\n, \nlegend\n, \nlegendfont\n, \nlevels\n, \nlinealpha\n, \nlinecolor\n, \nlinestyle\n, \nlinewidth\n, \nmarker_z\n, \nmarkeralpha\n, \nmarkercolor\n, \nmarkershape\n, \nmarkersize\n, \nmarkerstrokealpha\n, \nmarkerstrokecolor\n, \nmarkerstrokewidth\n, \nmatch_dimensions\n, \nn\n, \nnc\n, \nnormalize\n, \nnr\n, \norientation\n, \noverwrite_figure\n, \npolar\n, \nquiver\n, \nribbon\n, \nseriesalpha\n, \nseriescolor\n, \nseriestype\n, \nshow\n, \nsize\n, \nsmooth\n, \nsubplot\n, \ntickfont\n, \ntitle\n, \nweights\n, \nwindow_title\n, \nx\n, \nxerror\n, \nxflip\n, \nxguide\n, \nxlims\n, \nxrotation\n, \nxscale\n, \nxticks\n, \ny\n, \nyerror\n, \nyflip\n, \nyguide\n, \nylims\n, \nyrotation\n, \nyscale\n, \nyticks\n, \nz\n, \nz\n, \nzflip\n, \nzguide\n, \nzlims\n, \nzrotation\n, \nzscale\n, \nzticks\n\n\nSupported values for linetype: \n:bar\n, \n:contour\n, \n:contour3d\n, \n:heatmap\n, \n:hexbin\n, \n:histogram\n, \n:histogram2d\n, \n:hline\n, \n:image\n, \n:line\n, \n:none\n, \n:path\n, \n:path3d\n, \n:pie\n, \n:scatter\n, \n:scatter3d\n, \n:shape\n, \n:steppost\n, \n:steppre\n, \n:sticks\n, \n:surface\n, \n:vline\n, \n:wireframe\n\n\nSupported values for linestyle: \n:auto\n, \n:dash\n, \n:dashdot\n, \n:dot\n, \n:solid\n\n\nSupported values for marker: \n:Plots.Shape\n, \n:auto\n, \n:cross\n, \n:diamond\n, \n:dtriangle\n, \n:circle\n, \n:heptagon\n, \n:hexagon\n, \n:hline\n, \n:none\n, \n:octagon\n, \n:pentagon\n, \n:rect\n, \n:star4\n, \n:star5\n, \n:star6\n, \n:star7\n, \n:star8\n, \n:utriangle\n, \n:vline\n, \n:xcross\n\n(Automatically generated: 2016-06-10T13:38:20)", 
            "title": "PyPlot"
        }, 
        {
            "location": "/examples/pyplot/#initialize", 
            "text": "using   Plots  pyplot ()", 
            "title": "Initialize"
        }, 
        {
            "location": "/examples/pyplot/#lines", 
            "text": "A simple line plot of the columns.  plot ( Plots . fakedata ( 50 , 5 ), w = 3 )", 
            "title": "Lines"
        }, 
        {
            "location": "/examples/pyplot/#functions-adding-data-and-animations", 
            "text": "Plot multiple functions.  You can also put the function first, or use the form  plot(f, xmin, xmax)  where f is a Function or AbstractVector{Function}.  Get series data:  x, y = plt[i] .  Set series data:  plt[i] = (x,y) . Add to the series with  push! / append! .  Easily build animations.  ( convert  or  ffmpeg  must be available to generate the animation.)  Use command  gif(anim, filename, fps=15)  to save the animation.  p   =   plot ([ sin , cos ], zeros ( 0 ), leg = false )  anim   =   Animation ()  for   x   =   linspace ( 0 , 10 \u03c0 , 100 ) \n     push! ( p , x , Float64 [ sin ( x ), cos ( x )]) \n     frame ( anim )  end", 
            "title": "Functions, adding data, and animations"
        }, 
        {
            "location": "/examples/pyplot/#parametric-plots", 
            "text": "Plot function pair (x(u), y(u)).  plot ( sin ,( x - begin  \n             sin ( 2 x ) \n         end ), 0 , 2 \u03c0 , line = 4 , leg = false , fill = ( 0 ,: orange ))", 
            "title": "Parametric plots"
        }, 
        {
            "location": "/examples/pyplot/#colors", 
            "text": "Access predefined palettes (or build your own with the  colorscheme  method).  Line/marker colors are auto-generated from the plot's palette, unless overridden.  Set the  z  argument to turn on series gradients.  y   =   rand ( 100 )  plot ( 0 : 10 : 100 , rand ( 11 , 4 ), lab = lines , w = 3 , palette = : grays , fill = ( 0 ,: auto ), \u03b1 = 0.6 )  scatter! ( y , zcolor = abs ( y   -   0.5 ), m = (: heat , 0.8 , stroke ( 1 ,: green )), ms = 10   *   abs ( y   -   0.5 )   +   4 , lab = grad )", 
            "title": "Colors"
        }, 
        {
            "location": "/examples/pyplot/#global", 
            "text": "Change the guides/background/limits/ticks.  Convenience args  xaxis  and  yaxis  allow you to pass a tuple or value which will be mapped to the relevant args automatically.  The  xaxis  below will be replaced with  xlabel  and  xlims  args automatically during the preprocessing step. You can also use shorthand functions:  title! ,  xaxis! ,  yaxis! ,  xlabel! ,  ylabel! ,  xlims! ,  ylims! ,  xticks! ,  yticks!  y   =   rand ( 20 , 3 )  plot ( y , xaxis = ( XLABEL ,( - 5 , 30 ), 0 : 2 : 20 ,: flip ), background_color = RGB ( 0.2 , 0.2 , 0.2 ), leg = false )  hline! ( mean ( y , 1 )   +   rand ( 1 , 3 ), line = ( 4 ,: dash , 0.6 ,[: lightgreen   : green   : darkgreen ]))  vline! ([ 5 , 10 ])  title! ( TITLE )  yaxis! ( YLABEL ,: log10 )", 
            "title": "Global"
        }, 
        {
            "location": "/examples/pyplot/#images", 
            "text": "Plot an image.  y-axis is set to flipped  import   Images  img   =   Images . load ( Pkg . dir ( PlotReferenceImages , Plots , pyplot , 0.7.0 , ref1.png ))  plot ( img )", 
            "title": "Images"
        }, 
        {
            "location": "/examples/pyplot/#arguments", 
            "text": "Plot multiple series with different numbers of points.  Mix arguments that apply to all series (marker/markersize) with arguments unique to each series (colors).  Special arguments  line ,  marker , and  fill  will automatically figure out what arguments to set (for example, we are setting the  linestyle ,  linewidth , and  color  arguments with  line .)  Note that we pass a matrix of colors, and this applies the colors to each series.  ys   =   Vector [ rand ( 10 ), rand ( 20 )]  plot ( ys , color = [: black   : orange ], line = (: dot , 4 ), marker = ([: hex   : d ], 12 , 0.8 , stroke ( 3 ,: gray )))", 
            "title": "Arguments"
        }, 
        {
            "location": "/examples/pyplot/#build-plot-in-pieces", 
            "text": "Start with a base plot...  plot ( rand ( 100 )   /   3 , reg = true , fill = ( 0 ,: green ))", 
            "title": "Build plot in pieces"
        }, 
        {
            "location": "/examples/pyplot/#histogram2d", 
            "text": "histogram2d ( randn ( 10000 ), randn ( 10000 ), nbins = 20 )", 
            "title": "Histogram2D"
        }, 
        {
            "location": "/examples/pyplot/#line-types", 
            "text": "linetypes   =   [: path   : steppre   : steppost   : sticks   : scatter ]  n   =   length ( linetypes )  x   =   Vector [ sort ( rand ( 20 ))   for   i   =   1 : n ]  y   =   rand ( 20 , n )  plot ( x , y , line = ( linetypes , 3 ), lab = map ( string , linetypes ), ms = 15 )", 
            "title": "Line types"
        }, 
        {
            "location": "/examples/pyplot/#line-styles", 
            "text": "styles   =   setdiff ( supported_styles (),[: auto ])  plot ( cumsum ( randn ( 20 , length ( styles )), 1 ), style = : auto , label = map ( string , styles ), w = 5 )", 
            "title": "Line styles"
        }, 
        {
            "location": "/examples/pyplot/#marker-types", 
            "text": "markers   =   setdiff ( supported_markers (),[: none ,: auto , Shape ])  n   =   length ( markers )  x   =   ( linspace ( 0 , 10 , n   +   2 ))[ 2 : end   -   1 ]  y   =   repmat ( reverse ( x ) , n , 1 )  scatter ( x , y , m = ( 8 ,: auto ), lab = map ( string , markers ), bg = : linen , xlim = ( 0 , 10 ), ylim = ( 0 , 10 ))", 
            "title": "Marker types"
        }, 
        {
            "location": "/examples/pyplot/#bar", 
            "text": "x is the midpoint of the bar. (todo: allow passing of edges instead of midpoints)  bar ( randn ( 99 ))", 
            "title": "Bar"
        }, 
        {
            "location": "/examples/pyplot/#histogram", 
            "text": "histogram ( randn ( 1000 ), nbins = 20 )", 
            "title": "Histogram"
        }, 
        {
            "location": "/examples/pyplot/#subplots", 
            "text": "Use the  layout  keyword, and optionally the convenient  @layout  macro to generate arbitrarily complex subplot layouts.  l   =   @ layout ([ a { 0.1 h }, b   [ c , d   e ]])  plot ( randn ( 100 , 5 ), layout = l , t = [: line   : histogram   : scatter   : steppre   : bar ], leg = false , ticks = nothing , border = false )", 
            "title": "Subplots"
        }, 
        {
            "location": "/examples/pyplot/#adding-to-subplots", 
            "text": "Note here the automatic grid layout, as well as the order in which new series are added to the plots.  plot ( Plots . fakedata ( 100 , 10 ), layout = 4 , palette = [: grays   : blues   : heat   : lightrainbow ], bg_inside = [: orange   : pink   : darkblue   : black ])", 
            "title": "Adding to subplots"
        }, 
        {
            "location": "/examples/pyplot/#openhighlowclose", 
            "text": "Create an OHLC chart.  Pass in a list of (open,high,low,close) tuples as your  y  argument.  This uses recipes to first convert the tuples to OHLC objects, and subsequently create a :path series with the appropriate line segments.  n   =   20  hgt   =   rand ( n )   +   1  bot   =   randn ( n )  openpct   =   rand ( n )  closepct   =   rand ( n )  y   =   OHLC [( openpct [ i ]   *   hgt [ i ]   +   bot [ i ], bot [ i ]   +   hgt [ i ], bot [ i ], closepct [ i ]   *   hgt [ i ]   +   bot [ i ])   for   i   =   1 : n ]  ohlc ( y )", 
            "title": "Open/High/Low/Close"
        }, 
        {
            "location": "/examples/pyplot/#annotations", 
            "text": "The  annotations  keyword is used for text annotations in data-coordinates.  Pass in a tuple (x,y,text) or a vector of annotations.   annotate!(ann)  is shorthand for  plot!(; annotation=ann) .  Series annotations are used for annotating individual data points.  They require only the annotation... x/y values are computed.  A  PlotText  object can be build with the method  text(string, attr...) , which wraps font and color attributes.  y   =   rand ( 10 )  plot ( y , annotations = ( 3 , y [ 3 ], text ( this is #3 ,: left )), leg = false )  annotate! ([( 5 , y [ 5 ], text ( this is #5 , 16 ,: red ,: center )),( 10 , y [ 10 ], text ( this is #10 ,: right , 20 , courier ))])  scatter! ( linspace ( 2 , 8 , 6 ), rand ( 6 ), marker = ( 50 , 0.2 ,: orange ), series_annotations = [ series , annotations , map , to , series , text ( data ,: green )])", 
            "title": "Annotations"
        }, 
        {
            "location": "/examples/pyplot/#custom-markers", 
            "text": "A  Plots.Shape  is a light wrapper around vertices of a polygon.  For supported backends, pass arbitrary polygons as the marker shapes.  Note: The center is (0,0) and the size is expected to be rougly the area of the unit circle.  verts   =   [( - 1.0 , 1.0 ),( - 1.28 , 0.6 ),( - 0.2 , - 1.4 ),( 0.2 , - 1.4 ),( 1.28 , 0.6 ),( 1.0 , 1.0 ),( - 1.0 , 1.0 ),( - 0.2 , - 0.6 ),( 0.0 , - 0.2 ),( - 0.4 , 0.6 ),( 1.28 , 0.6 ),( 0.2 , - 1.4 ),( - 0.2 , - 1.4 ),( 0.6 , 0.2 ),( - 0.2 , 0.2 ),( 0.0 , - 0.2 ),( 0.2 , 0.2 ),( - 0.2 , - 0.6 )]  x   =   0.1 : 0.2 : 0.9  y   =   0.7   *   rand ( 5 )   +   0.15  plot ( x , y , line = ( 3 ,: dash ,: lightblue ), marker = ( Shape ( verts ), 30 , RGBA ( 0 , 0 , 0 , 0.2 )), bg = : pink , fg = : darkblue , xlim = ( 0 , 1 ), ylim = ( 0 , 1 ), leg = false )", 
            "title": "Custom Markers"
        }, 
        {
            "location": "/examples/pyplot/#contours", 
            "text": "Any value for fill works here.  We first build a filled contour from a function, then an unfilled contour from a matrix.  x   =   1 : 0.5 : 20  y   =   1 : 0.5 : 10  f ( x , y )   =   begin  \n         ( 3 x   +   y   ^   2 )   *   abs ( sin ( x )   +   cos ( y )) \n     end  X   =   repmat ( x , length ( y ), 1 )  Y   =   repmat ( y , 1 , length ( x ))  Z   =   map ( f , X , Y )  p1   =   contour ( x , y , f , fill = true )  p2   =   contour ( x , y , Z )  plot ( p1 , p2 )", 
            "title": "Contours"
        }, 
        {
            "location": "/examples/pyplot/#pie", 
            "text": "x   =   [ Nerds , Hackers , Scientists ]  y   =   [ 0.4 , 0.35 , 0.25 ]  pie ( x , y , title = The Julia Community , l = 0.5 )", 
            "title": "Pie"
        }, 
        {
            "location": "/examples/pyplot/#3d", 
            "text": "n   =   100  ts   =   linspace ( 0 , 8 \u03c0 , n )  x   =   ts   .*   map ( cos , ts )  y   =   ( 0.1 ts )   .*   map ( sin , ts )  z   =   1 : n  plot ( x , y , z , zcolor = reverse ( z ), m = ( 10 , 0.8 ,: blues , stroke ( 0 )), leg = false , cbar = true , w = 5 )  plot! ( zeros ( n ), zeros ( n ), 1 : n , w = 10 )", 
            "title": "3D"
        }, 
        {
            "location": "/examples/pyplot/#dataframes", 
            "text": "Plot using DataFrame column symbols.  import   RDatasets  iris   =   RDatasets . dataset ( datasets , iris )  scatter ( iris ,: SepalLength ,: SepalWidth , group = : Species , title = My awesome plot , xlabel = Length , ylabel = Width , marker = ( 0.5 ,[: +   : h   : star7 ], 12 ), bg = RGB ( 0.2 , 0.2 , 0.2 ))", 
            "title": "DataFrames"
        }, 
        {
            "location": "/examples/pyplot/#groups-and-subplots", 
            "text": "group   =   rand ( map (( i - begin  \n                     group  $(i) \n                 end ), 1 : 4 ), 100 )  plot ( rand ( 100 ), layout = @ layout ([ a   b ; c ]), group = group , n = 3 , linetype = [: bar   : scatter   : steppre ])", 
            "title": "Groups and Subplots"
        }, 
        {
            "location": "/examples/pyplot/#polar-plots", 
            "text": "\u0398   =   linspace ( 0 , 1.5 \u03c0 , 100 )  r   =   abs ( 0.1   *   randn ( 100 )   +   sin ( 3 \u0398 ))  plot ( \u0398 , r , proj = : polar , m = 2 )", 
            "title": "Polar Plots"
        }, 
        {
            "location": "/examples/pyplot/#heatmap-categorical-axes-and-aspect_ratio", 
            "text": "xs   =   [ string ( x , i )   for   i   =   1 : 10 ]  ys   =   [ string ( y , i )   for   i   =   1 : 4 ]  z   =   float (( 1 : 4 )   *   1 : 10 )  heatmap ( xs , ys , z , aspect_ratio = 1 )", 
            "title": "Heatmap, categorical axes, and aspect_ratio"
        }, 
        {
            "location": "/examples/pyplot/#layouts-margins-label-rotation-title-location", 
            "text": "plot ( rand ( 100 , 6 ), layout = @ layout ([ a   b ; c ]), title = [ A   B   C ], title_location = : left , left_margin = [ 20 mm   0 mm ], bottom_margin = 50 px , xrotation = 60 )", 
            "title": "Layouts, margins, label rotation, title location"
        }, 
        {
            "location": "/examples/pyplot/#boxplot-and-violin-series-recipes", 
            "text": "import   RDatasets  singers   =   RDatasets . dataset ( lattice , singer )  violin ( singers ,: VoicePart ,: Height , marker = ( 0.2 ,: blue , stroke ( 0 )))  boxplot! ( singers ,: VoicePart ,: Height , marker = ( 0.3 ,: orange , stroke ( 2 )))     Supported arguments:  annotations ,  arrow ,  aspect_ratio ,  background_color ,  background_color_inside ,  background_color_legend ,  background_color_outside ,  bar_edges ,  bar_width ,  bins ,  clims ,  color_palette ,  colorbar ,  contours ,  fillalpha ,  fillcolor ,  fillrange ,  foreground_color ,  foreground_color_axis ,  foreground_color_border ,  foreground_color_grid ,  foreground_color_legend ,  foreground_color_text ,  grid ,  group ,  guidefont ,  label ,  layout ,  legend ,  legendfont ,  levels ,  linealpha ,  linecolor ,  linestyle ,  linewidth ,  marker_z ,  markeralpha ,  markercolor ,  markershape ,  markersize ,  markerstrokealpha ,  markerstrokecolor ,  markerstrokewidth ,  match_dimensions ,  n ,  nc ,  normalize ,  nr ,  orientation ,  overwrite_figure ,  polar ,  quiver ,  ribbon ,  seriesalpha ,  seriescolor ,  seriestype ,  show ,  size ,  smooth ,  subplot ,  tickfont ,  title ,  weights ,  window_title ,  x ,  xerror ,  xflip ,  xguide ,  xlims ,  xrotation ,  xscale ,  xticks ,  y ,  yerror ,  yflip ,  yguide ,  ylims ,  yrotation ,  yscale ,  yticks ,  z ,  z ,  zflip ,  zguide ,  zlims ,  zrotation ,  zscale ,  zticks  Supported values for linetype:  :bar ,  :contour ,  :contour3d ,  :heatmap ,  :hexbin ,  :histogram ,  :histogram2d ,  :hline ,  :image ,  :line ,  :none ,  :path ,  :path3d ,  :pie ,  :scatter ,  :scatter3d ,  :shape ,  :steppost ,  :steppre ,  :sticks ,  :surface ,  :vline ,  :wireframe  Supported values for linestyle:  :auto ,  :dash ,  :dashdot ,  :dot ,  :solid  Supported values for marker:  :Plots.Shape ,  :auto ,  :cross ,  :diamond ,  :dtriangle ,  :circle ,  :heptagon ,  :hexagon ,  :hline ,  :none ,  :octagon ,  :pentagon ,  :rect ,  :star4 ,  :star5 ,  :star6 ,  :star7 ,  :star8 ,  :utriangle ,  :vline ,  :xcross \n(Automatically generated: 2016-06-10T13:38:20)", 
            "title": "Boxplot and Violin series recipes"
        }, 
        {
            "location": "/examples/gr/", 
            "text": "Initialize\n\n\nusing\n \nPlots\n\n\ngr\n()\n\n\n\n\n\n\nLines\n\n\nA simple line plot of the columns.\n\n\nplot\n(\nPlots\n.\nfakedata\n(\n50\n,\n5\n),\nw\n=\n3\n)\n\n\n\n\n\n\n\n\nFunctions, adding data, and animations\n\n\nPlot multiple functions.  You can also put the function first, or use the form \nplot(f, xmin, xmax)\n where f is a Function or AbstractVector{Function}.\n\n\nGet series data: \nx, y = plt[i]\n.  Set series data: \nplt[i] = (x,y)\n. Add to the series with \npush!\n/\nappend!\n.\n\n\nEasily build animations.  (\nconvert\n or \nffmpeg\n must be available to generate the animation.)  Use command \ngif(anim, filename, fps=15)\n to save the animation.\n\n\np\n \n=\n \nplot\n([\nsin\n,\ncos\n],\nzeros\n(\n0\n),\nleg\n=\nfalse\n)\n\n\nanim\n \n=\n \nAnimation\n()\n\n\nfor\n \nx\n \n=\n \nlinspace\n(\n0\n,\n10\n\u03c0\n,\n100\n)\n\n    \npush!\n(\np\n,\nx\n,\nFloat64\n[\nsin\n(\nx\n),\ncos\n(\nx\n)])\n\n    \nframe\n(\nanim\n)\n\n\nend\n\n\n\n\n\n\n\n\nParametric plots\n\n\nPlot function pair (x(u), y(u)).\n\n\nplot\n(\nsin\n,(\nx\n-\nbegin\n \n            \nsin\n(\n2\nx\n)\n\n        \nend\n),\n0\n,\n2\n\u03c0\n,\nline\n=\n4\n,\nleg\n=\nfalse\n,\nfill\n=\n(\n0\n,:\norange\n))\n\n\n\n\n\n\n\n\nColors\n\n\nAccess predefined palettes (or build your own with the \ncolorscheme\n method).  Line/marker colors are auto-generated from the plot's palette, unless overridden.  Set the \nz\n argument to turn on series gradients.\n\n\ny\n \n=\n \nrand\n(\n100\n)\n\n\nplot\n(\n0\n:\n10\n:\n100\n,\nrand\n(\n11\n,\n4\n),\nlab\n=\nlines\n,\nw\n=\n3\n,\npalette\n=\n:\ngrays\n,\nfill\n=\n(\n0\n,:\nauto\n),\n\u03b1\n=\n0.6\n)\n\n\nscatter!\n(\ny\n,\nzcolor\n=\nabs\n(\ny\n \n-\n \n0.5\n),\nm\n=\n(:\nheat\n,\n0.8\n,\nstroke\n(\n1\n,:\ngreen\n)),\nms\n=\n10\n \n*\n \nabs\n(\ny\n \n-\n \n0.5\n)\n \n+\n \n4\n,\nlab\n=\ngrad\n)\n\n\n\n\n\n\n\n\nGlobal\n\n\nChange the guides/background/limits/ticks.  Convenience args \nxaxis\n and \nyaxis\n allow you to pass a tuple or value which will be mapped to the relevant args automatically.  The \nxaxis\n below will be replaced with \nxlabel\n and \nxlims\n args automatically during the preprocessing step. You can also use shorthand functions: \ntitle!\n, \nxaxis!\n, \nyaxis!\n, \nxlabel!\n, \nylabel!\n, \nxlims!\n, \nylims!\n, \nxticks!\n, \nyticks!\n\n\ny\n \n=\n \nrand\n(\n20\n,\n3\n)\n\n\nplot\n(\ny\n,\nxaxis\n=\n(\nXLABEL\n,(\n-\n5\n,\n30\n),\n0\n:\n2\n:\n20\n,:\nflip\n),\nbackground_color\n=\nRGB\n(\n0.2\n,\n0.2\n,\n0.2\n),\nleg\n=\nfalse\n)\n\n\nhline!\n(\nmean\n(\ny\n,\n1\n)\n \n+\n \nrand\n(\n1\n,\n3\n),\nline\n=\n(\n4\n,:\ndash\n,\n0.6\n,[:\nlightgreen\n \n:\ngreen\n \n:\ndarkgreen\n]))\n\n\nvline!\n([\n5\n,\n10\n])\n\n\ntitle!\n(\nTITLE\n)\n\n\nyaxis!\n(\nYLABEL\n,:\nlog10\n)\n\n\n\n\n\n\n\n\nImages\n\n\nPlot an image.  y-axis is set to flipped\n\n\nimport\n \nImages\n\n\nimg\n \n=\n \nImages\n.\nload\n(\nPkg\n.\ndir\n(\nPlotReferenceImages\n,\nPlots\n,\npyplot\n,\n0.7.0\n,\nref1.png\n))\n\n\nplot\n(\nimg\n)\n\n\n\n\n\n\n\n\nArguments\n\n\nPlot multiple series with different numbers of points.  Mix arguments that apply to all series (marker/markersize) with arguments unique to each series (colors).  Special arguments \nline\n, \nmarker\n, and \nfill\n will automatically figure out what arguments to set (for example, we are setting the \nlinestyle\n, \nlinewidth\n, and \ncolor\n arguments with \nline\n.)  Note that we pass a matrix of colors, and this applies the colors to each series.\n\n\nys\n \n=\n \nVector\n[\nrand\n(\n10\n),\nrand\n(\n20\n)]\n\n\nplot\n(\nys\n,\ncolor\n=\n[:\nblack\n \n:\norange\n],\nline\n=\n(:\ndot\n,\n4\n),\nmarker\n=\n([:\nhex\n \n:\nd\n],\n12\n,\n0.8\n,\nstroke\n(\n3\n,:\ngray\n)))\n\n\n\n\n\n\n\n\nBuild plot in pieces\n\n\nStart with a base plot...\n\n\nplot\n(\nrand\n(\n100\n)\n \n/\n \n3\n,\nreg\n=\ntrue\n,\nfill\n=\n(\n0\n,:\ngreen\n))\n\n\n\n\n\n\n\n\n\n\nand add to it later.\n\n\nscatter!\n(\nrand\n(\n100\n),\nmarkersize\n=\n6\n,\nc\n=\n:\norange\n)\n\n\n\n\n\n\n\n\nHistogram2D\n\n\nhistogram2d\n(\nrandn\n(\n10000\n),\nrandn\n(\n10000\n),\nnbins\n=\n20\n)\n\n\n\n\n\n\n\n\nLine types\n\n\nlinetypes\n \n=\n \n[:\npath\n \n:\nsteppre\n \n:\nsteppost\n \n:\nsticks\n \n:\nscatter\n]\n\n\nn\n \n=\n \nlength\n(\nlinetypes\n)\n\n\nx\n \n=\n \nVector\n[\nsort\n(\nrand\n(\n20\n))\n \nfor\n \ni\n \n=\n \n1\n:\nn\n]\n\n\ny\n \n=\n \nrand\n(\n20\n,\nn\n)\n\n\nplot\n(\nx\n,\ny\n,\nline\n=\n(\nlinetypes\n,\n3\n),\nlab\n=\nmap\n(\nstring\n,\nlinetypes\n),\nms\n=\n15\n)\n\n\n\n\n\n\n\n\nLine styles\n\n\nstyles\n \n=\n \nfilter\n((\ns\n-\nbegin\n \n            \n$\n(\nExpr\n(:\nin\n,\n \n:\ns\n,\n \n:(\nsupported_styles\n())))\n\n        \nend\n),[:\nsolid\n,:\ndash\n,:\ndot\n,:\ndashdot\n,:\ndashdotdot\n])\n\n\nn\n \n=\n \nlength\n(\nstyles\n)\n\n\ny\n \n=\n \ncumsum\n(\nrandn\n(\n20\n,\nn\n),\n1\n)\n\n\nplot\n(\ny\n,\nline\n=\n(\n5\n,\nstyles\n),\nlabel\n=\nmap\n(\nstring\n,\nstyles\n))\n\n\n\n\n\n\n\n\nMarker types\n\n\nmarkers\n \n=\n \nfilter\n((\nm\n-\nbegin\n \n            \n$\n(\nExpr\n(:\nin\n,\n \n:\nm\n,\n \n:(\nsupported_markers\n())))\n\n        \nend\n),\nPlots\n.\n_shape_keys\n)\n\n\nn\n \n=\n \nlength\n(\nmarkers\n)\n\n\nx\n \n=\n \n(\nlinspace\n(\n0\n,\n10\n,\nn\n \n+\n \n2\n))[\n2\n:\nend\n \n-\n \n1\n]\n\n\ny\n \n=\n \nrepmat\n(\nreverse\n(\nx\n)\n,\nn\n,\n1\n)\n\n\nscatter\n(\nx\n,\ny\n,\nm\n=\n(\n8\n,:\nauto\n),\nlab\n=\nmap\n(\nstring\n,\nmarkers\n),\nbg\n=\n:\nlinen\n,\nxlim\n=\n(\n0\n,\n10\n),\nylim\n=\n(\n0\n,\n10\n))\n\n\n\n\n\n\n\n\nBar\n\n\nx is the midpoint of the bar. (todo: allow passing of edges instead of midpoints)\n\n\nbar\n(\nrandn\n(\n99\n))\n\n\n\n\n\n\n\n\nHistogram\n\n\nhistogram\n(\nrandn\n(\n1000\n),\nnbins\n=\n20\n)\n\n\n\n\n\n\n\n\nSubplots\n\n\nUse the \nlayout\n keyword, and optionally the convenient \n@layout\n macro to generate arbitrarily complex subplot layouts.\n\n\nl\n \n=\n \n@\nlayout\n([\na\n{\n0.1\nh\n},\nb\n \n[\nc\n,\nd\n \ne\n]])\n\n\nplot\n(\nrandn\n(\n100\n,\n5\n),\nlayout\n=\nl\n,\nt\n=\n[:\nline\n \n:\nhistogram\n \n:\nscatter\n \n:\nsteppre\n \n:\nbar\n],\nleg\n=\nfalse\n,\nticks\n=\nnothing\n,\nborder\n=\nfalse\n)\n\n\n\n\n\n\n\n\nAdding to subplots\n\n\nNote here the automatic grid layout, as well as the order in which new series are added to the plots.\n\n\nplot\n(\nPlots\n.\nfakedata\n(\n100\n,\n10\n),\nlayout\n=\n4\n,\npalette\n=\n[:\ngrays\n \n:\nblues\n \n:\nheat\n \n:\nlightrainbow\n],\nbg_inside\n=\n[:\norange\n \n:\npink\n \n:\ndarkblue\n \n:\nblack\n])\n\n\n\n\n\n\n\n\n\n\nsrand\n(\n111\n)\n\n\nplot!\n(\nPlots\n.\nfakedata\n(\n100\n,\n10\n))\n\n\n\n\n\n\n\n\nOpen/High/Low/Close\n\n\nCreate an OHLC chart.  Pass in a list of (open,high,low,close) tuples as your \ny\n argument.  This uses recipes to first convert the tuples to OHLC objects, and subsequently create a :path series with the appropriate line segments.\n\n\nn\n \n=\n \n20\n\n\nhgt\n \n=\n \nrand\n(\nn\n)\n \n+\n \n1\n\n\nbot\n \n=\n \nrandn\n(\nn\n)\n\n\nopenpct\n \n=\n \nrand\n(\nn\n)\n\n\nclosepct\n \n=\n \nrand\n(\nn\n)\n\n\ny\n \n=\n \nOHLC\n[(\nopenpct\n[\ni\n]\n \n*\n \nhgt\n[\ni\n]\n \n+\n \nbot\n[\ni\n],\nbot\n[\ni\n]\n \n+\n \nhgt\n[\ni\n],\nbot\n[\ni\n],\nclosepct\n[\ni\n]\n \n*\n \nhgt\n[\ni\n]\n \n+\n \nbot\n[\ni\n])\n \nfor\n \ni\n \n=\n \n1\n:\nn\n]\n\n\nohlc\n(\ny\n)\n\n\n\n\n\n\n\n\nAnnotations\n\n\nThe \nannotations\n keyword is used for text annotations in data-coordinates.  Pass in a tuple (x,y,text) or a vector of annotations.  \nannotate!(ann)\n is shorthand for \nplot!(; annotation=ann)\n.  Series annotations are used for annotating individual data points.  They require only the annotation... x/y values are computed.  A \nPlotText\n object can be build with the method \ntext(string, attr...)\n, which wraps font and color attributes.\n\n\ny\n \n=\n \nrand\n(\n10\n)\n\n\nplot\n(\ny\n,\nannotations\n=\n(\n3\n,\ny\n[\n3\n],\ntext\n(\nthis is #3\n,:\nleft\n)),\nleg\n=\nfalse\n)\n\n\nannotate!\n([(\n5\n,\ny\n[\n5\n],\ntext\n(\nthis is #5\n,\n16\n,:\nred\n,:\ncenter\n)),(\n10\n,\ny\n[\n10\n],\ntext\n(\nthis is #10\n,:\nright\n,\n20\n,\ncourier\n))])\n\n\nscatter!\n(\nlinspace\n(\n2\n,\n8\n,\n6\n),\nrand\n(\n6\n),\nmarker\n=\n(\n50\n,\n0.2\n,:\norange\n),\nseries_annotations\n=\n[\nseries\n,\nannotations\n,\nmap\n,\nto\n,\nseries\n,\ntext\n(\ndata\n,:\ngreen\n)])\n\n\n\n\n\n\n\n\nCustom Markers\n\n\nA \nPlots.Shape\n is a light wrapper around vertices of a polygon.  For supported backends, pass arbitrary polygons as the marker shapes.  Note: The center is (0,0) and the size is expected to be rougly the area of the unit circle.\n\n\nverts\n \n=\n \n[(\n-\n1.0\n,\n1.0\n),(\n-\n1.28\n,\n0.6\n),(\n-\n0.2\n,\n-\n1.4\n),(\n0.2\n,\n-\n1.4\n),(\n1.28\n,\n0.6\n),(\n1.0\n,\n1.0\n),(\n-\n1.0\n,\n1.0\n),(\n-\n0.2\n,\n-\n0.6\n),(\n0.0\n,\n-\n0.2\n),(\n-\n0.4\n,\n0.6\n),(\n1.28\n,\n0.6\n),(\n0.2\n,\n-\n1.4\n),(\n-\n0.2\n,\n-\n1.4\n),(\n0.6\n,\n0.2\n),(\n-\n0.2\n,\n0.2\n),(\n0.0\n,\n-\n0.2\n),(\n0.2\n,\n0.2\n),(\n-\n0.2\n,\n-\n0.6\n)]\n\n\nx\n \n=\n \n0.1\n:\n0.2\n:\n0.9\n\n\ny\n \n=\n \n0.7\n \n*\n \nrand\n(\n5\n)\n \n+\n \n0.15\n\n\nplot\n(\nx\n,\ny\n,\nline\n=\n(\n3\n,:\ndash\n,:\nlightblue\n),\nmarker\n=\n(\nShape\n(\nverts\n),\n30\n,\nRGBA\n(\n0\n,\n0\n,\n0\n,\n0.2\n)),\nbg\n=\n:\npink\n,\nfg\n=\n:\ndarkblue\n,\nxlim\n=\n(\n0\n,\n1\n),\nylim\n=\n(\n0\n,\n1\n),\nleg\n=\nfalse\n)\n\n\n\n\n\n\n\n\nContours\n\n\nAny value for fill works here.  We first build a filled contour from a function, then an unfilled contour from a matrix.\n\n\nx\n \n=\n \n1\n:\n0.5\n:\n20\n\n\ny\n \n=\n \n1\n:\n0.5\n:\n10\n\n\nf\n(\nx\n,\ny\n)\n \n=\n \nbegin\n \n        \n(\n3\nx\n \n+\n \ny\n \n^\n \n2\n)\n \n*\n \nabs\n(\nsin\n(\nx\n)\n \n+\n \ncos\n(\ny\n))\n\n    \nend\n\n\nX\n \n=\n \nrepmat\n(\nx\n,\nlength\n(\ny\n),\n1\n)\n\n\nY\n \n=\n \nrepmat\n(\ny\n,\n1\n,\nlength\n(\nx\n))\n\n\nZ\n \n=\n \nmap\n(\nf\n,\nX\n,\nY\n)\n\n\np1\n \n=\n \ncontour\n(\nx\n,\ny\n,\nf\n,\nfill\n=\ntrue\n)\n\n\np2\n \n=\n \ncontour\n(\nx\n,\ny\n,\nZ\n)\n\n\nplot\n(\np1\n,\np2\n)\n\n\n\n\n\n\n\n\nPie\n\n\nx\n \n=\n \n[\nNerds\n,\nHackers\n,\nScientists\n]\n\n\ny\n \n=\n \n[\n0.4\n,\n0.35\n,\n0.25\n]\n\n\npie\n(\nx\n,\ny\n,\ntitle\n=\nThe Julia Community\n,\nl\n=\n0.5\n)\n\n\n\n\n\n\n\n\n3D\n\n\nn\n \n=\n \n100\n\n\nts\n \n=\n \nlinspace\n(\n0\n,\n8\n\u03c0\n,\nn\n)\n\n\nx\n \n=\n \nts\n \n.*\n \nmap\n(\ncos\n,\nts\n)\n\n\ny\n \n=\n \n(\n0.1\nts\n)\n \n.*\n \nmap\n(\nsin\n,\nts\n)\n\n\nz\n \n=\n \n1\n:\nn\n\n\nplot\n(\nx\n,\ny\n,\nz\n,\nzcolor\n=\nreverse\n(\nz\n),\nm\n=\n(\n10\n,\n0.8\n,:\nblues\n,\nstroke\n(\n0\n)),\nleg\n=\nfalse\n,\ncbar\n=\ntrue\n,\nw\n=\n5\n)\n\n\nplot!\n(\nzeros\n(\nn\n),\nzeros\n(\nn\n),\n1\n:\nn\n,\nw\n=\n10\n)\n\n\n\n\n\n\n\n\nDataFrames\n\n\nPlot using DataFrame column symbols.\n\n\nimport\n \nRDatasets\n\n\niris\n \n=\n \nRDatasets\n.\ndataset\n(\ndatasets\n,\niris\n)\n\n\nscatter\n(\niris\n,:\nSepalLength\n,:\nSepalWidth\n,\ngroup\n=\n:\nSpecies\n,\ntitle\n=\nMy awesome plot\n,\nxlabel\n=\nLength\n,\nylabel\n=\nWidth\n,\nmarker\n=\n(\n0.5\n,[:\n+\n \n:\nh\n \n:\nstar7\n],\n12\n),\nbg\n=\nRGB\n(\n0.2\n,\n0.2\n,\n0.2\n))\n\n\n\n\n\n\n\n\nGroups and Subplots\n\n\ngroup\n \n=\n \nrand\n(\nmap\n((\ni\n-\nbegin\n \n                    \ngroup \n$(i)\n\n                \nend\n),\n1\n:\n4\n),\n100\n)\n\n\nplot\n(\nrand\n(\n100\n),\nlayout\n=\n@\nlayout\n([\na\n \nb\n;\nc\n]),\ngroup\n=\ngroup\n,\nlinetype\n=\n[:\nbar\n \n:\nscatter\n \n:\nsteppre\n])\n\n\n\n\n\n\n\n\nPolar Plots\n\n\n\u0398\n \n=\n \nlinspace\n(\n0\n,\n1.5\n\u03c0\n,\n100\n)\n\n\nr\n \n=\n \nabs\n(\n0.1\n \n*\n \nrandn\n(\n100\n)\n \n+\n \nsin\n(\n3\n\u0398\n))\n\n\nplot\n(\n\u0398\n,\nr\n,\nproj\n=\n:\npolar\n,\nm\n=\n2\n)\n\n\n\n\n\n\n\n\nHeatmap, categorical axes, and aspect_ratio\n\n\nxs\n \n=\n \n[\nstring\n(\nx\n,\ni\n)\n \nfor\n \ni\n \n=\n \n1\n:\n10\n]\n\n\nys\n \n=\n \n[\nstring\n(\ny\n,\ni\n)\n \nfor\n \ni\n \n=\n \n1\n:\n4\n]\n\n\nz\n \n=\n \nfloat\n((\n1\n:\n4\n)\n \n*\n \n1\n:\n10\n)\n\n\nheatmap\n(\nxs\n,\nys\n,\nz\n,\naspect_ratio\n=\n1\n)\n\n\n\n\n\n\n\n\nLayouts, margins, label rotation, title location\n\n\nplot\n(\nrand\n(\n100\n,\n6\n),\nlayout\n=\n@\nlayout\n([\na\n \nb\n;\nc\n]),\ntitle\n=\n[\nA\n \nB\n \nC\n],\ntitle_location\n=\n:\nleft\n,\nleft_margin\n=\n[\n20\nmm\n \n0\nmm\n],\nbottom_margin\n=\n50\npx\n,\nxrotation\n=\n60\n)\n\n\n\n\n\n\n\n\nBoxplot and Violin series recipes\n\n\nimport\n \nRDatasets\n\n\nsingers\n \n=\n \nRDatasets\n.\ndataset\n(\nlattice\n,\nsinger\n)\n\n\nviolin\n(\nsingers\n,:\nVoicePart\n,:\nHeight\n,\nline\n=\n0\n,\nfill\n=\n(\n0.2\n,:\nblue\n))\n\n\nboxplot!\n(\nsingers\n,:\nVoicePart\n,:\nHeight\n,\nline\n=\n(\n2\n,:\nblack\n),\nfill\n=\n(\n0.3\n,:\norange\n))\n\n\n\n\n\n\n\n\n\n\nSupported arguments: \nannotations\n, \naspect_ratio\n, \nbackground_color\n, \nbackground_color_inside\n, \nbackground_color_legend\n, \nbackground_color_outside\n, \nbackground_color_subplot\n, \nbins\n, \nbottom_margin\n, \ncolor_palette\n, \ncolorbar\n, \ndiscrete_values\n, \nfillalpha\n, \nfillcolor\n, \nfillrange\n, \nflip\n, \nforeground_color\n, \nforeground_color_axis\n, \nforeground_color_border\n, \nforeground_color_grid\n, \nforeground_color_legend\n, \nforeground_color_subplot\n, \nforeground_color_text\n, \ngrid\n, \ngroup\n, \nguide\n, \nguidefont\n, \nhtml_output_format\n, \ninset_subplots\n, \nlabel\n, \nlayout\n, \nlayout\n, \nleft_margin\n, \nlegend\n, \nlegendfont\n, \nlevels\n, \nlims\n, \nlinealpha\n, \nlinecolor\n, \nlinestyle\n, \nlinewidth\n, \nlink\n, \nmargin\n, \nmarker_z\n, \nmarkeralpha\n, \nmarkercolor\n, \nmarkershape\n, \nmarkersize\n, \nmarkerstrokealpha\n, \nmarkerstrokecolor\n, \nmarkerstrokewidth\n, \nnormalize\n, \norientation\n, \noverwrite_figure\n, \npolar\n, \nprimary\n, \nprojection\n, \nquiver\n, \nribbon\n, \nright_margin\n, \nscale\n, \nseries_annotations\n, \nseriesalpha\n, \nseriesalpha\n, \nseriescolor\n, \nseriescolor\n, \nseriestype\n, \nshow\n, \nsize\n, \nsmooth\n, \nsubplot\n, \nsubplot_index\n, \ntickfont\n, \nticks\n, \ntitle\n, \ntop_margin\n, \nweights\n, \nwindow_title\n, \nx\n, \nxdiscrete_values\n, \nxerror\n, \nxflip\n, \nxforeground_color_axis\n, \nxforeground_color_border\n, \nxforeground_color_text\n, \nxguide\n, \nxguidefont\n, \nxlims\n, \nxlink\n, \nxscale\n, \nxtickfont\n, \nxticks\n, \ny\n, \nydiscrete_values\n, \nyerror\n, \nyflip\n, \nyforeground_color_axis\n, \nyforeground_color_border\n, \nyforeground_color_text\n, \nyguide\n, \nyguidefont\n, \nylims\n, \nylink\n, \nyscale\n, \nytickfont\n, \nyticks\n, \nz\n, \nzdiscrete_values\n, \nzflip\n, \nzforeground_color_axis\n, \nzforeground_color_border\n, \nzforeground_color_text\n, \nzguide\n, \nzguidefont\n, \nzlims\n, \nzlink\n, \nzscale\n, \nztickfont\n, \nzticks\n\n\nSupported values for linetype: \n:contour\n, \n:heatmap\n, \n:image\n, \n:path\n, \n:path3d\n, \n:pie\n, \n:scatter\n, \n:scatter3d\n, \n:shape\n, \n:surface\n, \n:wireframe\n\n\nSupported values for linestyle: \n:auto\n, \n:dash\n, \n:dashdot\n, \n:dashdotdot\n, \n:dot\n, \n:solid\n\n\nSupported values for marker: \n:Plots.Shape\n, \n:auto\n, \n:circle\n, \n:cross\n, \n:diamond\n, \n:dtriangle\n, \n:heptagon\n, \n:hexagon\n, \n:hline\n, \n:none\n, \n:octagon\n, \n:pentagon\n, \n:rect\n, \n:star4\n, \n:star5\n, \n:star6\n, \n:star7\n, \n:star8\n, \n:utriangle\n, \n:vline\n, \n:xcross\n\n(Automatically generated: 2016-06-29T16:16:28)", 
            "title": "GR"
        }, 
        {
            "location": "/examples/gr/#initialize", 
            "text": "using   Plots  gr ()", 
            "title": "Initialize"
        }, 
        {
            "location": "/examples/gr/#lines", 
            "text": "A simple line plot of the columns.  plot ( Plots . fakedata ( 50 , 5 ), w = 3 )", 
            "title": "Lines"
        }, 
        {
            "location": "/examples/gr/#functions-adding-data-and-animations", 
            "text": "Plot multiple functions.  You can also put the function first, or use the form  plot(f, xmin, xmax)  where f is a Function or AbstractVector{Function}.  Get series data:  x, y = plt[i] .  Set series data:  plt[i] = (x,y) . Add to the series with  push! / append! .  Easily build animations.  ( convert  or  ffmpeg  must be available to generate the animation.)  Use command  gif(anim, filename, fps=15)  to save the animation.  p   =   plot ([ sin , cos ], zeros ( 0 ), leg = false )  anim   =   Animation ()  for   x   =   linspace ( 0 , 10 \u03c0 , 100 ) \n     push! ( p , x , Float64 [ sin ( x ), cos ( x )]) \n     frame ( anim )  end", 
            "title": "Functions, adding data, and animations"
        }, 
        {
            "location": "/examples/gr/#parametric-plots", 
            "text": "Plot function pair (x(u), y(u)).  plot ( sin ,( x - begin  \n             sin ( 2 x ) \n         end ), 0 , 2 \u03c0 , line = 4 , leg = false , fill = ( 0 ,: orange ))", 
            "title": "Parametric plots"
        }, 
        {
            "location": "/examples/gr/#colors", 
            "text": "Access predefined palettes (or build your own with the  colorscheme  method).  Line/marker colors are auto-generated from the plot's palette, unless overridden.  Set the  z  argument to turn on series gradients.  y   =   rand ( 100 )  plot ( 0 : 10 : 100 , rand ( 11 , 4 ), lab = lines , w = 3 , palette = : grays , fill = ( 0 ,: auto ), \u03b1 = 0.6 )  scatter! ( y , zcolor = abs ( y   -   0.5 ), m = (: heat , 0.8 , stroke ( 1 ,: green )), ms = 10   *   abs ( y   -   0.5 )   +   4 , lab = grad )", 
            "title": "Colors"
        }, 
        {
            "location": "/examples/gr/#global", 
            "text": "Change the guides/background/limits/ticks.  Convenience args  xaxis  and  yaxis  allow you to pass a tuple or value which will be mapped to the relevant args automatically.  The  xaxis  below will be replaced with  xlabel  and  xlims  args automatically during the preprocessing step. You can also use shorthand functions:  title! ,  xaxis! ,  yaxis! ,  xlabel! ,  ylabel! ,  xlims! ,  ylims! ,  xticks! ,  yticks!  y   =   rand ( 20 , 3 )  plot ( y , xaxis = ( XLABEL ,( - 5 , 30 ), 0 : 2 : 20 ,: flip ), background_color = RGB ( 0.2 , 0.2 , 0.2 ), leg = false )  hline! ( mean ( y , 1 )   +   rand ( 1 , 3 ), line = ( 4 ,: dash , 0.6 ,[: lightgreen   : green   : darkgreen ]))  vline! ([ 5 , 10 ])  title! ( TITLE )  yaxis! ( YLABEL ,: log10 )", 
            "title": "Global"
        }, 
        {
            "location": "/examples/gr/#images", 
            "text": "Plot an image.  y-axis is set to flipped  import   Images  img   =   Images . load ( Pkg . dir ( PlotReferenceImages , Plots , pyplot , 0.7.0 , ref1.png ))  plot ( img )", 
            "title": "Images"
        }, 
        {
            "location": "/examples/gr/#arguments", 
            "text": "Plot multiple series with different numbers of points.  Mix arguments that apply to all series (marker/markersize) with arguments unique to each series (colors).  Special arguments  line ,  marker , and  fill  will automatically figure out what arguments to set (for example, we are setting the  linestyle ,  linewidth , and  color  arguments with  line .)  Note that we pass a matrix of colors, and this applies the colors to each series.  ys   =   Vector [ rand ( 10 ), rand ( 20 )]  plot ( ys , color = [: black   : orange ], line = (: dot , 4 ), marker = ([: hex   : d ], 12 , 0.8 , stroke ( 3 ,: gray )))", 
            "title": "Arguments"
        }, 
        {
            "location": "/examples/gr/#build-plot-in-pieces", 
            "text": "Start with a base plot...  plot ( rand ( 100 )   /   3 , reg = true , fill = ( 0 ,: green ))", 
            "title": "Build plot in pieces"
        }, 
        {
            "location": "/examples/gr/#histogram2d", 
            "text": "histogram2d ( randn ( 10000 ), randn ( 10000 ), nbins = 20 )", 
            "title": "Histogram2D"
        }, 
        {
            "location": "/examples/gr/#line-types", 
            "text": "linetypes   =   [: path   : steppre   : steppost   : sticks   : scatter ]  n   =   length ( linetypes )  x   =   Vector [ sort ( rand ( 20 ))   for   i   =   1 : n ]  y   =   rand ( 20 , n )  plot ( x , y , line = ( linetypes , 3 ), lab = map ( string , linetypes ), ms = 15 )", 
            "title": "Line types"
        }, 
        {
            "location": "/examples/gr/#line-styles", 
            "text": "styles   =   filter (( s - begin  \n             $ ( Expr (: in ,   : s ,   :( supported_styles ()))) \n         end ),[: solid ,: dash ,: dot ,: dashdot ,: dashdotdot ])  n   =   length ( styles )  y   =   cumsum ( randn ( 20 , n ), 1 )  plot ( y , line = ( 5 , styles ), label = map ( string , styles ))", 
            "title": "Line styles"
        }, 
        {
            "location": "/examples/gr/#marker-types", 
            "text": "markers   =   filter (( m - begin  \n             $ ( Expr (: in ,   : m ,   :( supported_markers ()))) \n         end ), Plots . _shape_keys )  n   =   length ( markers )  x   =   ( linspace ( 0 , 10 , n   +   2 ))[ 2 : end   -   1 ]  y   =   repmat ( reverse ( x ) , n , 1 )  scatter ( x , y , m = ( 8 ,: auto ), lab = map ( string , markers ), bg = : linen , xlim = ( 0 , 10 ), ylim = ( 0 , 10 ))", 
            "title": "Marker types"
        }, 
        {
            "location": "/examples/gr/#bar", 
            "text": "x is the midpoint of the bar. (todo: allow passing of edges instead of midpoints)  bar ( randn ( 99 ))", 
            "title": "Bar"
        }, 
        {
            "location": "/examples/gr/#histogram", 
            "text": "histogram ( randn ( 1000 ), nbins = 20 )", 
            "title": "Histogram"
        }, 
        {
            "location": "/examples/gr/#subplots", 
            "text": "Use the  layout  keyword, and optionally the convenient  @layout  macro to generate arbitrarily complex subplot layouts.  l   =   @ layout ([ a { 0.1 h }, b   [ c , d   e ]])  plot ( randn ( 100 , 5 ), layout = l , t = [: line   : histogram   : scatter   : steppre   : bar ], leg = false , ticks = nothing , border = false )", 
            "title": "Subplots"
        }, 
        {
            "location": "/examples/gr/#adding-to-subplots", 
            "text": "Note here the automatic grid layout, as well as the order in which new series are added to the plots.  plot ( Plots . fakedata ( 100 , 10 ), layout = 4 , palette = [: grays   : blues   : heat   : lightrainbow ], bg_inside = [: orange   : pink   : darkblue   : black ])", 
            "title": "Adding to subplots"
        }, 
        {
            "location": "/examples/gr/#openhighlowclose", 
            "text": "Create an OHLC chart.  Pass in a list of (open,high,low,close) tuples as your  y  argument.  This uses recipes to first convert the tuples to OHLC objects, and subsequently create a :path series with the appropriate line segments.  n   =   20  hgt   =   rand ( n )   +   1  bot   =   randn ( n )  openpct   =   rand ( n )  closepct   =   rand ( n )  y   =   OHLC [( openpct [ i ]   *   hgt [ i ]   +   bot [ i ], bot [ i ]   +   hgt [ i ], bot [ i ], closepct [ i ]   *   hgt [ i ]   +   bot [ i ])   for   i   =   1 : n ]  ohlc ( y )", 
            "title": "Open/High/Low/Close"
        }, 
        {
            "location": "/examples/gr/#annotations", 
            "text": "The  annotations  keyword is used for text annotations in data-coordinates.  Pass in a tuple (x,y,text) or a vector of annotations.   annotate!(ann)  is shorthand for  plot!(; annotation=ann) .  Series annotations are used for annotating individual data points.  They require only the annotation... x/y values are computed.  A  PlotText  object can be build with the method  text(string, attr...) , which wraps font and color attributes.  y   =   rand ( 10 )  plot ( y , annotations = ( 3 , y [ 3 ], text ( this is #3 ,: left )), leg = false )  annotate! ([( 5 , y [ 5 ], text ( this is #5 , 16 ,: red ,: center )),( 10 , y [ 10 ], text ( this is #10 ,: right , 20 , courier ))])  scatter! ( linspace ( 2 , 8 , 6 ), rand ( 6 ), marker = ( 50 , 0.2 ,: orange ), series_annotations = [ series , annotations , map , to , series , text ( data ,: green )])", 
            "title": "Annotations"
        }, 
        {
            "location": "/examples/gr/#custom-markers", 
            "text": "A  Plots.Shape  is a light wrapper around vertices of a polygon.  For supported backends, pass arbitrary polygons as the marker shapes.  Note: The center is (0,0) and the size is expected to be rougly the area of the unit circle.  verts   =   [( - 1.0 , 1.0 ),( - 1.28 , 0.6 ),( - 0.2 , - 1.4 ),( 0.2 , - 1.4 ),( 1.28 , 0.6 ),( 1.0 , 1.0 ),( - 1.0 , 1.0 ),( - 0.2 , - 0.6 ),( 0.0 , - 0.2 ),( - 0.4 , 0.6 ),( 1.28 , 0.6 ),( 0.2 , - 1.4 ),( - 0.2 , - 1.4 ),( 0.6 , 0.2 ),( - 0.2 , 0.2 ),( 0.0 , - 0.2 ),( 0.2 , 0.2 ),( - 0.2 , - 0.6 )]  x   =   0.1 : 0.2 : 0.9  y   =   0.7   *   rand ( 5 )   +   0.15  plot ( x , y , line = ( 3 ,: dash ,: lightblue ), marker = ( Shape ( verts ), 30 , RGBA ( 0 , 0 , 0 , 0.2 )), bg = : pink , fg = : darkblue , xlim = ( 0 , 1 ), ylim = ( 0 , 1 ), leg = false )", 
            "title": "Custom Markers"
        }, 
        {
            "location": "/examples/gr/#contours", 
            "text": "Any value for fill works here.  We first build a filled contour from a function, then an unfilled contour from a matrix.  x   =   1 : 0.5 : 20  y   =   1 : 0.5 : 10  f ( x , y )   =   begin  \n         ( 3 x   +   y   ^   2 )   *   abs ( sin ( x )   +   cos ( y )) \n     end  X   =   repmat ( x , length ( y ), 1 )  Y   =   repmat ( y , 1 , length ( x ))  Z   =   map ( f , X , Y )  p1   =   contour ( x , y , f , fill = true )  p2   =   contour ( x , y , Z )  plot ( p1 , p2 )", 
            "title": "Contours"
        }, 
        {
            "location": "/examples/gr/#pie", 
            "text": "x   =   [ Nerds , Hackers , Scientists ]  y   =   [ 0.4 , 0.35 , 0.25 ]  pie ( x , y , title = The Julia Community , l = 0.5 )", 
            "title": "Pie"
        }, 
        {
            "location": "/examples/gr/#3d", 
            "text": "n   =   100  ts   =   linspace ( 0 , 8 \u03c0 , n )  x   =   ts   .*   map ( cos , ts )  y   =   ( 0.1 ts )   .*   map ( sin , ts )  z   =   1 : n  plot ( x , y , z , zcolor = reverse ( z ), m = ( 10 , 0.8 ,: blues , stroke ( 0 )), leg = false , cbar = true , w = 5 )  plot! ( zeros ( n ), zeros ( n ), 1 : n , w = 10 )", 
            "title": "3D"
        }, 
        {
            "location": "/examples/gr/#dataframes", 
            "text": "Plot using DataFrame column symbols.  import   RDatasets  iris   =   RDatasets . dataset ( datasets , iris )  scatter ( iris ,: SepalLength ,: SepalWidth , group = : Species , title = My awesome plot , xlabel = Length , ylabel = Width , marker = ( 0.5 ,[: +   : h   : star7 ], 12 ), bg = RGB ( 0.2 , 0.2 , 0.2 ))", 
            "title": "DataFrames"
        }, 
        {
            "location": "/examples/gr/#groups-and-subplots", 
            "text": "group   =   rand ( map (( i - begin  \n                     group  $(i) \n                 end ), 1 : 4 ), 100 )  plot ( rand ( 100 ), layout = @ layout ([ a   b ; c ]), group = group , linetype = [: bar   : scatter   : steppre ])", 
            "title": "Groups and Subplots"
        }, 
        {
            "location": "/examples/gr/#polar-plots", 
            "text": "\u0398   =   linspace ( 0 , 1.5 \u03c0 , 100 )  r   =   abs ( 0.1   *   randn ( 100 )   +   sin ( 3 \u0398 ))  plot ( \u0398 , r , proj = : polar , m = 2 )", 
            "title": "Polar Plots"
        }, 
        {
            "location": "/examples/gr/#heatmap-categorical-axes-and-aspect_ratio", 
            "text": "xs   =   [ string ( x , i )   for   i   =   1 : 10 ]  ys   =   [ string ( y , i )   for   i   =   1 : 4 ]  z   =   float (( 1 : 4 )   *   1 : 10 )  heatmap ( xs , ys , z , aspect_ratio = 1 )", 
            "title": "Heatmap, categorical axes, and aspect_ratio"
        }, 
        {
            "location": "/examples/gr/#layouts-margins-label-rotation-title-location", 
            "text": "plot ( rand ( 100 , 6 ), layout = @ layout ([ a   b ; c ]), title = [ A   B   C ], title_location = : left , left_margin = [ 20 mm   0 mm ], bottom_margin = 50 px , xrotation = 60 )", 
            "title": "Layouts, margins, label rotation, title location"
        }, 
        {
            "location": "/examples/gr/#boxplot-and-violin-series-recipes", 
            "text": "import   RDatasets  singers   =   RDatasets . dataset ( lattice , singer )  violin ( singers ,: VoicePart ,: Height , line = 0 , fill = ( 0.2 ,: blue ))  boxplot! ( singers ,: VoicePart ,: Height , line = ( 2 ,: black ), fill = ( 0.3 ,: orange ))     Supported arguments:  annotations ,  aspect_ratio ,  background_color ,  background_color_inside ,  background_color_legend ,  background_color_outside ,  background_color_subplot ,  bins ,  bottom_margin ,  color_palette ,  colorbar ,  discrete_values ,  fillalpha ,  fillcolor ,  fillrange ,  flip ,  foreground_color ,  foreground_color_axis ,  foreground_color_border ,  foreground_color_grid ,  foreground_color_legend ,  foreground_color_subplot ,  foreground_color_text ,  grid ,  group ,  guide ,  guidefont ,  html_output_format ,  inset_subplots ,  label ,  layout ,  layout ,  left_margin ,  legend ,  legendfont ,  levels ,  lims ,  linealpha ,  linecolor ,  linestyle ,  linewidth ,  link ,  margin ,  marker_z ,  markeralpha ,  markercolor ,  markershape ,  markersize ,  markerstrokealpha ,  markerstrokecolor ,  markerstrokewidth ,  normalize ,  orientation ,  overwrite_figure ,  polar ,  primary ,  projection ,  quiver ,  ribbon ,  right_margin ,  scale ,  series_annotations ,  seriesalpha ,  seriesalpha ,  seriescolor ,  seriescolor ,  seriestype ,  show ,  size ,  smooth ,  subplot ,  subplot_index ,  tickfont ,  ticks ,  title ,  top_margin ,  weights ,  window_title ,  x ,  xdiscrete_values ,  xerror ,  xflip ,  xforeground_color_axis ,  xforeground_color_border ,  xforeground_color_text ,  xguide ,  xguidefont ,  xlims ,  xlink ,  xscale ,  xtickfont ,  xticks ,  y ,  ydiscrete_values ,  yerror ,  yflip ,  yforeground_color_axis ,  yforeground_color_border ,  yforeground_color_text ,  yguide ,  yguidefont ,  ylims ,  ylink ,  yscale ,  ytickfont ,  yticks ,  z ,  zdiscrete_values ,  zflip ,  zforeground_color_axis ,  zforeground_color_border ,  zforeground_color_text ,  zguide ,  zguidefont ,  zlims ,  zlink ,  zscale ,  ztickfont ,  zticks  Supported values for linetype:  :contour ,  :heatmap ,  :image ,  :path ,  :path3d ,  :pie ,  :scatter ,  :scatter3d ,  :shape ,  :surface ,  :wireframe  Supported values for linestyle:  :auto ,  :dash ,  :dashdot ,  :dashdotdot ,  :dot ,  :solid  Supported values for marker:  :Plots.Shape ,  :auto ,  :circle ,  :cross ,  :diamond ,  :dtriangle ,  :heptagon ,  :hexagon ,  :hline ,  :none ,  :octagon ,  :pentagon ,  :rect ,  :star4 ,  :star5 ,  :star6 ,  :star7 ,  :star8 ,  :utriangle ,  :vline ,  :xcross \n(Automatically generated: 2016-06-29T16:16:28)", 
            "title": "Boxplot and Violin series recipes"
        }, 
        {
            "location": "/examples/plotlyjs/", 
            "text": "Initialize\n\n\nusing\n \nPlots\n\n\nplotlyjs\n()\n\n\n\n\n\n\nLines\n\n\nA simple line plot of the columns.\n\n\nplot\n(\nPlots\n.\nfakedata\n(\n50\n,\n5\n),\nw\n=\n3\n)\n\n\n\n\n\n\n\n\nFunctions, adding data, and animations\n\n\nPlot multiple functions.  You can also put the function first, or use the form \nplot(f, xmin, xmax)\n where f is a Function or AbstractVector{Function}.\n\n\nGet series data: \nx, y = plt[i]\n.  Set series data: \nplt[i] = (x,y)\n. Add to the series with \npush!\n/\nappend!\n.\n\n\nEasily build animations.  (\nconvert\n or \nffmpeg\n must be available to generate the animation.)  Use command \ngif(anim, filename, fps=15)\n to save the animation.\n\n\np\n \n=\n \nplot\n([\nsin\n,\ncos\n],\nzeros\n(\n0\n),\nleg\n=\nfalse\n)\n\n\nanim\n \n=\n \nAnimation\n()\n\n\nfor\n \nx\n \n=\n \nlinspace\n(\n0\n,\n10\n\u03c0\n,\n100\n)\n\n    \npush!\n(\np\n,\nx\n,\nFloat64\n[\nsin\n(\nx\n),\ncos\n(\nx\n)])\n\n    \nframe\n(\nanim\n)\n\n\nend\n\n\n\n\n\n\n\n\nParametric plots\n\n\nPlot function pair (x(u), y(u)).\n\n\nplot\n(\nsin\n,(\nx\n-\nbegin\n \n            \nsin\n(\n2\nx\n)\n\n        \nend\n),\n0\n,\n2\n\u03c0\n,\nline\n=\n4\n,\nleg\n=\nfalse\n,\nfill\n=\n(\n0\n,:\norange\n))\n\n\n\n\n\n\n\n\nColors\n\n\nAccess predefined palettes (or build your own with the \ncolorscheme\n method).  Line/marker colors are auto-generated from the plot's palette, unless overridden.  Set the \nz\n argument to turn on series gradients.\n\n\ny\n \n=\n \nrand\n(\n100\n)\n\n\nplot\n(\n0\n:\n10\n:\n100\n,\nrand\n(\n11\n,\n4\n),\nlab\n=\nlines\n,\nw\n=\n3\n,\npalette\n=\n:\ngrays\n,\nfill\n=\n(\n0\n,:\nauto\n),\n\u03b1\n=\n0.6\n)\n\n\nscatter!\n(\ny\n,\nzcolor\n=\nabs\n(\ny\n \n-\n \n0.5\n),\nm\n=\n(:\nheat\n,\n0.8\n,\nstroke\n(\n1\n,:\ngreen\n)),\nms\n=\n10\n \n*\n \nabs\n(\ny\n \n-\n \n0.5\n)\n \n+\n \n4\n,\nlab\n=\ngrad\n)\n\n\n\n\n\n\n\n\nGlobal\n\n\nChange the guides/background/limits/ticks.  Convenience args \nxaxis\n and \nyaxis\n allow you to pass a tuple or value which will be mapped to the relevant args automatically.  The \nxaxis\n below will be replaced with \nxlabel\n and \nxlims\n args automatically during the preprocessing step. You can also use shorthand functions: \ntitle!\n, \nxaxis!\n, \nyaxis!\n, \nxlabel!\n, \nylabel!\n, \nxlims!\n, \nylims!\n, \nxticks!\n, \nyticks!\n\n\ny\n \n=\n \nrand\n(\n20\n,\n3\n)\n\n\nplot\n(\ny\n,\nxaxis\n=\n(\nXLABEL\n,(\n-\n5\n,\n30\n),\n0\n:\n2\n:\n20\n,:\nflip\n),\nbackground_color\n=\nRGB\n(\n0.2\n,\n0.2\n,\n0.2\n),\nleg\n=\nfalse\n)\n\n\nhline!\n(\nmean\n(\ny\n,\n1\n)\n \n+\n \nrand\n(\n1\n,\n3\n),\nline\n=\n(\n4\n,:\ndash\n,\n0.6\n,[:\nlightgreen\n \n:\ngreen\n \n:\ndarkgreen\n]))\n\n\nvline!\n([\n5\n,\n10\n])\n\n\ntitle!\n(\nTITLE\n)\n\n\nyaxis!\n(\nYLABEL\n,:\nlog10\n)\n\n\n\n\n\n\n\n\nArguments\n\n\nPlot multiple series with different numbers of points.  Mix arguments that apply to all series (marker/markersize) with arguments unique to each series (colors).  Special arguments \nline\n, \nmarker\n, and \nfill\n will automatically figure out what arguments to set (for example, we are setting the \nlinestyle\n, \nlinewidth\n, and \ncolor\n arguments with \nline\n.)  Note that we pass a matrix of colors, and this applies the colors to each series.\n\n\nys\n \n=\n \nVector\n[\nrand\n(\n10\n),\nrand\n(\n20\n)]\n\n\nplot\n(\nys\n,\ncolor\n=\n[:\nblack\n \n:\norange\n],\nline\n=\n(:\ndot\n,\n4\n),\nmarker\n=\n([:\nhex\n \n:\nd\n],\n12\n,\n0.8\n,\nstroke\n(\n3\n,:\ngray\n)))\n\n\n\n\n\n\n\n\nBuild plot in pieces\n\n\nStart with a base plot...\n\n\nplot\n(\nrand\n(\n100\n)\n \n/\n \n3\n,\nreg\n=\ntrue\n,\nfill\n=\n(\n0\n,:\ngreen\n))\n\n\n\n\n\n\n\n\n\n\nand add to it later.\n\n\nscatter!\n(\nrand\n(\n100\n),\nmarkersize\n=\n6\n,\nc\n=\n:\norange\n)\n\n\n\n\n\n\n\n\nHistogram2D\n\n\nhistogram2d\n(\nrandn\n(\n10000\n),\nrandn\n(\n10000\n),\nnbins\n=\n20\n)\n\n\n\n\n\n\n\n\nLine types\n\n\nlinetypes\n \n=\n \n[:\npath\n \n:\nsteppre\n \n:\nsteppost\n \n:\nsticks\n \n:\nscatter\n]\n\n\nn\n \n=\n \nlength\n(\nlinetypes\n)\n\n\nx\n \n=\n \nVector\n[\nsort\n(\nrand\n(\n20\n))\n \nfor\n \ni\n \n=\n \n1\n:\nn\n]\n\n\ny\n \n=\n \nrand\n(\n20\n,\nn\n)\n\n\nplot\n(\nx\n,\ny\n,\nline\n=\n(\nlinetypes\n,\n3\n),\nlab\n=\nmap\n(\nstring\n,\nlinetypes\n),\nms\n=\n15\n)\n\n\n\n\n\n\n\n\nLine styles\n\n\nstyles\n \n=\n \nsetdiff\n(\nsupported_styles\n(),[:\nauto\n])\n\n\nplot\n(\ncumsum\n(\nrandn\n(\n20\n,\nlength\n(\nstyles\n)),\n1\n),\nstyle\n=\n:\nauto\n,\nlabel\n=\nmap\n(\nstring\n,\nstyles\n),\nw\n=\n5\n)\n\n\n\n\n\n\n\n\nMarker types\n\n\nmarkers\n \n=\n \nsetdiff\n(\nsupported_markers\n(),[:\nnone\n,:\nauto\n,\nShape\n])\n\n\nn\n \n=\n \nlength\n(\nmarkers\n)\n\n\nx\n \n=\n \n(\nlinspace\n(\n0\n,\n10\n,\nn\n \n+\n \n2\n))[\n2\n:\nend\n \n-\n \n1\n]\n\n\ny\n \n=\n \nrepmat\n(\nreverse\n(\nx\n)\n,\nn\n,\n1\n)\n\n\nscatter\n(\nx\n,\ny\n,\nm\n=\n(\n8\n,:\nauto\n),\nlab\n=\nmap\n(\nstring\n,\nmarkers\n),\nbg\n=\n:\nlinen\n,\nxlim\n=\n(\n0\n,\n10\n),\nylim\n=\n(\n0\n,\n10\n))\n\n\n\n\n\n\n\n\nBar\n\n\nx is the midpoint of the bar. (todo: allow passing of edges instead of midpoints)\n\n\nbar\n(\nrandn\n(\n99\n))\n\n\n\n\n\n\n\n\nHistogram\n\n\nhistogram\n(\nrandn\n(\n1000\n),\nnbins\n=\n20\n)\n\n\n\n\n\n\n\n\nSubplots\n\n\nUse the \nlayout\n keyword, and optionally the convenient \n@layout\n macro to generate arbitrarily complex subplot layouts.\n\n\nl\n \n=\n \n@\nlayout\n([\na\n{\n0.1\nh\n},\nb\n \n[\nc\n,\nd\n \ne\n]])\n\n\nplot\n(\nrandn\n(\n100\n,\n5\n),\nlayout\n=\nl\n,\nt\n=\n[:\nline\n \n:\nhistogram\n \n:\nscatter\n \n:\nsteppre\n \n:\nbar\n],\nleg\n=\nfalse\n,\nticks\n=\nnothing\n,\nborder\n=\nfalse\n)\n\n\n\n\n\n\n\n\nAdding to subplots\n\n\nNote here the automatic grid layout, as well as the order in which new series are added to the plots.\n\n\nplot\n(\nPlots\n.\nfakedata\n(\n100\n,\n10\n),\nlayout\n=\n4\n,\npalette\n=\n[:\ngrays\n \n:\nblues\n \n:\nheat\n \n:\nlightrainbow\n],\nbg_inside\n=\n[:\norange\n \n:\npink\n \n:\ndarkblue\n \n:\nblack\n])\n\n\n\n\n\n\n\n\n\n\nsrand\n(\n111\n)\n\n\nplot!\n(\nPlots\n.\nfakedata\n(\n100\n,\n10\n))\n\n\n\n\n\n\n\n\nOpen/High/Low/Close\n\n\nCreate an OHLC chart.  Pass in a list of (open,high,low,close) tuples as your \ny\n argument.  This uses recipes to first convert the tuples to OHLC objects, and subsequently create a :path series with the appropriate line segments.\n\n\nn\n \n=\n \n20\n\n\nhgt\n \n=\n \nrand\n(\nn\n)\n \n+\n \n1\n\n\nbot\n \n=\n \nrandn\n(\nn\n)\n\n\nopenpct\n \n=\n \nrand\n(\nn\n)\n\n\nclosepct\n \n=\n \nrand\n(\nn\n)\n\n\ny\n \n=\n \nOHLC\n[(\nopenpct\n[\ni\n]\n \n*\n \nhgt\n[\ni\n]\n \n+\n \nbot\n[\ni\n],\nbot\n[\ni\n]\n \n+\n \nhgt\n[\ni\n],\nbot\n[\ni\n],\nclosepct\n[\ni\n]\n \n*\n \nhgt\n[\ni\n]\n \n+\n \nbot\n[\ni\n])\n \nfor\n \ni\n \n=\n \n1\n:\nn\n]\n\n\nohlc\n(\ny\n)\n\n\n\n\n\n\n\n\nAnnotations\n\n\nThe \nannotations\n keyword is used for text annotations in data-coordinates.  Pass in a tuple (x,y,text) or a vector of annotations.  \nannotate!(ann)\n is shorthand for \nplot!(; annotation=ann)\n.  Series annotations are used for annotating individual data points.  They require only the annotation... x/y values are computed.  A \nPlotText\n object can be build with the method \ntext(string, attr...)\n, which wraps font and color attributes.\n\n\ny\n \n=\n \nrand\n(\n10\n)\n\n\nplot\n(\ny\n,\nannotations\n=\n(\n3\n,\ny\n[\n3\n],\ntext\n(\nthis is #3\n,:\nleft\n)),\nleg\n=\nfalse\n)\n\n\nannotate!\n([(\n5\n,\ny\n[\n5\n],\ntext\n(\nthis is #5\n,\n16\n,:\nred\n,:\ncenter\n)),(\n10\n,\ny\n[\n10\n],\ntext\n(\nthis is #10\n,:\nright\n,\n20\n,\ncourier\n))])\n\n\nscatter!\n(\nlinspace\n(\n2\n,\n8\n,\n6\n),\nrand\n(\n6\n),\nmarker\n=\n(\n50\n,\n0.2\n,:\norange\n),\nseries_annotations\n=\n[\nseries\n,\nannotations\n,\nmap\n,\nto\n,\nseries\n,\ntext\n(\ndata\n,:\ngreen\n)])\n\n\n\n\n\n\n\n\nCustom Markers\n\n\nA \nPlots.Shape\n is a light wrapper around vertices of a polygon.  For supported backends, pass arbitrary polygons as the marker shapes.  Note: The center is (0,0) and the size is expected to be rougly the area of the unit circle.\n\n\nverts\n \n=\n \n[(\n-\n1.0\n,\n1.0\n),(\n-\n1.28\n,\n0.6\n),(\n-\n0.2\n,\n-\n1.4\n),(\n0.2\n,\n-\n1.4\n),(\n1.28\n,\n0.6\n),(\n1.0\n,\n1.0\n),(\n-\n1.0\n,\n1.0\n),(\n-\n0.2\n,\n-\n0.6\n),(\n0.0\n,\n-\n0.2\n),(\n-\n0.4\n,\n0.6\n),(\n1.28\n,\n0.6\n),(\n0.2\n,\n-\n1.4\n),(\n-\n0.2\n,\n-\n1.4\n),(\n0.6\n,\n0.2\n),(\n-\n0.2\n,\n0.2\n),(\n0.0\n,\n-\n0.2\n),(\n0.2\n,\n0.2\n),(\n-\n0.2\n,\n-\n0.6\n)]\n\n\nx\n \n=\n \n0.1\n:\n0.2\n:\n0.9\n\n\ny\n \n=\n \n0.7\n \n*\n \nrand\n(\n5\n)\n \n+\n \n0.15\n\n\nplot\n(\nx\n,\ny\n,\nline\n=\n(\n3\n,:\ndash\n,:\nlightblue\n),\nmarker\n=\n(\nShape\n(\nverts\n),\n30\n,\nRGBA\n(\n0\n,\n0\n,\n0\n,\n0.2\n)),\nbg\n=\n:\npink\n,\nfg\n=\n:\ndarkblue\n,\nxlim\n=\n(\n0\n,\n1\n),\nylim\n=\n(\n0\n,\n1\n),\nleg\n=\nfalse\n)\n\n\n\n\n\n\n\n\nContours\n\n\nAny value for fill works here.  We first build a filled contour from a function, then an unfilled contour from a matrix.\n\n\nx\n \n=\n \n1\n:\n0.5\n:\n20\n\n\ny\n \n=\n \n1\n:\n0.5\n:\n10\n\n\nf\n(\nx\n,\ny\n)\n \n=\n \nbegin\n \n        \n(\n3\nx\n \n+\n \ny\n \n^\n \n2\n)\n \n*\n \nabs\n(\nsin\n(\nx\n)\n \n+\n \ncos\n(\ny\n))\n\n    \nend\n\n\nX\n \n=\n \nrepmat\n(\nx\n,\nlength\n(\ny\n),\n1\n)\n\n\nY\n \n=\n \nrepmat\n(\ny\n,\n1\n,\nlength\n(\nx\n))\n\n\nZ\n \n=\n \nmap\n(\nf\n,\nX\n,\nY\n)\n\n\np1\n \n=\n \ncontour\n(\nx\n,\ny\n,\nf\n,\nfill\n=\ntrue\n)\n\n\np2\n \n=\n \ncontour\n(\nx\n,\ny\n,\nZ\n)\n\n\nplot\n(\np1\n,\np2\n)\n\n\n\n\n\n\n\n\nPie\n\n\nx\n \n=\n \n[\nNerds\n,\nHackers\n,\nScientists\n]\n\n\ny\n \n=\n \n[\n0.4\n,\n0.35\n,\n0.25\n]\n\n\npie\n(\nx\n,\ny\n,\ntitle\n=\nThe Julia Community\n,\nl\n=\n0.5\n)\n\n\n\n\n\n\n\n\n3D\n\n\nn\n \n=\n \n100\n\n\nts\n \n=\n \nlinspace\n(\n0\n,\n8\n\u03c0\n,\nn\n)\n\n\nx\n \n=\n \nts\n \n.*\n \nmap\n(\ncos\n,\nts\n)\n\n\ny\n \n=\n \n(\n0.1\nts\n)\n \n.*\n \nmap\n(\nsin\n,\nts\n)\n\n\nz\n \n=\n \n1\n:\nn\n\n\nplot\n(\nx\n,\ny\n,\nz\n,\nzcolor\n=\nreverse\n(\nz\n),\nm\n=\n(\n10\n,\n0.8\n,:\nblues\n,\nstroke\n(\n0\n)),\nleg\n=\nfalse\n,\ncbar\n=\ntrue\n,\nw\n=\n5\n)\n\n\nplot!\n(\nzeros\n(\nn\n),\nzeros\n(\nn\n),\n1\n:\nn\n,\nw\n=\n10\n)\n\n\n\n\n\n\n\n\nDataFrames\n\n\nPlot using DataFrame column symbols.\n\n\nimport\n \nRDatasets\n\n\niris\n \n=\n \nRDatasets\n.\ndataset\n(\ndatasets\n,\niris\n)\n\n\nscatter\n(\niris\n,:\nSepalLength\n,:\nSepalWidth\n,\ngroup\n=\n:\nSpecies\n,\ntitle\n=\nMy awesome plot\n,\nxlabel\n=\nLength\n,\nylabel\n=\nWidth\n,\nmarker\n=\n(\n0.5\n,[:\n+\n \n:\nh\n \n:\nstar7\n],\n12\n),\nbg\n=\nRGB\n(\n0.2\n,\n0.2\n,\n0.2\n))\n\n\n\n\n\n\n\n\nGroups and Subplots\n\n\ngroup\n \n=\n \nrand\n(\nmap\n((\ni\n-\nbegin\n \n                    \ngroup \n$(i)\n\n                \nend\n),\n1\n:\n4\n),\n100\n)\n\n\nplot\n(\nrand\n(\n100\n),\nlayout\n=\n@\nlayout\n([\na\n \nb\n;\nc\n]),\ngroup\n=\ngroup\n,\nlinetype\n=\n[:\nbar\n \n:\nscatter\n \n:\nsteppre\n])\n\n\n\n\n\n\n\n\nPolar Plots\n\n\n\u0398\n \n=\n \nlinspace\n(\n0\n,\n1.5\n\u03c0\n,\n100\n)\n\n\nr\n \n=\n \nabs\n(\n0.1\n \n*\n \nrandn\n(\n100\n)\n \n+\n \nsin\n(\n3\n\u0398\n))\n\n\nplot\n(\n\u0398\n,\nr\n,\nproj\n=\n:\npolar\n,\nm\n=\n2\n)\n\n\n\n\n\n\n\n\nHeatmap, categorical axes, and aspect_ratio\n\n\nxs\n \n=\n \n[\nstring\n(\nx\n,\ni\n)\n \nfor\n \ni\n \n=\n \n1\n:\n10\n]\n\n\nys\n \n=\n \n[\nstring\n(\ny\n,\ni\n)\n \nfor\n \ni\n \n=\n \n1\n:\n4\n]\n\n\nz\n \n=\n \nfloat\n((\n1\n:\n4\n)\n \n*\n \n1\n:\n10\n)\n\n\nheatmap\n(\nxs\n,\nys\n,\nz\n,\naspect_ratio\n=\n1\n)\n\n\n\n\n\n\n\n\nLayouts, margins, label rotation, title location\n\n\nplot\n(\nrand\n(\n100\n,\n6\n),\nlayout\n=\n@\nlayout\n([\na\n \nb\n;\nc\n]),\ntitle\n=\n[\nA\n \nB\n \nC\n],\ntitle_location\n=\n:\nleft\n,\nleft_margin\n=\n[\n20\nmm\n \n0\nmm\n],\nbottom_margin\n=\n50\npx\n,\nxrotation\n=\n60\n)\n\n\n\n\n\n\n\n\nBoxplot and Violin series recipes\n\n\nimport\n \nRDatasets\n\n\nsingers\n \n=\n \nRDatasets\n.\ndataset\n(\nlattice\n,\nsinger\n)\n\n\nviolin\n(\nsingers\n,:\nVoicePart\n,:\nHeight\n,\nmarker\n=\n(\n0.2\n,:\nblue\n,\nstroke\n(\n0\n)))\n\n\nboxplot!\n(\nsingers\n,:\nVoicePart\n,:\nHeight\n,\nmarker\n=\n(\n0.3\n,:\norange\n,\nstroke\n(\n2\n)))\n\n\n\n\n\n\n\n\n\n\nSupported arguments: \nannotations\n, \nbackground_color\n, \nbackground_color_inside\n, \nbackground_color_legend\n, \nbackground_color_outside\n, \nbins\n, \ncolor_palette\n, \ncolorbar\n, \nfillalpha\n, \nfillcolor\n, \nfillrange\n, \nforeground_color\n, \nforeground_color_border\n, \nforeground_color_guide\n, \nforeground_color_legend\n, \nforeground_color_text\n, \ngrid\n, \ngroup\n, \nguidefont\n, \nhover\n, \nlabel\n, \nlayout\n, \nlegend\n, \nlegendfont\n, \nlevels\n, \nlinealpha\n, \nlinecolor\n, \nlinestyle\n, \nlinewidth\n, \nmarker_z\n, \nmarkeralpha\n, \nmarkercolor\n, \nmarkershape\n, \nmarkersize\n, \nmarkerstrokealpha\n, \nmarkerstrokecolor\n, \nmarkerstrokewidth\n, \nnormalize\n, \norientation\n, \npolar\n, \nquiver\n, \nribbon\n, \nseriesalpha\n, \nseriescolor\n, \nseriestype\n, \nshow\n, \nsize\n, \ntickfont\n, \ntitle\n, \ntitle_location\n, \ntitlefont\n, \nweights\n, \nwindow_title\n, \nx\n, \nxerror\n, \nxflip\n, \nxguide\n, \nxlims\n, \nxrotation\n, \nxscale\n, \nxticks\n, \ny\n, \nyerror\n, \nyflip\n, \nyguide\n, \nylims\n, \nyrotation\n, \nyscale\n, \nyticks\n, \nz\n, \nz\n, \nzflip\n, \nzguide\n, \nzlims\n, \nzrotation\n, \nzscale\n, \nzticks\n\n\nSupported values for linetype: \n:bar\n, \n:contour\n, \n:heatmap\n, \n:path\n, \n:path3d\n, \n:pie\n, \n:scatter\n, \n:scatter3d\n, \n:scattergl\n, \n:shape\n, \n:surface\n\n\nSupported values for linestyle: \n:auto\n, \n:dash\n, \n:dashdot\n, \n:dot\n, \n:solid\n\n\nSupported values for marker: \n:auto\n, \n:cross\n, \n:diamond\n, \n:dtriangle\n, \n:circle\n, \n:hexagon\n, \n:hline\n, \n:none\n, \n:octagon\n, \n:pentagon\n, \n:rect\n, \n:utriangle\n, \n:vline\n, \n:xcross\n\n(Automatically generated: 2016-06-13T12:46:48)", 
            "title": "PlotlyJS"
        }, 
        {
            "location": "/examples/plotlyjs/#initialize", 
            "text": "using   Plots  plotlyjs ()", 
            "title": "Initialize"
        }, 
        {
            "location": "/examples/plotlyjs/#lines", 
            "text": "A simple line plot of the columns.  plot ( Plots . fakedata ( 50 , 5 ), w = 3 )", 
            "title": "Lines"
        }, 
        {
            "location": "/examples/plotlyjs/#functions-adding-data-and-animations", 
            "text": "Plot multiple functions.  You can also put the function first, or use the form  plot(f, xmin, xmax)  where f is a Function or AbstractVector{Function}.  Get series data:  x, y = plt[i] .  Set series data:  plt[i] = (x,y) . Add to the series with  push! / append! .  Easily build animations.  ( convert  or  ffmpeg  must be available to generate the animation.)  Use command  gif(anim, filename, fps=15)  to save the animation.  p   =   plot ([ sin , cos ], zeros ( 0 ), leg = false )  anim   =   Animation ()  for   x   =   linspace ( 0 , 10 \u03c0 , 100 ) \n     push! ( p , x , Float64 [ sin ( x ), cos ( x )]) \n     frame ( anim )  end", 
            "title": "Functions, adding data, and animations"
        }, 
        {
            "location": "/examples/plotlyjs/#parametric-plots", 
            "text": "Plot function pair (x(u), y(u)).  plot ( sin ,( x - begin  \n             sin ( 2 x ) \n         end ), 0 , 2 \u03c0 , line = 4 , leg = false , fill = ( 0 ,: orange ))", 
            "title": "Parametric plots"
        }, 
        {
            "location": "/examples/plotlyjs/#colors", 
            "text": "Access predefined palettes (or build your own with the  colorscheme  method).  Line/marker colors are auto-generated from the plot's palette, unless overridden.  Set the  z  argument to turn on series gradients.  y   =   rand ( 100 )  plot ( 0 : 10 : 100 , rand ( 11 , 4 ), lab = lines , w = 3 , palette = : grays , fill = ( 0 ,: auto ), \u03b1 = 0.6 )  scatter! ( y , zcolor = abs ( y   -   0.5 ), m = (: heat , 0.8 , stroke ( 1 ,: green )), ms = 10   *   abs ( y   -   0.5 )   +   4 , lab = grad )", 
            "title": "Colors"
        }, 
        {
            "location": "/examples/plotlyjs/#global", 
            "text": "Change the guides/background/limits/ticks.  Convenience args  xaxis  and  yaxis  allow you to pass a tuple or value which will be mapped to the relevant args automatically.  The  xaxis  below will be replaced with  xlabel  and  xlims  args automatically during the preprocessing step. You can also use shorthand functions:  title! ,  xaxis! ,  yaxis! ,  xlabel! ,  ylabel! ,  xlims! ,  ylims! ,  xticks! ,  yticks!  y   =   rand ( 20 , 3 )  plot ( y , xaxis = ( XLABEL ,( - 5 , 30 ), 0 : 2 : 20 ,: flip ), background_color = RGB ( 0.2 , 0.2 , 0.2 ), leg = false )  hline! ( mean ( y , 1 )   +   rand ( 1 , 3 ), line = ( 4 ,: dash , 0.6 ,[: lightgreen   : green   : darkgreen ]))  vline! ([ 5 , 10 ])  title! ( TITLE )  yaxis! ( YLABEL ,: log10 )", 
            "title": "Global"
        }, 
        {
            "location": "/examples/plotlyjs/#arguments", 
            "text": "Plot multiple series with different numbers of points.  Mix arguments that apply to all series (marker/markersize) with arguments unique to each series (colors).  Special arguments  line ,  marker , and  fill  will automatically figure out what arguments to set (for example, we are setting the  linestyle ,  linewidth , and  color  arguments with  line .)  Note that we pass a matrix of colors, and this applies the colors to each series.  ys   =   Vector [ rand ( 10 ), rand ( 20 )]  plot ( ys , color = [: black   : orange ], line = (: dot , 4 ), marker = ([: hex   : d ], 12 , 0.8 , stroke ( 3 ,: gray )))", 
            "title": "Arguments"
        }, 
        {
            "location": "/examples/plotlyjs/#build-plot-in-pieces", 
            "text": "Start with a base plot...  plot ( rand ( 100 )   /   3 , reg = true , fill = ( 0 ,: green ))", 
            "title": "Build plot in pieces"
        }, 
        {
            "location": "/examples/plotlyjs/#histogram2d", 
            "text": "histogram2d ( randn ( 10000 ), randn ( 10000 ), nbins = 20 )", 
            "title": "Histogram2D"
        }, 
        {
            "location": "/examples/plotlyjs/#line-types", 
            "text": "linetypes   =   [: path   : steppre   : steppost   : sticks   : scatter ]  n   =   length ( linetypes )  x   =   Vector [ sort ( rand ( 20 ))   for   i   =   1 : n ]  y   =   rand ( 20 , n )  plot ( x , y , line = ( linetypes , 3 ), lab = map ( string , linetypes ), ms = 15 )", 
            "title": "Line types"
        }, 
        {
            "location": "/examples/plotlyjs/#line-styles", 
            "text": "styles   =   setdiff ( supported_styles (),[: auto ])  plot ( cumsum ( randn ( 20 , length ( styles )), 1 ), style = : auto , label = map ( string , styles ), w = 5 )", 
            "title": "Line styles"
        }, 
        {
            "location": "/examples/plotlyjs/#marker-types", 
            "text": "markers   =   setdiff ( supported_markers (),[: none ,: auto , Shape ])  n   =   length ( markers )  x   =   ( linspace ( 0 , 10 , n   +   2 ))[ 2 : end   -   1 ]  y   =   repmat ( reverse ( x ) , n , 1 )  scatter ( x , y , m = ( 8 ,: auto ), lab = map ( string , markers ), bg = : linen , xlim = ( 0 , 10 ), ylim = ( 0 , 10 ))", 
            "title": "Marker types"
        }, 
        {
            "location": "/examples/plotlyjs/#bar", 
            "text": "x is the midpoint of the bar. (todo: allow passing of edges instead of midpoints)  bar ( randn ( 99 ))", 
            "title": "Bar"
        }, 
        {
            "location": "/examples/plotlyjs/#histogram", 
            "text": "histogram ( randn ( 1000 ), nbins = 20 )", 
            "title": "Histogram"
        }, 
        {
            "location": "/examples/plotlyjs/#subplots", 
            "text": "Use the  layout  keyword, and optionally the convenient  @layout  macro to generate arbitrarily complex subplot layouts.  l   =   @ layout ([ a { 0.1 h }, b   [ c , d   e ]])  plot ( randn ( 100 , 5 ), layout = l , t = [: line   : histogram   : scatter   : steppre   : bar ], leg = false , ticks = nothing , border = false )", 
            "title": "Subplots"
        }, 
        {
            "location": "/examples/plotlyjs/#adding-to-subplots", 
            "text": "Note here the automatic grid layout, as well as the order in which new series are added to the plots.  plot ( Plots . fakedata ( 100 , 10 ), layout = 4 , palette = [: grays   : blues   : heat   : lightrainbow ], bg_inside = [: orange   : pink   : darkblue   : black ])", 
            "title": "Adding to subplots"
        }, 
        {
            "location": "/examples/plotlyjs/#openhighlowclose", 
            "text": "Create an OHLC chart.  Pass in a list of (open,high,low,close) tuples as your  y  argument.  This uses recipes to first convert the tuples to OHLC objects, and subsequently create a :path series with the appropriate line segments.  n   =   20  hgt   =   rand ( n )   +   1  bot   =   randn ( n )  openpct   =   rand ( n )  closepct   =   rand ( n )  y   =   OHLC [( openpct [ i ]   *   hgt [ i ]   +   bot [ i ], bot [ i ]   +   hgt [ i ], bot [ i ], closepct [ i ]   *   hgt [ i ]   +   bot [ i ])   for   i   =   1 : n ]  ohlc ( y )", 
            "title": "Open/High/Low/Close"
        }, 
        {
            "location": "/examples/plotlyjs/#annotations", 
            "text": "The  annotations  keyword is used for text annotations in data-coordinates.  Pass in a tuple (x,y,text) or a vector of annotations.   annotate!(ann)  is shorthand for  plot!(; annotation=ann) .  Series annotations are used for annotating individual data points.  They require only the annotation... x/y values are computed.  A  PlotText  object can be build with the method  text(string, attr...) , which wraps font and color attributes.  y   =   rand ( 10 )  plot ( y , annotations = ( 3 , y [ 3 ], text ( this is #3 ,: left )), leg = false )  annotate! ([( 5 , y [ 5 ], text ( this is #5 , 16 ,: red ,: center )),( 10 , y [ 10 ], text ( this is #10 ,: right , 20 , courier ))])  scatter! ( linspace ( 2 , 8 , 6 ), rand ( 6 ), marker = ( 50 , 0.2 ,: orange ), series_annotations = [ series , annotations , map , to , series , text ( data ,: green )])", 
            "title": "Annotations"
        }, 
        {
            "location": "/examples/plotlyjs/#custom-markers", 
            "text": "A  Plots.Shape  is a light wrapper around vertices of a polygon.  For supported backends, pass arbitrary polygons as the marker shapes.  Note: The center is (0,0) and the size is expected to be rougly the area of the unit circle.  verts   =   [( - 1.0 , 1.0 ),( - 1.28 , 0.6 ),( - 0.2 , - 1.4 ),( 0.2 , - 1.4 ),( 1.28 , 0.6 ),( 1.0 , 1.0 ),( - 1.0 , 1.0 ),( - 0.2 , - 0.6 ),( 0.0 , - 0.2 ),( - 0.4 , 0.6 ),( 1.28 , 0.6 ),( 0.2 , - 1.4 ),( - 0.2 , - 1.4 ),( 0.6 , 0.2 ),( - 0.2 , 0.2 ),( 0.0 , - 0.2 ),( 0.2 , 0.2 ),( - 0.2 , - 0.6 )]  x   =   0.1 : 0.2 : 0.9  y   =   0.7   *   rand ( 5 )   +   0.15  plot ( x , y , line = ( 3 ,: dash ,: lightblue ), marker = ( Shape ( verts ), 30 , RGBA ( 0 , 0 , 0 , 0.2 )), bg = : pink , fg = : darkblue , xlim = ( 0 , 1 ), ylim = ( 0 , 1 ), leg = false )", 
            "title": "Custom Markers"
        }, 
        {
            "location": "/examples/plotlyjs/#contours", 
            "text": "Any value for fill works here.  We first build a filled contour from a function, then an unfilled contour from a matrix.  x   =   1 : 0.5 : 20  y   =   1 : 0.5 : 10  f ( x , y )   =   begin  \n         ( 3 x   +   y   ^   2 )   *   abs ( sin ( x )   +   cos ( y )) \n     end  X   =   repmat ( x , length ( y ), 1 )  Y   =   repmat ( y , 1 , length ( x ))  Z   =   map ( f , X , Y )  p1   =   contour ( x , y , f , fill = true )  p2   =   contour ( x , y , Z )  plot ( p1 , p2 )", 
            "title": "Contours"
        }, 
        {
            "location": "/examples/plotlyjs/#pie", 
            "text": "x   =   [ Nerds , Hackers , Scientists ]  y   =   [ 0.4 , 0.35 , 0.25 ]  pie ( x , y , title = The Julia Community , l = 0.5 )", 
            "title": "Pie"
        }, 
        {
            "location": "/examples/plotlyjs/#3d", 
            "text": "n   =   100  ts   =   linspace ( 0 , 8 \u03c0 , n )  x   =   ts   .*   map ( cos , ts )  y   =   ( 0.1 ts )   .*   map ( sin , ts )  z   =   1 : n  plot ( x , y , z , zcolor = reverse ( z ), m = ( 10 , 0.8 ,: blues , stroke ( 0 )), leg = false , cbar = true , w = 5 )  plot! ( zeros ( n ), zeros ( n ), 1 : n , w = 10 )", 
            "title": "3D"
        }, 
        {
            "location": "/examples/plotlyjs/#dataframes", 
            "text": "Plot using DataFrame column symbols.  import   RDatasets  iris   =   RDatasets . dataset ( datasets , iris )  scatter ( iris ,: SepalLength ,: SepalWidth , group = : Species , title = My awesome plot , xlabel = Length , ylabel = Width , marker = ( 0.5 ,[: +   : h   : star7 ], 12 ), bg = RGB ( 0.2 , 0.2 , 0.2 ))", 
            "title": "DataFrames"
        }, 
        {
            "location": "/examples/plotlyjs/#groups-and-subplots", 
            "text": "group   =   rand ( map (( i - begin  \n                     group  $(i) \n                 end ), 1 : 4 ), 100 )  plot ( rand ( 100 ), layout = @ layout ([ a   b ; c ]), group = group , linetype = [: bar   : scatter   : steppre ])", 
            "title": "Groups and Subplots"
        }, 
        {
            "location": "/examples/plotlyjs/#polar-plots", 
            "text": "\u0398   =   linspace ( 0 , 1.5 \u03c0 , 100 )  r   =   abs ( 0.1   *   randn ( 100 )   +   sin ( 3 \u0398 ))  plot ( \u0398 , r , proj = : polar , m = 2 )", 
            "title": "Polar Plots"
        }, 
        {
            "location": "/examples/plotlyjs/#heatmap-categorical-axes-and-aspect_ratio", 
            "text": "xs   =   [ string ( x , i )   for   i   =   1 : 10 ]  ys   =   [ string ( y , i )   for   i   =   1 : 4 ]  z   =   float (( 1 : 4 )   *   1 : 10 )  heatmap ( xs , ys , z , aspect_ratio = 1 )", 
            "title": "Heatmap, categorical axes, and aspect_ratio"
        }, 
        {
            "location": "/examples/plotlyjs/#layouts-margins-label-rotation-title-location", 
            "text": "plot ( rand ( 100 , 6 ), layout = @ layout ([ a   b ; c ]), title = [ A   B   C ], title_location = : left , left_margin = [ 20 mm   0 mm ], bottom_margin = 50 px , xrotation = 60 )", 
            "title": "Layouts, margins, label rotation, title location"
        }, 
        {
            "location": "/examples/plotlyjs/#boxplot-and-violin-series-recipes", 
            "text": "import   RDatasets  singers   =   RDatasets . dataset ( lattice , singer )  violin ( singers ,: VoicePart ,: Height , marker = ( 0.2 ,: blue , stroke ( 0 )))  boxplot! ( singers ,: VoicePart ,: Height , marker = ( 0.3 ,: orange , stroke ( 2 )))     Supported arguments:  annotations ,  background_color ,  background_color_inside ,  background_color_legend ,  background_color_outside ,  bins ,  color_palette ,  colorbar ,  fillalpha ,  fillcolor ,  fillrange ,  foreground_color ,  foreground_color_border ,  foreground_color_guide ,  foreground_color_legend ,  foreground_color_text ,  grid ,  group ,  guidefont ,  hover ,  label ,  layout ,  legend ,  legendfont ,  levels ,  linealpha ,  linecolor ,  linestyle ,  linewidth ,  marker_z ,  markeralpha ,  markercolor ,  markershape ,  markersize ,  markerstrokealpha ,  markerstrokecolor ,  markerstrokewidth ,  normalize ,  orientation ,  polar ,  quiver ,  ribbon ,  seriesalpha ,  seriescolor ,  seriestype ,  show ,  size ,  tickfont ,  title ,  title_location ,  titlefont ,  weights ,  window_title ,  x ,  xerror ,  xflip ,  xguide ,  xlims ,  xrotation ,  xscale ,  xticks ,  y ,  yerror ,  yflip ,  yguide ,  ylims ,  yrotation ,  yscale ,  yticks ,  z ,  z ,  zflip ,  zguide ,  zlims ,  zrotation ,  zscale ,  zticks  Supported values for linetype:  :bar ,  :contour ,  :heatmap ,  :path ,  :path3d ,  :pie ,  :scatter ,  :scatter3d ,  :scattergl ,  :shape ,  :surface  Supported values for linestyle:  :auto ,  :dash ,  :dashdot ,  :dot ,  :solid  Supported values for marker:  :auto ,  :cross ,  :diamond ,  :dtriangle ,  :circle ,  :hexagon ,  :hline ,  :none ,  :octagon ,  :pentagon ,  :rect ,  :utriangle ,  :vline ,  :xcross \n(Automatically generated: 2016-06-13T12:46:48)", 
            "title": "Boxplot and Violin series recipes"
        }, 
        {
            "location": "/examples/pgfplots/", 
            "text": "Initialize\n\n\nusing\n \nPlots\n\n\npgfplots\n()\n\n\n\n\n\n\nLines\n\n\nA simple line plot of the columns.\n\n\nplot\n(\nPlots\n.\nfakedata\n(\n50\n,\n5\n),\nw\n=\n3\n)\n\n\n\n\n\n\n\n\nParametric plots\n\n\nPlot function pair (x(u), y(u)).\n\n\nplot\n(\nsin\n,(\nx\n-\nbegin\n \n            \nsin\n(\n2\nx\n)\n\n        \nend\n),\n0\n,\n2\n\u03c0\n,\nline\n=\n4\n,\nleg\n=\nfalse\n,\nfill\n=\n(\n0\n,:\norange\n))\n\n\n\n\n\n\n\n\nGlobal\n\n\nChange the guides/background/limits/ticks.  Convenience args \nxaxis\n and \nyaxis\n allow you to pass a tuple or value which will be mapped to the relevant args automatically.  The \nxaxis\n below will be replaced with \nxlabel\n and \nxlims\n args automatically during the preprocessing step. You can also use shorthand functions: \ntitle!\n, \nxaxis!\n, \nyaxis!\n, \nxlabel!\n, \nylabel!\n, \nxlims!\n, \nylims!\n, \nxticks!\n, \nyticks!\n\n\ny\n \n=\n \nrand\n(\n20\n,\n3\n)\n\n\nplot\n(\ny\n,\nxaxis\n=\n(\nXLABEL\n,(\n-\n5\n,\n30\n),\n0\n:\n2\n:\n20\n,:\nflip\n),\nbackground_color\n=\nRGB\n(\n0.2\n,\n0.2\n,\n0.2\n),\nleg\n=\nfalse\n)\n\n\nhline!\n(\nmean\n(\ny\n,\n1\n)\n \n+\n \nrand\n(\n1\n,\n3\n),\nline\n=\n(\n4\n,:\ndash\n,\n0.6\n,[:\nlightgreen\n \n:\ngreen\n \n:\ndarkgreen\n]))\n\n\nvline!\n([\n5\n,\n10\n])\n\n\ntitle!\n(\nTITLE\n)\n\n\nyaxis!\n(\nYLABEL\n,:\nlog10\n)\n\n\n\n\n\n\n\n\nArguments\n\n\nPlot multiple series with different numbers of points.  Mix arguments that apply to all series (marker/markersize) with arguments unique to each series (colors).  Special arguments \nline\n, \nmarker\n, and \nfill\n will automatically figure out what arguments to set (for example, we are setting the \nlinestyle\n, \nlinewidth\n, and \ncolor\n arguments with \nline\n.)  Note that we pass a matrix of colors, and this applies the colors to each series.\n\n\nys\n \n=\n \nVector\n[\nrand\n(\n10\n),\nrand\n(\n20\n)]\n\n\nplot\n(\nys\n,\ncolor\n=\n[:\nblack\n \n:\norange\n],\nline\n=\n(:\ndot\n,\n4\n),\nmarker\n=\n([:\nhex\n \n:\nd\n],\n12\n,\n0.8\n,\nstroke\n(\n3\n,:\ngray\n)))\n\n\n\n\n\n\n\n\nBuild plot in pieces\n\n\nStart with a base plot...\n\n\nplot\n(\nrand\n(\n100\n)\n \n/\n \n3\n,\nreg\n=\ntrue\n,\nfill\n=\n(\n0\n,:\ngreen\n))\n\n\n\n\n\n\n\n\n\n\nand add to it later.\n\n\nscatter!\n(\nrand\n(\n100\n),\nmarkersize\n=\n6\n,\nc\n=\n:\norange\n)\n\n\n\n\n\n\n\n\nLine types\n\n\nlinetypes\n \n=\n \n[:\npath\n \n:\nsteppre\n \n:\nsteppost\n \n:\nsticks\n \n:\nscatter\n]\n\n\nn\n \n=\n \nlength\n(\nlinetypes\n)\n\n\nx\n \n=\n \nVector\n[\nsort\n(\nrand\n(\n20\n))\n \nfor\n \ni\n \n=\n \n1\n:\nn\n]\n\n\ny\n \n=\n \nrand\n(\n20\n,\nn\n)\n\n\nplot\n(\nx\n,\ny\n,\nline\n=\n(\nlinetypes\n,\n3\n),\nlab\n=\nmap\n(\nstring\n,\nlinetypes\n),\nms\n=\n15\n)\n\n\n\n\n\n\n\n\nLine styles\n\n\nstyles\n \n=\n \nsetdiff\n(\nsupported_styles\n(),[:\nauto\n])\n\n\nplot\n(\ncumsum\n(\nrandn\n(\n20\n,\nlength\n(\nstyles\n)),\n1\n),\nstyle\n=\n:\nauto\n,\nlabel\n=\nmap\n(\nstring\n,\nstyles\n),\nw\n=\n5\n)\n\n\n\n\n\n\n\n\nMarker types\n\n\nmarkers\n \n=\n \nsetdiff\n(\nsupported_markers\n(),[:\nnone\n,:\nauto\n,\nShape\n])\n\n\nn\n \n=\n \nlength\n(\nmarkers\n)\n\n\nx\n \n=\n \n(\nlinspace\n(\n0\n,\n10\n,\nn\n \n+\n \n2\n))[\n2\n:\nend\n \n-\n \n1\n]\n\n\ny\n \n=\n \nrepmat\n(\nreverse\n(\nx\n)\n,\nn\n,\n1\n)\n\n\nscatter\n(\nx\n,\ny\n,\nm\n=\n(\n8\n,:\nauto\n),\nlab\n=\nmap\n(\nstring\n,\nmarkers\n),\nbg\n=\n:\nlinen\n,\nxlim\n=\n(\n0\n,\n10\n),\nylim\n=\n(\n0\n,\n10\n))\n\n\n\n\n\n\n\n\nBar\n\n\nx is the midpoint of the bar. (todo: allow passing of edges instead of midpoints)\n\n\nbar\n(\nrandn\n(\n99\n))\n\n\n\n\n\n\n\n\nHistogram\n\n\nhistogram\n(\nrandn\n(\n1000\n),\nnbins\n=\n20\n)\n\n\n\n\n\n\n\n\nSubplots\n\n\nUse the \nlayout\n keyword, and optionally the convenient \n@layout\n macro to generate arbitrarily complex subplot layouts.\n\n\nl\n \n=\n \n@\nlayout\n([\na\n{\n0.1\nh\n},\nb\n \n[\nc\n,\nd\n \ne\n]])\n\n\nplot\n(\nrandn\n(\n100\n,\n5\n),\nlayout\n=\nl\n,\nt\n=\n[:\nline\n \n:\nhistogram\n \n:\nscatter\n \n:\nsteppre\n \n:\nbar\n],\nleg\n=\nfalse\n,\nticks\n=\nnothing\n,\nborder\n=\nfalse\n)\n\n\n\n\n\n\n\n\nAdding to subplots\n\n\nNote here the automatic grid layout, as well as the order in which new series are added to the plots.\n\n\nplot\n(\nPlots\n.\nfakedata\n(\n100\n,\n10\n),\nlayout\n=\n4\n,\npalette\n=\n[:\ngrays\n \n:\nblues\n \n:\nheat\n \n:\nlightrainbow\n],\nbg_inside\n=\n[:\norange\n \n:\npink\n \n:\ndarkblue\n \n:\nblack\n])\n\n\n\n\n\n\n\n\n\n\nsrand\n(\n111\n)\n\n\nplot!\n(\nPlots\n.\nfakedata\n(\n100\n,\n10\n))\n\n\n\n\n\n\n\n\nOpen/High/Low/Close\n\n\nCreate an OHLC chart.  Pass in a list of (open,high,low,close) tuples as your \ny\n argument.  This uses recipes to first convert the tuples to OHLC objects, and subsequently create a :path series with the appropriate line segments.\n\n\nn\n \n=\n \n20\n\n\nhgt\n \n=\n \nrand\n(\nn\n)\n \n+\n \n1\n\n\nbot\n \n=\n \nrandn\n(\nn\n)\n\n\nopenpct\n \n=\n \nrand\n(\nn\n)\n\n\nclosepct\n \n=\n \nrand\n(\nn\n)\n\n\ny\n \n=\n \nOHLC\n[(\nopenpct\n[\ni\n]\n \n*\n \nhgt\n[\ni\n]\n \n+\n \nbot\n[\ni\n],\nbot\n[\ni\n]\n \n+\n \nhgt\n[\ni\n],\nbot\n[\ni\n],\nclosepct\n[\ni\n]\n \n*\n \nhgt\n[\ni\n]\n \n+\n \nbot\n[\ni\n])\n \nfor\n \ni\n \n=\n \n1\n:\nn\n]\n\n\nohlc\n(\ny\n)\n\n\n\n\n\n\n\n\nAnnotations\n\n\nThe \nannotations\n keyword is used for text annotations in data-coordinates.  Pass in a tuple (x,y,text) or a vector of annotations.  \nannotate!(ann)\n is shorthand for \nplot!(; annotation=ann)\n.  Series annotations are used for annotating individual data points.  They require only the annotation... x/y values are computed.  A \nPlotText\n object can be build with the method \ntext(string, attr...)\n, which wraps font and color attributes.\n\n\ny\n \n=\n \nrand\n(\n10\n)\n\n\nplot\n(\ny\n,\nannotations\n=\n(\n3\n,\ny\n[\n3\n],\ntext\n(\nthis is #3\n,:\nleft\n)),\nleg\n=\nfalse\n)\n\n\nannotate!\n([(\n5\n,\ny\n[\n5\n],\ntext\n(\nthis is #5\n,\n16\n,:\nred\n,:\ncenter\n)),(\n10\n,\ny\n[\n10\n],\ntext\n(\nthis is #10\n,:\nright\n,\n20\n,\ncourier\n))])\n\n\nscatter!\n(\nlinspace\n(\n2\n,\n8\n,\n6\n),\nrand\n(\n6\n),\nmarker\n=\n(\n50\n,\n0.2\n,:\norange\n),\nseries_annotations\n=\n[\nseries\n,\nannotations\n,\nmap\n,\nto\n,\nseries\n,\ntext\n(\ndata\n,:\ngreen\n)])\n\n\n\n\n\n\n\n\nCustom Markers\n\n\nA \nPlots.Shape\n is a light wrapper around vertices of a polygon.  For supported backends, pass arbitrary polygons as the marker shapes.  Note: The center is (0,0) and the size is expected to be rougly the area of the unit circle.\n\n\nverts\n \n=\n \n[(\n-\n1.0\n,\n1.0\n),(\n-\n1.28\n,\n0.6\n),(\n-\n0.2\n,\n-\n1.4\n),(\n0.2\n,\n-\n1.4\n),(\n1.28\n,\n0.6\n),(\n1.0\n,\n1.0\n),(\n-\n1.0\n,\n1.0\n),(\n-\n0.2\n,\n-\n0.6\n),(\n0.0\n,\n-\n0.2\n),(\n-\n0.4\n,\n0.6\n),(\n1.28\n,\n0.6\n),(\n0.2\n,\n-\n1.4\n),(\n-\n0.2\n,\n-\n1.4\n),(\n0.6\n,\n0.2\n),(\n-\n0.2\n,\n0.2\n),(\n0.0\n,\n-\n0.2\n),(\n0.2\n,\n0.2\n),(\n-\n0.2\n,\n-\n0.6\n)]\n\n\nx\n \n=\n \n0.1\n:\n0.2\n:\n0.9\n\n\ny\n \n=\n \n0.7\n \n*\n \nrand\n(\n5\n)\n \n+\n \n0.15\n\n\nplot\n(\nx\n,\ny\n,\nline\n=\n(\n3\n,:\ndash\n,:\nlightblue\n),\nmarker\n=\n(\nShape\n(\nverts\n),\n30\n,\nRGBA\n(\n0\n,\n0\n,\n0\n,\n0.2\n)),\nbg\n=\n:\npink\n,\nfg\n=\n:\ndarkblue\n,\nxlim\n=\n(\n0\n,\n1\n),\nylim\n=\n(\n0\n,\n1\n),\nleg\n=\nfalse\n)\n\n\n\n\n\n\n\n\n3D\n\n\nn\n \n=\n \n100\n\n\nts\n \n=\n \nlinspace\n(\n0\n,\n8\n\u03c0\n,\nn\n)\n\n\nx\n \n=\n \nts\n \n.*\n \nmap\n(\ncos\n,\nts\n)\n\n\ny\n \n=\n \n(\n0.1\nts\n)\n \n.*\n \nmap\n(\nsin\n,\nts\n)\n\n\nz\n \n=\n \n1\n:\nn\n\n\nplot\n(\nx\n,\ny\n,\nz\n,\nzcolor\n=\nreverse\n(\nz\n),\nm\n=\n(\n10\n,\n0.8\n,:\nblues\n,\nstroke\n(\n0\n)),\nleg\n=\nfalse\n,\ncbar\n=\ntrue\n,\nw\n=\n5\n)\n\n\nplot!\n(\nzeros\n(\nn\n),\nzeros\n(\nn\n),\n1\n:\nn\n,\nw\n=\n10\n)\n\n\n\n\n\n\n\n\nDataFrames\n\n\nPlot using DataFrame column symbols.\n\n\nimport\n \nRDatasets\n\n\niris\n \n=\n \nRDatasets\n.\ndataset\n(\ndatasets\n,\niris\n)\n\n\nscatter\n(\niris\n,:\nSepalLength\n,:\nSepalWidth\n,\ngroup\n=\n:\nSpecies\n,\ntitle\n=\nMy awesome plot\n,\nxlabel\n=\nLength\n,\nylabel\n=\nWidth\n,\nmarker\n=\n(\n0.5\n,[:\n+\n \n:\nh\n \n:\nstar7\n],\n12\n),\nbg\n=\nRGB\n(\n0.2\n,\n0.2\n,\n0.2\n))\n\n\n\n\n\n\n\n\nPolar Plots\n\n\n\u0398\n \n=\n \nlinspace\n(\n0\n,\n1.5\n\u03c0\n,\n100\n)\n\n\nr\n \n=\n \nabs\n(\n0.1\n \n*\n \nrandn\n(\n100\n)\n \n+\n \nsin\n(\n3\n\u0398\n))\n\n\nplot\n(\n\u0398\n,\nr\n,\nproj\n=\n:\npolar\n,\nm\n=\n2\n)\n\n\n\n\n\n\n\n\nLayouts, margins, label rotation, title location\n\n\nplot\n(\nrand\n(\n100\n,\n6\n),\nlayout\n=\n@\nlayout\n([\na\n \nb\n;\nc\n]),\ntitle\n=\n[\nA\n \nB\n \nC\n],\ntitle_location\n=\n:\nleft\n,\nleft_margin\n=\n[\n20\nmm\n \n0\nmm\n],\nbottom_margin\n=\n50\npx\n,\nxrotation\n=\n60\n)\n\n\n\n\n\n\n\n\n\n\nSupported arguments: \naspect_ratio\n, \nbackground_color\n, \nbackground_color_inside\n, \nbins\n, \ncolor_palette\n, \nfillalpha\n, \nfillcolor\n, \nfillrange\n, \nforeground_color\n, \ngrid\n, \ngroup\n, \nguidefont\n, \nlabel\n, \nlayout\n, \nlegend\n, \nlegendfont\n, \nlinealpha\n, \nlinecolor\n, \nlinestyle\n, \nlinewidth\n, \nmarkeralpha\n, \nmarkercolor\n, \nmarkershape\n, \nmarkersize\n, \nmarkerstrokealpha\n, \nmarkerstrokecolor\n, \nmarkerstrokewidth\n, \nseriesalpha\n, \nseriescolor\n, \nseriestype\n, \nshow\n, \nsize\n, \ntickfont\n, \ntitle\n, \nx\n, \nxflip\n, \nxguide\n, \nxlims\n, \nxrotation\n, \nxscale\n, \nxticks\n, \ny\n, \nyflip\n, \nyguide\n, \nylims\n, \nyrotation\n, \nyscale\n, \nyticks\n, \nz\n, \nzflip\n, \nzguide\n, \nzlims\n, \nzrotation\n, \nzscale\n, \nzticks\n\n\nSupported values for axis: \n:auto\n, \n:left\n\n\nSupported values for linetype: \n:contour\n, \n:histogram2d\n, \n:path\n, \n:path3d\n, \n:scatter\n, \n:stepmid\n, \n:steppost\n, \n:steppre\n, \n:xsticks\n, \n:ysticks\n\n\nSupported values for linestyle: \n:auto\n, \n:dash\n, \n:dashdot\n, \n:dashdotdot\n, \n:dot\n, \n:solid\n\n\nSupported values for marker: \n:auto\n, \n:cross\n, \n:diamond\n, \n:dtriangle\n, \n:circle\n, \n:none\n, \n:pentagon\n, \n:rect\n, \n:star5\n, \n:utriangle\n, \n:xcross\n\n\nIs \nsubplot\n/\nsubplot!\n supported? No\n\n\n\n\n(Automatically generated: 2016-06-09T17:39:13)", 
            "title": "PGFPlots"
        }, 
        {
            "location": "/examples/pgfplots/#initialize", 
            "text": "using   Plots  pgfplots ()", 
            "title": "Initialize"
        }, 
        {
            "location": "/examples/pgfplots/#lines", 
            "text": "A simple line plot of the columns.  plot ( Plots . fakedata ( 50 , 5 ), w = 3 )", 
            "title": "Lines"
        }, 
        {
            "location": "/examples/pgfplots/#parametric-plots", 
            "text": "Plot function pair (x(u), y(u)).  plot ( sin ,( x - begin  \n             sin ( 2 x ) \n         end ), 0 , 2 \u03c0 , line = 4 , leg = false , fill = ( 0 ,: orange ))", 
            "title": "Parametric plots"
        }, 
        {
            "location": "/examples/pgfplots/#global", 
            "text": "Change the guides/background/limits/ticks.  Convenience args  xaxis  and  yaxis  allow you to pass a tuple or value which will be mapped to the relevant args automatically.  The  xaxis  below will be replaced with  xlabel  and  xlims  args automatically during the preprocessing step. You can also use shorthand functions:  title! ,  xaxis! ,  yaxis! ,  xlabel! ,  ylabel! ,  xlims! ,  ylims! ,  xticks! ,  yticks!  y   =   rand ( 20 , 3 )  plot ( y , xaxis = ( XLABEL ,( - 5 , 30 ), 0 : 2 : 20 ,: flip ), background_color = RGB ( 0.2 , 0.2 , 0.2 ), leg = false )  hline! ( mean ( y , 1 )   +   rand ( 1 , 3 ), line = ( 4 ,: dash , 0.6 ,[: lightgreen   : green   : darkgreen ]))  vline! ([ 5 , 10 ])  title! ( TITLE )  yaxis! ( YLABEL ,: log10 )", 
            "title": "Global"
        }, 
        {
            "location": "/examples/pgfplots/#arguments", 
            "text": "Plot multiple series with different numbers of points.  Mix arguments that apply to all series (marker/markersize) with arguments unique to each series (colors).  Special arguments  line ,  marker , and  fill  will automatically figure out what arguments to set (for example, we are setting the  linestyle ,  linewidth , and  color  arguments with  line .)  Note that we pass a matrix of colors, and this applies the colors to each series.  ys   =   Vector [ rand ( 10 ), rand ( 20 )]  plot ( ys , color = [: black   : orange ], line = (: dot , 4 ), marker = ([: hex   : d ], 12 , 0.8 , stroke ( 3 ,: gray )))", 
            "title": "Arguments"
        }, 
        {
            "location": "/examples/pgfplots/#build-plot-in-pieces", 
            "text": "Start with a base plot...  plot ( rand ( 100 )   /   3 , reg = true , fill = ( 0 ,: green ))", 
            "title": "Build plot in pieces"
        }, 
        {
            "location": "/examples/pgfplots/#line-types", 
            "text": "linetypes   =   [: path   : steppre   : steppost   : sticks   : scatter ]  n   =   length ( linetypes )  x   =   Vector [ sort ( rand ( 20 ))   for   i   =   1 : n ]  y   =   rand ( 20 , n )  plot ( x , y , line = ( linetypes , 3 ), lab = map ( string , linetypes ), ms = 15 )", 
            "title": "Line types"
        }, 
        {
            "location": "/examples/pgfplots/#line-styles", 
            "text": "styles   =   setdiff ( supported_styles (),[: auto ])  plot ( cumsum ( randn ( 20 , length ( styles )), 1 ), style = : auto , label = map ( string , styles ), w = 5 )", 
            "title": "Line styles"
        }, 
        {
            "location": "/examples/pgfplots/#marker-types", 
            "text": "markers   =   setdiff ( supported_markers (),[: none ,: auto , Shape ])  n   =   length ( markers )  x   =   ( linspace ( 0 , 10 , n   +   2 ))[ 2 : end   -   1 ]  y   =   repmat ( reverse ( x ) , n , 1 )  scatter ( x , y , m = ( 8 ,: auto ), lab = map ( string , markers ), bg = : linen , xlim = ( 0 , 10 ), ylim = ( 0 , 10 ))", 
            "title": "Marker types"
        }, 
        {
            "location": "/examples/pgfplots/#bar", 
            "text": "x is the midpoint of the bar. (todo: allow passing of edges instead of midpoints)  bar ( randn ( 99 ))", 
            "title": "Bar"
        }, 
        {
            "location": "/examples/pgfplots/#histogram", 
            "text": "histogram ( randn ( 1000 ), nbins = 20 )", 
            "title": "Histogram"
        }, 
        {
            "location": "/examples/pgfplots/#subplots", 
            "text": "Use the  layout  keyword, and optionally the convenient  @layout  macro to generate arbitrarily complex subplot layouts.  l   =   @ layout ([ a { 0.1 h }, b   [ c , d   e ]])  plot ( randn ( 100 , 5 ), layout = l , t = [: line   : histogram   : scatter   : steppre   : bar ], leg = false , ticks = nothing , border = false )", 
            "title": "Subplots"
        }, 
        {
            "location": "/examples/pgfplots/#adding-to-subplots", 
            "text": "Note here the automatic grid layout, as well as the order in which new series are added to the plots.  plot ( Plots . fakedata ( 100 , 10 ), layout = 4 , palette = [: grays   : blues   : heat   : lightrainbow ], bg_inside = [: orange   : pink   : darkblue   : black ])", 
            "title": "Adding to subplots"
        }, 
        {
            "location": "/examples/pgfplots/#openhighlowclose", 
            "text": "Create an OHLC chart.  Pass in a list of (open,high,low,close) tuples as your  y  argument.  This uses recipes to first convert the tuples to OHLC objects, and subsequently create a :path series with the appropriate line segments.  n   =   20  hgt   =   rand ( n )   +   1  bot   =   randn ( n )  openpct   =   rand ( n )  closepct   =   rand ( n )  y   =   OHLC [( openpct [ i ]   *   hgt [ i ]   +   bot [ i ], bot [ i ]   +   hgt [ i ], bot [ i ], closepct [ i ]   *   hgt [ i ]   +   bot [ i ])   for   i   =   1 : n ]  ohlc ( y )", 
            "title": "Open/High/Low/Close"
        }, 
        {
            "location": "/examples/pgfplots/#annotations", 
            "text": "The  annotations  keyword is used for text annotations in data-coordinates.  Pass in a tuple (x,y,text) or a vector of annotations.   annotate!(ann)  is shorthand for  plot!(; annotation=ann) .  Series annotations are used for annotating individual data points.  They require only the annotation... x/y values are computed.  A  PlotText  object can be build with the method  text(string, attr...) , which wraps font and color attributes.  y   =   rand ( 10 )  plot ( y , annotations = ( 3 , y [ 3 ], text ( this is #3 ,: left )), leg = false )  annotate! ([( 5 , y [ 5 ], text ( this is #5 , 16 ,: red ,: center )),( 10 , y [ 10 ], text ( this is #10 ,: right , 20 , courier ))])  scatter! ( linspace ( 2 , 8 , 6 ), rand ( 6 ), marker = ( 50 , 0.2 ,: orange ), series_annotations = [ series , annotations , map , to , series , text ( data ,: green )])", 
            "title": "Annotations"
        }, 
        {
            "location": "/examples/pgfplots/#custom-markers", 
            "text": "A  Plots.Shape  is a light wrapper around vertices of a polygon.  For supported backends, pass arbitrary polygons as the marker shapes.  Note: The center is (0,0) and the size is expected to be rougly the area of the unit circle.  verts   =   [( - 1.0 , 1.0 ),( - 1.28 , 0.6 ),( - 0.2 , - 1.4 ),( 0.2 , - 1.4 ),( 1.28 , 0.6 ),( 1.0 , 1.0 ),( - 1.0 , 1.0 ),( - 0.2 , - 0.6 ),( 0.0 , - 0.2 ),( - 0.4 , 0.6 ),( 1.28 , 0.6 ),( 0.2 , - 1.4 ),( - 0.2 , - 1.4 ),( 0.6 , 0.2 ),( - 0.2 , 0.2 ),( 0.0 , - 0.2 ),( 0.2 , 0.2 ),( - 0.2 , - 0.6 )]  x   =   0.1 : 0.2 : 0.9  y   =   0.7   *   rand ( 5 )   +   0.15  plot ( x , y , line = ( 3 ,: dash ,: lightblue ), marker = ( Shape ( verts ), 30 , RGBA ( 0 , 0 , 0 , 0.2 )), bg = : pink , fg = : darkblue , xlim = ( 0 , 1 ), ylim = ( 0 , 1 ), leg = false )", 
            "title": "Custom Markers"
        }, 
        {
            "location": "/examples/pgfplots/#3d", 
            "text": "n   =   100  ts   =   linspace ( 0 , 8 \u03c0 , n )  x   =   ts   .*   map ( cos , ts )  y   =   ( 0.1 ts )   .*   map ( sin , ts )  z   =   1 : n  plot ( x , y , z , zcolor = reverse ( z ), m = ( 10 , 0.8 ,: blues , stroke ( 0 )), leg = false , cbar = true , w = 5 )  plot! ( zeros ( n ), zeros ( n ), 1 : n , w = 10 )", 
            "title": "3D"
        }, 
        {
            "location": "/examples/pgfplots/#dataframes", 
            "text": "Plot using DataFrame column symbols.  import   RDatasets  iris   =   RDatasets . dataset ( datasets , iris )  scatter ( iris ,: SepalLength ,: SepalWidth , group = : Species , title = My awesome plot , xlabel = Length , ylabel = Width , marker = ( 0.5 ,[: +   : h   : star7 ], 12 ), bg = RGB ( 0.2 , 0.2 , 0.2 ))", 
            "title": "DataFrames"
        }, 
        {
            "location": "/examples/pgfplots/#polar-plots", 
            "text": "\u0398   =   linspace ( 0 , 1.5 \u03c0 , 100 )  r   =   abs ( 0.1   *   randn ( 100 )   +   sin ( 3 \u0398 ))  plot ( \u0398 , r , proj = : polar , m = 2 )", 
            "title": "Polar Plots"
        }, 
        {
            "location": "/examples/pgfplots/#layouts-margins-label-rotation-title-location", 
            "text": "plot ( rand ( 100 , 6 ), layout = @ layout ([ a   b ; c ]), title = [ A   B   C ], title_location = : left , left_margin = [ 20 mm   0 mm ], bottom_margin = 50 px , xrotation = 60 )     Supported arguments:  aspect_ratio ,  background_color ,  background_color_inside ,  bins ,  color_palette ,  fillalpha ,  fillcolor ,  fillrange ,  foreground_color ,  grid ,  group ,  guidefont ,  label ,  layout ,  legend ,  legendfont ,  linealpha ,  linecolor ,  linestyle ,  linewidth ,  markeralpha ,  markercolor ,  markershape ,  markersize ,  markerstrokealpha ,  markerstrokecolor ,  markerstrokewidth ,  seriesalpha ,  seriescolor ,  seriestype ,  show ,  size ,  tickfont ,  title ,  x ,  xflip ,  xguide ,  xlims ,  xrotation ,  xscale ,  xticks ,  y ,  yflip ,  yguide ,  ylims ,  yrotation ,  yscale ,  yticks ,  z ,  zflip ,  zguide ,  zlims ,  zrotation ,  zscale ,  zticks  Supported values for axis:  :auto ,  :left  Supported values for linetype:  :contour ,  :histogram2d ,  :path ,  :path3d ,  :scatter ,  :stepmid ,  :steppost ,  :steppre ,  :xsticks ,  :ysticks  Supported values for linestyle:  :auto ,  :dash ,  :dashdot ,  :dashdotdot ,  :dot ,  :solid  Supported values for marker:  :auto ,  :cross ,  :diamond ,  :dtriangle ,  :circle ,  :none ,  :pentagon ,  :rect ,  :star5 ,  :utriangle ,  :xcross  Is  subplot / subplot!  supported? No   (Automatically generated: 2016-06-09T17:39:13)", 
            "title": "Layouts, margins, label rotation, title location"
        }, 
        {
            "location": "/examples/unicodeplots/", 
            "text": "Examples for backend: unicodeplots\n\n\nInitialize\n\n\nusing\n \nPlots\n\n\nunicodeplots\n()\n\n\n\n\n\n\nLines\n\n\nA simple line plot of the columns.\n\n\nplot\n(\nfakedata\n(\n50\n,\n5\n),\nw\n=\n3\n)\n\n\n\n\n\n\n\n\nParametric plots\n\n\nPlot function pair (x(u), y(u)).\n\n\nplot\n(\nsin\n,(\nx\n-\nbegin\n  \n# /Users/tom/.julia/v0.4/Plots/docs/example_generation.jl, line 50:\n\n            \nsin\n(\n2\nx\n)\n\n        \nend\n),\n0\n,\n2\n\u03c0\n,\nline\n=\n4\n,\nleg\n=\nfalse\n,\nfill\n=\n(\n0\n,:\norange\n))\n\n\n\n\n\n\n\n\nColors\n\n\nAccess predefined palettes (or build your own with the \ncolorscheme\n method).  Line/marker colors are auto-generated from the plot's palette, unless overridden.  Set the \nz\n argument to turn on series gradients.\n\n\ny\n \n=\n \nrand\n(\n100\n)\n\n\nplot\n(\n0\n:\n10\n:\n100\n,\nrand\n(\n11\n,\n4\n),\nlab\n=\nlines\n,\nw\n=\n3\n,\npalette\n=\n:\ngrays\n,\nfill\n=\n(\n0.5\n,:\nauto\n))\n\n\nscatter!\n(\ny\n,\nz\n=\nabs\n(\ny\n \n-\n \n0.5\n),\nm\n=\n(\n10\n,:\nheat\n),\nlab\n=\ngrad\n)\n\n\n\n\n\n\n\n\nGlobal\n\n\nChange the guides/background/limits/ticks.  Convenience args \nxaxis\n and \nyaxis\n allow you to pass a tuple or value which will be mapped to the relevant args automatically.  The \nxaxis\n below will be replaced with \nxlabel\n and \nxlims\n args automatically during the preprocessing step. You can also use shorthand functions: \ntitle!\n, \nxaxis!\n, \nyaxis!\n, \nxlabel!\n, \nylabel!\n, \nxlims!\n, \nylims!\n, \nxticks!\n, \nyticks!\n\n\nplot\n(\nrand\n(\n20\n,\n3\n),\nxaxis\n=\n(\nXLABEL\n,(\n-\n5\n,\n30\n),\n0\n:\n2\n:\n20\n,:\nflip\n),\nbackground_color\n=\nRGB\n(\n0.2\n,\n0.2\n,\n0.2\n),\nleg\n=\nfalse\n)\n\n\ntitle!\n(\nTITLE\n)\n\n\nyaxis!\n(\nYLABEL\n,:\nlog10\n)\n\n\n\n\n\n\n\n\nTwo-axis\n\n\nUse the \naxis\n arguments.\n\n\nNote: Currently only supported with Qwt and PyPlot\n\n\nplot\n(\nVector\n[\nrandn\n(\n100\n),\nrandn\n(\n100\n)\n \n*\n \n100\n],\naxis\n=\n[:\nl\n \n:\nr\n],\nylabel\n=\nLEFT\n,\nyrightlabel\n=\nRIGHT\n)\n\n\n\n\n\n\n\n\nArguments\n\n\nPlot multiple series with different numbers of points.  Mix arguments that apply to all series (marker/markersize) with arguments unique to each series (colors).  Special arguments \nline\n, \nmarker\n, and \nfill\n will automatically figure out what arguments to set (for example, we are setting the \nlinestyle\n, \nlinewidth\n, and \ncolor\n arguments with \nline\n.)  Note that we pass a matrix of colors, and this applies the colors to each series.\n\n\nplot\n(\nVector\n[\nrand\n(\n10\n),\nrand\n(\n20\n)],\nmarker\n=\n(:\ncircle\n,\n8\n),\nline\n=\n(:\ndot\n,\n3\n,[:\nblack\n \n:\norange\n]))\n\n\n\n\n\n\n\n\nBuild plot in pieces\n\n\nStart with a base plot...\n\n\nplot\n(\nrand\n(\n100\n)\n \n/\n \n3\n,\nreg\n=\ntrue\n,\nfill\n=\n(\n0\n,:\ngreen\n))\n\n\n\n\n\n\n\n\n\n\nand add to it later.\n\n\nscatter!\n(\nrand\n(\n100\n),\nmarkersize\n=\n6\n,\nc\n=\n:\norange\n)\n\n\n\n\n\n\n\n\nLine types\n\n\ntypes\n \n=\n \nintersect\n(\nsupported_types\n(),[:\nline\n,:\npath\n,:\nsteppre\n,:\nsteppost\n,:\nsticks\n,:\nscatter\n])\n\n\nn\n \n=\n \nlength\n(\ntypes\n)\n\n\nx\n \n=\n \nVector\n[\nsort\n(\nrand\n(\n20\n))\n \nfor\n \ni\n \n=\n \n1\n:\nn\n]\n\n\ny\n \n=\n \nrand\n(\n20\n,\nn\n)\n\n\nplot\n(\nx\n,\ny\n,\nline\n=\n(\ntypes\n,\n3\n),\nlab\n=\nmap\n(\nstring\n,\ntypes\n),\nms\n=\n15\n)\n\n\n\n\n\n\n\n\nLine styles\n\n\nstyles\n \n=\n \nsetdiff\n(\nsupported_styles\n(),[:\nauto\n])\n\n\nplot\n(\ncumsum\n(\nrandn\n(\n20\n,\nlength\n(\nstyles\n)),\n1\n),\nstyle\n=\n:\nauto\n,\nlabel\n=\nmap\n(\nstring\n,\nstyles\n),\nw\n=\n5\n)\n\n\n\n\n\n\n\n\nMarker types\n\n\nmarkers\n \n=\n \nsetdiff\n(\nsupported_markers\n(),[:\nnone\n,:\nauto\n,\nShape\n])\n\n\nn\n \n=\n \nlength\n(\nmarkers\n)\n\n\nx\n \n=\n \n(\nlinspace\n(\n0\n,\n10\n,\nn\n \n+\n \n2\n))[\n2\n:\nend\n \n-\n \n1\n]\n\n\ny\n \n=\n \nrepmat\n(\nreverse\n(\nx\n)\n,\nn\n,\n1\n)\n\n\nscatter\n(\nx\n,\ny\n,\nm\n=\n(\n8\n,:\nauto\n),\nlab\n=\nmap\n(\nstring\n,\nmarkers\n),\nbg\n=\n:\nlinen\n)\n\n\n\n\n\n\n\n\nBar\n\n\nx is the midpoint of the bar. (todo: allow passing of edges instead of midpoints)\n\n\nbar\n(\nrandn\n(\n999\n))\n\n\n\n\n\n\n\n\nHistogram\n\n\nhistogram\n(\nrandn\n(\n1000\n),\nnbins\n=\n50\n)\n\n\n\n\n\n\n\n\nSubplots\n\n\nsubplot and subplot! are distinct commands which create many plots and add series to them in a circular fashion.\n  You can define the layout with keyword params... either set the number of plots \nn\n (and optionally number of rows \nnr\n or \n  number of columns \nnc\n), or you can set the layout directly with \nlayout\n.\n\n\nsubplot\n(\nrandn\n(\n100\n,\n5\n),\nlayout\n=\n[\n1\n,\n1\n,\n3\n],\nt\n=\n[:\nline\n \n:\nhist\n \n:\nscatter\n \n:\nstep\n \n:\nbar\n],\nnbins\n=\n10\n,\nleg\n=\nfalse\n)\n\n\n\n\n\n\n\n\nAdding to subplots\n\n\nNote here the automatic grid layout, as well as the order in which new series are added to the plots.\n\n\nsubplot\n(\nfakedata\n(\n100\n,\n10\n),\nn\n=\n4\n,\npalette\n=\n[:\ngrays\n \n:\nblues\n \n:\nheat\n \n:\nlightrainbow\n],\nbg\n=\n[:\norange\n \n:\npink\n \n:\ndarkblue\n \n:\nblack\n])\n\n\n\n\n\n\n\n\n\n\nsubplot!\n(\nfakedata\n(\n100\n,\n10\n))\n\n\n\n\n\n\n\n\nCustom Markers\n\n\nA \nPlots.Shape\n is a light wrapper around vertices of a polygon.  For supported backends, pass arbitrary polygons as the marker shapes.  Note: The center is (0,0) and the size is expected to be rougly the area of the unit circle.\n\n\nverts\n \n=\n \n[(\n-\n1.0\n,\n1.0\n),(\n-\n1.28\n,\n0.6\n),(\n-\n0.2\n,\n-\n1.4\n),(\n0.2\n,\n-\n1.4\n),(\n1.28\n,\n0.6\n),(\n1.0\n,\n1.0\n),(\n-\n1.0\n,\n1.0\n),(\n-\n0.2\n,\n-\n0.6\n),(\n0.0\n,\n-\n0.2\n),(\n-\n0.4\n,\n0.6\n),(\n1.28\n,\n0.6\n),(\n0.2\n,\n-\n1.4\n),(\n-\n0.2\n,\n-\n1.4\n),(\n0.6\n,\n0.2\n),(\n-\n0.2\n,\n0.2\n),(\n0.0\n,\n-\n0.2\n),(\n0.2\n,\n0.2\n),(\n-\n0.2\n,\n-\n0.6\n)]\n\n\nplot\n(\n0.1\n:\n0.2\n:\n0.9\n,\n0.7\n \n*\n \nrand\n(\n5\n)\n \n+\n \n0.15\n,\nl\n=\n(\n3\n,:\ndash\n,:\nlightblue\n),\nm\n=\n(\nShape\n(\nverts\n),\n30\n,\nRGBA\n(\n0\n,\n0\n,\n0\n,\n0.2\n)),\nbg\n=\n:\npink\n,\nfg\n=\n:\ndarkblue\n,\nxlim\n=\n(\n0\n,\n1\n),\nylim\n=\n(\n0\n,\n1\n),\nleg\n=\nfalse\n)\n\n\n\n\n\n\n\n\n\n\nSupported arguments: \ngroup\n, \nlabel\n, \nlegend\n, \nlinestyle\n, \nlinetype\n, \nmarkershape\n, \nnbins\n, \nshow\n, \nsize\n, \ntitle\n, \nwindowtitle\n, \nx\n, \nxlabel\n, \nxlims\n, \ny\n, \nylabel\n, \nylims\n\n\nSupported values for axis: \n:auto\n, \n:left\n\n\nSupported values for linetype: \n:bar\n, \n:heatmap\n, \n:hexbin\n, \n:hist\n, \n:hline\n, \n:line\n, \n:none\n, \n:path\n, \n:scatter\n, \n:steppost\n, \n:sticks\n, \n:vline\n\n\nSupported values for linestyle: \n:auto\n, \n:solid\n\n\nSupported values for marker: \n:auto\n, \n:circle\n, \n:none\n\n\nIs \nsubplot\n/\nsubplot!\n supported? Yes\n\n\n\n\n(Automatically generated: 2015-10-18T00:07:46)", 
            "title": "UnicodePlots"
        }, 
        {
            "location": "/examples/unicodeplots/#examples-for-backend-unicodeplots", 
            "text": "", 
            "title": "Examples for backend: unicodeplots"
        }, 
        {
            "location": "/examples/unicodeplots/#initialize", 
            "text": "using   Plots  unicodeplots ()", 
            "title": "Initialize"
        }, 
        {
            "location": "/examples/unicodeplots/#lines", 
            "text": "A simple line plot of the columns.  plot ( fakedata ( 50 , 5 ), w = 3 )", 
            "title": "Lines"
        }, 
        {
            "location": "/examples/unicodeplots/#parametric-plots", 
            "text": "Plot function pair (x(u), y(u)).  plot ( sin ,( x - begin    # /Users/tom/.julia/v0.4/Plots/docs/example_generation.jl, line 50: \n             sin ( 2 x ) \n         end ), 0 , 2 \u03c0 , line = 4 , leg = false , fill = ( 0 ,: orange ))", 
            "title": "Parametric plots"
        }, 
        {
            "location": "/examples/unicodeplots/#colors", 
            "text": "Access predefined palettes (or build your own with the  colorscheme  method).  Line/marker colors are auto-generated from the plot's palette, unless overridden.  Set the  z  argument to turn on series gradients.  y   =   rand ( 100 )  plot ( 0 : 10 : 100 , rand ( 11 , 4 ), lab = lines , w = 3 , palette = : grays , fill = ( 0.5 ,: auto ))  scatter! ( y , z = abs ( y   -   0.5 ), m = ( 10 ,: heat ), lab = grad )", 
            "title": "Colors"
        }, 
        {
            "location": "/examples/unicodeplots/#global", 
            "text": "Change the guides/background/limits/ticks.  Convenience args  xaxis  and  yaxis  allow you to pass a tuple or value which will be mapped to the relevant args automatically.  The  xaxis  below will be replaced with  xlabel  and  xlims  args automatically during the preprocessing step. You can also use shorthand functions:  title! ,  xaxis! ,  yaxis! ,  xlabel! ,  ylabel! ,  xlims! ,  ylims! ,  xticks! ,  yticks!  plot ( rand ( 20 , 3 ), xaxis = ( XLABEL ,( - 5 , 30 ), 0 : 2 : 20 ,: flip ), background_color = RGB ( 0.2 , 0.2 , 0.2 ), leg = false )  title! ( TITLE )  yaxis! ( YLABEL ,: log10 )", 
            "title": "Global"
        }, 
        {
            "location": "/examples/unicodeplots/#two-axis", 
            "text": "Use the  axis  arguments.  Note: Currently only supported with Qwt and PyPlot  plot ( Vector [ randn ( 100 ), randn ( 100 )   *   100 ], axis = [: l   : r ], ylabel = LEFT , yrightlabel = RIGHT )", 
            "title": "Two-axis"
        }, 
        {
            "location": "/examples/unicodeplots/#arguments", 
            "text": "Plot multiple series with different numbers of points.  Mix arguments that apply to all series (marker/markersize) with arguments unique to each series (colors).  Special arguments  line ,  marker , and  fill  will automatically figure out what arguments to set (for example, we are setting the  linestyle ,  linewidth , and  color  arguments with  line .)  Note that we pass a matrix of colors, and this applies the colors to each series.  plot ( Vector [ rand ( 10 ), rand ( 20 )], marker = (: circle , 8 ), line = (: dot , 3 ,[: black   : orange ]))", 
            "title": "Arguments"
        }, 
        {
            "location": "/examples/unicodeplots/#build-plot-in-pieces", 
            "text": "Start with a base plot...  plot ( rand ( 100 )   /   3 , reg = true , fill = ( 0 ,: green ))", 
            "title": "Build plot in pieces"
        }, 
        {
            "location": "/examples/unicodeplots/#line-types", 
            "text": "types   =   intersect ( supported_types (),[: line ,: path ,: steppre ,: steppost ,: sticks ,: scatter ])  n   =   length ( types )  x   =   Vector [ sort ( rand ( 20 ))   for   i   =   1 : n ]  y   =   rand ( 20 , n )  plot ( x , y , line = ( types , 3 ), lab = map ( string , types ), ms = 15 )", 
            "title": "Line types"
        }, 
        {
            "location": "/examples/unicodeplots/#line-styles", 
            "text": "styles   =   setdiff ( supported_styles (),[: auto ])  plot ( cumsum ( randn ( 20 , length ( styles )), 1 ), style = : auto , label = map ( string , styles ), w = 5 )", 
            "title": "Line styles"
        }, 
        {
            "location": "/examples/unicodeplots/#marker-types", 
            "text": "markers   =   setdiff ( supported_markers (),[: none ,: auto , Shape ])  n   =   length ( markers )  x   =   ( linspace ( 0 , 10 , n   +   2 ))[ 2 : end   -   1 ]  y   =   repmat ( reverse ( x ) , n , 1 )  scatter ( x , y , m = ( 8 ,: auto ), lab = map ( string , markers ), bg = : linen )", 
            "title": "Marker types"
        }, 
        {
            "location": "/examples/unicodeplots/#bar", 
            "text": "x is the midpoint of the bar. (todo: allow passing of edges instead of midpoints)  bar ( randn ( 999 ))", 
            "title": "Bar"
        }, 
        {
            "location": "/examples/unicodeplots/#histogram", 
            "text": "histogram ( randn ( 1000 ), nbins = 50 )", 
            "title": "Histogram"
        }, 
        {
            "location": "/examples/unicodeplots/#subplots", 
            "text": "subplot and subplot! are distinct commands which create many plots and add series to them in a circular fashion.\n  You can define the layout with keyword params... either set the number of plots  n  (and optionally number of rows  nr  or \n  number of columns  nc ), or you can set the layout directly with  layout .  subplot ( randn ( 100 , 5 ), layout = [ 1 , 1 , 3 ], t = [: line   : hist   : scatter   : step   : bar ], nbins = 10 , leg = false )", 
            "title": "Subplots"
        }, 
        {
            "location": "/examples/unicodeplots/#adding-to-subplots", 
            "text": "Note here the automatic grid layout, as well as the order in which new series are added to the plots.  subplot ( fakedata ( 100 , 10 ), n = 4 , palette = [: grays   : blues   : heat   : lightrainbow ], bg = [: orange   : pink   : darkblue   : black ])", 
            "title": "Adding to subplots"
        }, 
        {
            "location": "/examples/unicodeplots/#custom-markers", 
            "text": "A  Plots.Shape  is a light wrapper around vertices of a polygon.  For supported backends, pass arbitrary polygons as the marker shapes.  Note: The center is (0,0) and the size is expected to be rougly the area of the unit circle.  verts   =   [( - 1.0 , 1.0 ),( - 1.28 , 0.6 ),( - 0.2 , - 1.4 ),( 0.2 , - 1.4 ),( 1.28 , 0.6 ),( 1.0 , 1.0 ),( - 1.0 , 1.0 ),( - 0.2 , - 0.6 ),( 0.0 , - 0.2 ),( - 0.4 , 0.6 ),( 1.28 , 0.6 ),( 0.2 , - 1.4 ),( - 0.2 , - 1.4 ),( 0.6 , 0.2 ),( - 0.2 , 0.2 ),( 0.0 , - 0.2 ),( 0.2 , 0.2 ),( - 0.2 , - 0.6 )]  plot ( 0.1 : 0.2 : 0.9 , 0.7   *   rand ( 5 )   +   0.15 , l = ( 3 ,: dash ,: lightblue ), m = ( Shape ( verts ), 30 , RGBA ( 0 , 0 , 0 , 0.2 )), bg = : pink , fg = : darkblue , xlim = ( 0 , 1 ), ylim = ( 0 , 1 ), leg = false )     Supported arguments:  group ,  label ,  legend ,  linestyle ,  linetype ,  markershape ,  nbins ,  show ,  size ,  title ,  windowtitle ,  x ,  xlabel ,  xlims ,  y ,  ylabel ,  ylims  Supported values for axis:  :auto ,  :left  Supported values for linetype:  :bar ,  :heatmap ,  :hexbin ,  :hist ,  :hline ,  :line ,  :none ,  :path ,  :scatter ,  :steppost ,  :sticks ,  :vline  Supported values for linestyle:  :auto ,  :solid  Supported values for marker:  :auto ,  :circle ,  :none  Is  subplot / subplot!  supported? Yes   (Automatically generated: 2015-10-18T00:07:46)", 
            "title": "Custom Markers"
        }
    ]
}